
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Web Code Explorer - Upload and Analyze</title>
<style>
    /* Update/add responsive styles */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: #1e1e1e;
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Update container styles */
    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }

    /* Update sidebar styles */
    .sidebar {
      position: fixed;
      left: -100%;
      top: 0;
      width: min(320px, 90vw);
      height: 100vh;
      background: #2d2d2d;
      transition: left 0.3s ease;
      z-index: 1200;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0,0,0,0.2);
      padding: 20px;
      box-sizing: border-box;
    }

    .sidebar.open {
      left: 0;
    }

    /* Update playground and preview styles */
    #playgroundContainer,
    #codeDisplayContainer {
      width: 100%;
      height: 100%;
      padding: 20px;
      box-sizing: border-box;
      overflow: auto;
    }

    #preview-frame {
      width: 100%;
      height: calc(100vh - 200px) !important;
      min-height: 400px;
      border: 1px solid #444;
      border-radius: 4px;
      background: white;
      margin-bottom: 20px;
    }

    /* Update chat window styles */
    .chat-window {
      position: fixed;
      bottom: 90px;
      right: 20px;
      width: min(350px, 90vw);
      height: min(500px, 80vh);
      background: #2d2d2d;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: none;
      flex-direction: column;
      z-index: 1000;
    }

    /* Update help guide styles */
    .help-guide {
      width: min(800px, 90vw);
      max-height: 90vh;
      overflow-y: auto;
    }

    /* Update modal styles */
    #code-review-modal .code-review-content,
    #global-ai-modal .modal-content,
    #ai-edit-modal .ai-modal-content {
      width: min(90%, 600px);
      max-height: 90vh;
      overflow-y: auto;
    }

    /* Add responsive font sizes */
    @media (max-width: 768px) {
      body {
        font-size: 14px;
      }

      h1 { font-size: 1.8em; }
      h2 { font-size: 1.5em; }
      h3 { font-size: 1.2em; }

      .chat-bubble {
        width: 50px;
        height: 50px;
      }

      .chat-bubble svg {
        width: 25px;
        height: 25px;
      }

      .edit-buttons,
      .modal-buttons,
      .code-review-buttons {
        flex-wrap: wrap;
      }

      button {
        padding: 8px 16px;
        font-size: 0.9em;
      }

      .component-library {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      }
    }

    /* Add styles for landscape orientation */
    @media (orientation: landscape) and (max-height: 600px) {
      .sidebar {
        padding: 10px;
      }

      #preview-frame {
        height: calc(100vh - 100px) !important;
      }

      .chat-window {
        height: 70vh;
      }
    }

    /* Add flex styles for component sections */
    .component-category {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .component-library {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 10px;
    }

    /* Make forms more responsive */
    .edit-controls,
    .style-controls,
    .config-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    input[type="text"],
    input[type="password"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 8px;
    }

    /* Update draggable element styles */
    .draggable {
      touch-action: none;
      position: relative !important;
      max-width: 100%;
    }

    .resize-handle {
      min-width: 20px;
      min-height: 20px;
    }
    
    /* Base styles from previous version */
    .edit-buttons {
      display: flex;
      gap: 10px;
      margin: 10px 0;
    }

    .chat-bubble {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      background: #0078d4;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
    }
    .chat-bubble svg {
      width: 30px;
      height: 30px;
      fill: white;
    }
    .chat-window {
      position: fixed;
      bottom: 90px;
      right: 20px;
      width: min(350px, 90vw);
      height: min(500px, 80vh);
      background: #2d2d2d;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: none;
      flex-direction: column;
      z-index: 1000;
    }
    .chat-header {
      padding: 15px;
      background: #1e1e1e;
      border-radius: 8px 8px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .chat-header h3 {
      margin: 0;
      color: #fff;
    }
    .chat-close {
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
      padding: 5px;
    }
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
    }
    .message {
      margin-bottom: 15px;
      max-width: 80%;
    }
    .message.user {
      margin-left: auto;
      background: #0078d4;
      color: white;
      padding: 10px;
      border-radius: 15px 15px 0 15px;
    }
    .message.assistant {
      margin-right: auto;
      background: #3d3d3d;
      color: white;
      padding: 10px;
      border-radius: 15px 15px 15px 0;
    }
    .chat-input {
      padding: 15px;
      border-top: 1px solid #444;
      display: flex;
      gap: 10px;
    }
    .chat-input input {
      flex: 1;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
    }
    .chat-input button {
      padding: 8px 15px;
    }
    .loading-dots {
      display: inline-block;
    }
    .loading-dots:after {
      content: '.';
      animation: dots 1.5s steps(5, end) infinite;
    }
    @keyframes dots {
      0%, 20% {
        content: '.';
      }
      40% {
        content: '..';   
      }
      60% {
        content: '...';
      }
      80%, 100% {
        content: '';
      }
    }
    .chat-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 999;
    }
    .chat-overlay.open {
      display: block;
    }
    .download-button {
      margin-bottom: 15px;
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .download-button:hover {
      background: #218838;
    }
    /* AI Edit Modal Styles */
    #ai-edit-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.6);
    }
    #ai-edit-modal .ai-modal-content {
      background-color: #2d2d2d;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      width: min(90%, 500px);
      max-width: 500px;
      border-radius: 8px;
      color: #fff;
    }
    #ai-edit-modal .ai-modal-close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    #ai-edit-modal .ai-modal-close:hover,
    #ai-edit-modal .ai-modal-close:focus {
      color: #fff;
      text-decoration: none;
      cursor: pointer;
    }
    #ai-edit-modal textarea {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
      resize: vertical;
    }
    #ai-edit-modal .ai-modal-buttons {
      margin-top: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #ai-edit-modal .ai-modal-buttons button {
      padding: 10px 20px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    #ai-edit-modal .ai-modal-buttons button:hover {
      background: #005a9e;
    }
    #ai-edit-loader {
      margin-left: 10px;
    }
    /* Add new styles for the global edit feature */
    #global-ai-edit {
      position: fixed;
      bottom: 20px;
      left: 20px;
      padding: 15px 25px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #global-ai-edit:hover {
      background: #218838;
    }

    #global-ai-edit .loader {
      display: none;
      width: 20px;
      height: 20px;
      border: 2px solid #fff;
      border-top: 2px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    #global-ai-edit.processing {
      pointer-events: none;
      opacity: 0.8;
    }

    #global-ai-edit.processing .loader {
      display: inline-block;
    }

    #global-ai-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.6);
    }

    #global-ai-modal .modal-content {
      background-color: #2d2d2d;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      width: min(90%, 600px);
      max-width: 600px;
      border-radius: 8px;
      color: #fff;
    }

    #global-ai-modal textarea {
      width: 100%;
      min-height: 150px;
      padding: 15px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
      margin: 15px 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      resize: vertical;
    }

    #global-ai-modal .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .changes-summary {
      background: #1e1e1e;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
      font-family: monospace;
      white-space: pre-wrap;
      display: none;
    }

    .changes-summary.show {
      display: block;
    }
    
    /* Add styles for edit mode */
    .code-editor {
      display: none;
      margin: 10px 0;
    }
    .code-editor textarea {
      width: 100%;
      min-height: 200px;
      font-family: 'Consolas', monospace;
      background: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
      padding: 10px;
      border-radius: 4px;
    }
    .editing .code-content {
      display: none;
    }
    .editing .code-editor {
      display: block;
    }
  
  /* Add this to your existing CSS */
.iframe-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
    display: none;
}

.edit-mode-active .iframe-overlay {
    display: block;
}
    /* Originally a grid layout - now overridden below for full screen toggling */
    /* Give each view full viewport height */
    /* Same styles as before */
    .playground {
      background: #2d2d2d;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      height: auto;
      min-height: 100vh;
    }
    .code-display {
      background: #2d2d2d;
      padding: 20px;
      border-radius: 8px;
      overflow-y: auto;
    }
    .code-block {
      background: #1e1e1e;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 10px;
      font-family: 'Consolas', monospace;
    }
    .function-name {
      color: #569cd6;
    }
    .code-content {
      color: #ce9178;
    }
    .dependency-tree {
      margin-left: 20px;
      border-left: 1px solid #569cd6;
      padding-left: 10px;
    }
    .css-rules {
      color: #b5cea8;
      margin-top: 10px;
    }
    .event-handlers {
      color: #dcdcaa;
      margin-top: 10px;
    }
    .js-references {
      margin-top: 20px;
      padding: 10px;
      background: #1e1e1e;
      border-radius: 4px;
    }
    .js-references pre {
      margin: 10px 0;
      padding: 10px;
      background: #2d2d2d;
      border-radius: 4px;
      overflow-x: auto;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #005a9e;
    }
    .highlight {
      background: #264f78;
      transition: background 0.3s;
    }
    #upload-section {
      margin-bottom: 20px;
    }
    /* #preview-frame {
      width: 100%;
      height: 800px !important; 
      border: 1px solid #444;
      border-radius: 4px;
      background: white;
      margin-bottom: 20px;
    } */
    #previewConsole {
      height: 20vh; 
      background: #000;
      color: #0f0;
      font-family: monospace;
      font-size: 0.85em;
      padding: 10px;
      margin-top: 10px;
      overflow-y: auto;
      border: 1px solid #444;
      border-radius: 4px;
    }
    .console-entry {
      margin-bottom: 5px;
    }
    .console-entry.error {
      color: #ff5555;
    }
    .console-entry.warn {
      color: #ffbb33;
    }
    .console-entry.info {
      color: #55ddff;
    }
    .dropzone {
      border: 2px dashed #666;
      padding: 20px;
      text-align: center;
      margin: 10px 0;
      border-radius: 4px;
    }
    .dropzone.dragover {
      border-color: #0078d4;
      background: rgba(0, 120, 212, 0.1);
    }
    .search-section {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
    }
    #searchInput {
      flex: 1;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
    }
    #searchType {
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
    }
    .search-result {
      padding: 10px;
      margin: 5px 0;
      background: #2d2d2d;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .search-result:hover {
      background: #3d3d3d;
    }
    .result-type {
      color: #569cd6;
      font-size: 0.9em;
      margin-right: 10px;
    }
    .result-name {
      color: #ce9178;
    }
    .function-link {
      color: #4fc3f7;
      text-decoration: underline;
      cursor: pointer;
    }
    .function-link:hover {
      color: #81d4fa;
    }
    .navigation-controls {
      margin-bottom: 15px;
    }
    .nav-button {
      padding: 8px 16px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .nav-button:hover:not([disabled]) {
      background: #005a9e;
    }
    .nav-button[disabled] {
      background: #666;
      cursor: not-allowed;
      opacity: 0.6;
    }
    .edit-controls {
      margin: 10px 0;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .edit-prompt {
      flex: 1;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
    }
    .loader {
      display: none;
      width: 24px;
      height: 24px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .loader.active {
      display: inline-block;
    }
    /* Add styles for edit mode */
    .code-editor {
      display: none;
      margin: 10px 0;
    }
    .code-editor textarea {
      width: 100%;
      min-height: 200px;
      font-family: 'Consolas', monospace;
      background: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
      padding: 10px;
      border-radius: 4px;
    }
    .editing .code-content {
      display: none;
    }
    .editing .code-editor {
      display: block;
    }
    /* Add styles for global ai edit modal close button */
    #global-ai-modal .modal-close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      margin-top: -10px;
    }
    #global-ai-modal .modal-close:hover,
    #global-ai-modal .modal-close:focus {
      color: #fff;
      text-decoration: none;
    }
    
    /* Add styles for file browser and zip upload */
    .file-browser {
      background: #2d2d2d;
      border-radius: 8px;
      margin-bottom: 20px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .file-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    
    .file-item {
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
    }
    
    .file-item:hover {
      background: #3d3d3d;
    }
    
    .file-item.active {
      background: #0078d4;
    }
    
    .file-icon {
      margin-right: 8px;
      width: 16px;
      height: 16px;
    }
    
    .file-tree {
      font-family: monospace;
    }
    
    .file-tree-folder {
      margin-left: 15px;
    }
    
    .zip-upload-message {
      text-align: center;
      padding: 10px;
      margin-top: 10px;
      color: #4fc3f7;
    }
    
    /* Add new styles for draggable/resizable elements */
    /* Add new styles for drag and resize functionality */
    .draggable {
      position: relative !important;
      user-select: none;
      touch-action: none;
    }

    .draggable:hover {
      outline: 2px dashed #0078d4;
    }

    .draggable.dragging {
      opacity: 0.8;
      z-index: 1000;
    }

    .resize-handle {
      position: absolute;
      width: 20px;
      height: 20px;
      background: #0078d4;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1001;
    }

    .draggable:hover .resize-handle {
      opacity: 0.8;
    }

    .resize-handle.top-left { top: -10px; left: -10px; cursor: nw-resize; }
    .resize-handle.top-right { top: -10px; right: -10px; cursor: ne-resize; }
    .resize-handle.bottom-left { bottom: -10px; left: -10px; cursor: sw-resize; }
    .resize-handle.bottom-right { bottom: -10px; right: -10px; cursor: se-resize; }

    /* Mobile-specific styles */
    @media (max-width: 768px) {
      .resize-handle {
        width: 30px;
        height: 30px;
        opacity: 0.8;
      }
      
      .resize-handle.top-left { top: -15px; left: -15px; }
      .resize-handle.top-right { top: -15px; right: -15px; }
      .resize-handle.bottom-left { bottom: -15px; left: -15px; }
      .resize-handle.bottom-right { bottom: -15px; right: -15px; }
    }
    
    .resize-control-panel {
      position: relative;
      background: #1e1e1e;
      margin: 10px 0;
      border-radius: 4px;
      display: none;
      padding: 15px;
    }

    .resize-control-panel.active {
      display: block;
    }

    .dimension-group {
      margin-bottom: 15px;
    }

    .style-controls {
      margin-top: 15px;
      border-top: 1px solid #444;
      padding-top: 15px;
    }

    .style-group {
      margin-bottom: 10px;
    }

    .style-group label {
      display: block;
      margin-bottom: 5px;
    }

    .style-group input, .style-group select {
      width: 100%;
      padding: 5px;
      background: #2d2d2d;
      border: 1px solid #444;
      color: #fff;
      border-radius: 4px;
    }

    .color-picker {
      width: 100%;
      height: 40px;
      padding: 5px;
      background: #2d2d2d;
      border: 1px solid #444;
      border-radius: 4px;
    }
    /* Add new styles for the sidebar */
    .sidebar {
      position: fixed;
      left: -100%;
      top: 0;
      width: min(320px, 90vw);
      height: 100vh;
      background: #2d2d2d;
      transition: left 0.3s ease;
      z-index: 1200;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0,0,0,0.2);
      padding: 20px;
      box-sizing: border-box;
    }

    .sidebar.open {
      left: 0;
    }

    .sidebar-toggle {
      position: fixed;
      left: 20px;
      top: 20px;
      z-index: 1201;
      background: #0078d4;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .sidebar-toggle svg {
      width: 20px;
      height: 20px;
      transition: transform 0.3s;
    }

    .sidebar.open + .sidebar-toggle svg {
      transform: rotate(180deg);
    }

    /* Update container padding to accommodate sidebar */
    .container {
      padding-left: 60px !important;
    }

    /* Section titles */
    .sidebar-section {
      margin-bottom: 20px;
    }

    .sidebar-section-title {
      font-size: 1.1em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .sidebar-section-content {
      display: none;
      transition: all 0.3s ease;
    }

    .sidebar-section.expanded .sidebar-section-content {
      display: block;
    }

    .collapse-icon {
      cursor: pointer;
      transition: transform 0.3s;
    }

    .sidebar-section.expanded .collapse-icon {
      transform: rotate(180deg);
    }

    /* Tool toggle styles */
    .tool-toggle {
      padding: 10px;
      background: #1e1e1e;
      border-radius: 4px;
      margin-bottom: 10px;
    }

    .tool-toggle label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .tool-toggle input[type="checkbox"] {
      margin: 0;
    }

    /* Dimension controls */
    .dimension-group {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 10px;
    }

    .dimension-group label {
      min-width: 50px;
    }

    .dimension-group input {
      width: 60px;
      padding: 5px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #2d2d2d;
      color: #fff;
    }

    .dimension-group select {
      padding: 5px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #2d2d2d;
      color: #fff;
    }

    /* Component Library Styles */
    .component-library {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 10px;
    }

    .component-category {
      width: 100%;
      margin-bottom: 15px;
    }

    .component-category-title {
      font-size: 0.9em;
      font-weight: bold;
      margin-bottom: 8px;
      padding-bottom: 5px;
      border-bottom: 1px solid #444;
    }

    .component-item {
      background: #3d3d3d;
      border-radius: 4px;
      padding: 8px;
      cursor: grab;
      transition: transform 0.2s, background 0.2s;
      text-align: center;
    }

    .component-item:hover {
      background: #0078d4;
      transform: translateY(-2px);
    }

    .component-preview {
      font-size: 20px;
      margin-bottom: 4px;
    }

    .component-name {
      font-size: 0.8em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .drop-indicator {
      position: absolute;
      border: 2px dashed #0078d4;
      background: rgba(0, 120, 212, 0.1);
      z-index: 1000;
      pointer-events: none;
      display: none;
    }

    .drop-indicator.active {
      display: block;
    }

    .component-library-toggle,
    .component-library-window {
      display: none;
    }

    .component-tabs {
      display: flex;
      border-bottom: 1px solid #444;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .component-tab {
      padding: 8px 15px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      font-size: 0.9em;
    }

    .component-tab.active {
      border-bottom: 2px solid #0078d4;
      color: #0078d4;
    }
    /* Edit mode controls */
    .edit-mode-controls {
      position: fixed;
      bottom: 20px;
      right: 100px;
      display: flex;
      gap: 10px;
      z-index: 1000;
    }

    .edit-mode-button {
      padding: 10px 15px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .edit-mode-button.active {
      background: #28a745;
    }

    .edit-mode-button.delete {
      background: #dc3545;
    }

    .element-delete-handle {
      position: absolute;
      top: -10px;
      right: -10px;
      width: 20px;
      height: 20px;
      background: #dc3545;
      border-radius: 50%;
      display: none;
      cursor: pointer;
      z-index: 1002;
    }

    .draggable:hover .element-delete-handle {
      display: block;
    }

    .edit-mode-active .draggable {
      outline: 2px dashed #0078d4;
    }

    .edit-mode-active .draggable:hover .resize-handle,
    .edit-mode-active .draggable:hover .element-delete-handle {
      opacity: 1;
    }
    .color-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .transparency-control {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .transparency-control label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .transparency-control input[type="range"] {
      flex: 1;
      min-width: 100px;
    }

    #opacityValue {
      min-width: 48px;
    }
    
    /* New styles for element type controls */
    .element-type {
      padding: 5px 10px;
      background: #444;
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 0.9em;
    }

    .element-type-controls {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #444;
    }

    .image-preview {
      max-width: 100%;
      height: 100px;
      background: #333;
      margin-top: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .image-preview img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    /* Add new styles for code review modal */
    #code-review-modal {
      display: none;
      position: fixed;
      z-index: 2100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      overflow: auto;
    }

    .code-review-content {
      background-color: #2d2d2d;
      margin: 2% auto;
      padding: 20px;
      width: min(90%, 600px);
      height: 85vh;
      border-radius: 8px;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    #code-editor {
      width: 100%;
      height: calc(100% - 60px);
      border-radius: 4px;
      margin-bottom: 15px;
      border: 1px solid #444;
    }

    .code-review-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .code-review-close {
      position: absolute;
      right: 20px;
      top: 10px;
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .code-review-close:hover {
      color: #fff;
    }
    #slashRemovalReport {
      font-family: monospace;
      font-size: 0.9em;
      color: #4fc3f7;
      white-space: pre-wrap;
      word-break: break-word;
    }
  
    .code-review-buttons button {
      margin-right: 10px;
      padding: 8px 16px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
  
    .code-review-buttons button:hover {
      background: #005a9e;
    }
    /* Add new styles for the help guide */
    .help-guide {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(800px, 90vw);
      max-height: 90vh;
      background: #2d2d2d;
      border-radius: 8px;
      padding: 20px;
      z-index: 2200;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      overflow-y: auto;
    }

    .help-guide.open {
      display: block;
    }

    .help-guide h2 {
      margin-top: 0;
      padding-bottom: 10px;
      border-bottom: 1px solid #444;
    }

    .help-guide-section {
      margin: 20px 0;
    }

    .help-guide-section h3 {
      color: #0078d4;
      margin-bottom: 10px;
    }

    .help-guide-section ul {
      list-style-type: none;
      padding-left: 0;
    }

    .help-guide-section li {
      margin: 10px 0;
      padding-left: 20px;
      position: relative;
    }

    .help-guide-section li:before {
      content: "‚Ä¢";
      color: #0078d4;
      position: absolute;
      left: 0;
      top: 0;
    }

    .help-guide .close-button {
      position: absolute;
      right: 20px;
      top: 20px;
      background: none;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
    }

    .help-button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      background: #0078d4;
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 20px;
      cursor: pointer;
      margin: 10px auto;
      transition: background 0.3s;
    }

    .help-button:hover {
      background: #005a9e;
    }

    .help-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 2100;
    }

    .help-overlay.open {
      display: block;
    }
    /* Add styles for create new section */
    .create-new-section {
      padding: 15px;
      margin: 15px 0;
      background: #2d2d2d;
      border-radius: 8px;
      display: none; /* Hidden by default, shown when no project */
    }

    .create-new-section.show {
      display: block;
    }

    .create-new-section h3 {
      margin: 0 0 10px 0;
      color: #fff;
    }

    .create-new-section p {
      color: #aaa;
      font-size: 0.9em;
      margin-bottom: 15px;
    }

    .create-new-section textarea {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      margin-bottom: 10px;
      background: #1e1e1e;
      border: 1px solid #444;
      border-radius: 4px;
      color: #fff;
      font-family: inherit;
      resize: vertical;
    }

    .create-new-section button {
      width: 100%;
      padding: 10px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .create-new-section button:hover {
      background: #218838;
    }

    .create-new-section button.generating {
      background: #666;
      cursor: not-allowed;
    }

    .create-new-section .loader {
      display: none;
      width: 20px;
      height: 20px;
      border: 2px solid #fff;
      border-top: 2px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .create-new-section button.generating .loader {
      display: inline-block;
    }
    .api-config {
      padding: 15px;
      background: #1e1e1e;
      border-radius: 4px;
      margin-top: 10px;
    }

    .config-group {
      margin-bottom: 15px;
    }

    .config-group label {
      display: block;
      margin-bottom: 5px;
      color: #aaa;
      font-size: 0.9em;
    }

    .config-group input {
      width: 100%;
      padding: 8px;
      background: #2d2d2d;
      border: 1px solid #444;
      color: #fff;
      font-family: inherit;
    }

    .save-config-button {
      width: 100%;
      padding: 10px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }

    .save-config-button:hover {
      background: #005a9e;
    }

    .api-status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
      font-size: 0.9em;
      display: none;
    }

    .api-status.success {
      display: block;
      background: rgba(40, 167, 69, 0.2);
      color: #28a745;
    }

    .api-status.error {
      display: block;
      background: rgba(220, 53, 69, 0.2);
      color: #dc3545;
    }
    /* Add these styles to your existing CSS */
    .toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2000;
      pointer-events: none;
    }
    
    .toast {
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 20px;
      margin: 10px;
      text-align: center;
      animation: toast-in 0.3s ease-out;
    }
    
    .toast.fade-out {
      opacity: 0;
      transition: opacity 0.3s ease-out;
    }
    
    @keyframes toast-in {
      from {
        transform: translateY(100%);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    /* Update component items to be more tap-friendly on mobile */
    @media (max-width: 768px) {
      .component-item {
        padding: 15px;
        min-height: 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
      
      .component-item:active {
        transform: scale(0.95);
        background: #005a9e;
      }
      
      .component-preview {
        font-size: 24px;
      }
      
      .component-name {
        font-size: 0.9em;
        margin-top: 5px;
      }
    }

    /* === NEW STYLES FOR AUTH & PROJECT BROWSER === */
    /* User Controls */
    #user-controls {
      padding: 10px 20px;
      background: #1e1e1e;
      border-bottom: 1px solid #444;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    #user-info {
      font-weight: bold;
      margin-right: auto;
    }

    /* General Modal Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      z-index: 3000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.7);
    }
    .modal-overlay .modal-content {
      background-color: #2d2d2d;
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: min(90%, 500px);
      border-radius: 8px;
      color: #fff;
      position: relative;
    }
    .modal-overlay .modal-close {
      color: #aaa;
      position: absolute;
      right: 15px;
      top: 10px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .error-message { color: #dc3545; }
    .success-message { color: #28a745; }

    #auth-form-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    /* Project List Styles */
    #project-list-container {
      max-height: 40vh;
      overflow-y: auto;
      margin-bottom: 20px;
      border: 1px solid #444;
      padding: 10px;
      border-radius: 4px;
    }
    .project-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: #3d3d3d;
      border-radius: 4px;
      margin-bottom: 8px;
    }
    .project-item-name {
      font-weight: bold;
    }
    .project-item-actions button {
      margin-left: 5px;
      padding: 5px 10px;
      font-size: 0.8em;
    }
    .project-item-actions button.delete {
        background-color: #dc3545;
    }
    .project-item-actions button.delete:hover {
        background-color: #c82333;
    }
</style>
</head>
<body>
<div class="sidebar">
  <div id="user-controls">
    <span id="user-info" style="display: none;"></span>
    <button id="auth-button">Login</button>
    <button id="logout-button" style="display: none;">Logout</button>
    <button id="projects-button" style="display: none;">My Projects</button>
    <button id="save-project-button" style="display: none;">Save Project</button>
  </div>
<div class="create-new-section">
  <h3 id="websiteActionTitle">Create New Website</h3>
  <p id="websiteActionDescription">Describe the website you want to create and AI will generate it for you.</p>
  <textarea id="websitePrompt" placeholder="Example: Create a modern portfolio website with a hero section, about me, skills, and contact form. Use a dark theme with blue accents..."></textarea>
  <button onclick="handleWebsiteAction()" id="generateButton">
    <span id="actionButtonText">Generate Website</span>
    <div class="loader"></div>
  </button>
</div>
  <div class="sidebar-section">
    <div class="sidebar-section-title">
      API Configuration
      <span class="collapse-icon">‚ñº</span>
    </div>  
    <div class="sidebar-section-content">
      <div class="api-config">
        <div class="config-group">
          <label for="apiKey">Gemini API Key:</label>
          <input type="password" id="apiKey" placeholder="Enter your Gemini API key">
        </div>
        <button onclick="saveApiConfig()" class="save-config-button">Save Configuration</button>
        <div class="api-status"></div>
      </div>
    </div>
  </div>
  <button class="help-button" onclick="toggleHelpGuide()">?</button>
  <div class="sidebar-section expanded">
    <div class="sidebar-section-title">
      Upload Project
      <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="sidebar-section-content">
      <div id="upload-section">
        <div class="dropzone" id="dropzone">
          Drag &amp; drop HTML file or ZIP archive here or
          <input type="file" id="fileInput" accept=".html,.htm,.zip" style="display: none;">
          <button onclick="document.getElementById('fileInput').click()">Browse</button>
        </div>
        <div class="zip-upload-message" id="zipUploadMessage"></div>
      </div>
    </div>
  </div>

  <div class="sidebar-section expanded">
    <div class="sidebar-section-title">
      Project Files
      <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="sidebar-section-content">
          <button id="editCodeButton" class="download-button">Edit Code</button>
      <div class="file-browser" id="fileBrowser">
        <div class="file-tree" id="fileTree"></div>
      </div>
    </div>
  </div>

  <div class="sidebar-section expanded">
    <div class="sidebar-section-title">
      Element Tools
      <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="sidebar-section-content">
      <div class="tool-toggle">
        <label>
          <input type="checkbox" id="toggleMoveElements"> Enable Element Movement
        </label>
      </div>
      <div class="resize-control-panel">
        <div class="dimension-group">
          <label>Width:</label>
          <input type="number" id="elementWidth" min="0" step="1">
          <select id="widthUnit">
            <option value="px">px</option>
            <option value="%">%</option>
            <option value="vw">vw</option>
          </select>
        </div>
        <div class="dimension-group">
          <label>Height:</label>
          <input type="number" id="elementHeight" min="0" step="1">
          <select id="heightUnit">
            <option value="px">px</option>
            <option value="%">%</option>
            <option value="vh">vh</option>
          </select>
        </div>
        <button onclick="applyDimensions()">Apply Dimensions</button>
        
        <div class="style-controls">
          <div class="style-group">
            <label>Background Color:</label>
            <div class="color-controls">
              <input type="color" id="elementBgColor" class="color-picker">
              <div class="transparency-control">
                <label>
                  <input type="checkbox" id="transparentBg"> Transparent
                </label>
                <input type="range" id="bgOpacity" min="0" max="100" value="100" disabled>
                <span id="opacityValue">100%</span>
              </div>
            </div>
          </div>
          <div class="style-group">
            <label>Text Color:</label>
            <input type="color" id="elementTextColor" class="color-picker">
          </div>
          <div class="style-group">
            <label>Font Size:</label>
            <input type="number" id="elementFontSize" min="0" step="1">
            <select id="fontSizeUnit">
              <option value="px">px</option>
              <option value="em">em</option>
              <option value="rem">rem</option>
            </select>
          </div>
          <div class="style-group">
            <label>Font Family:</label>
            <select id="elementFontFamily">
              <option value="inherit">Default</option>
              <option value="Arial, sans-serif">Arial</option>
              <option value="'Times New Roman', serif">Times New Roman</option>
              <option value="'Courier New', monospace">Courier New</option>
              <option value="Georgia, serif">Georgia</option>
              <option value="Verdana, sans-serif">Verdana</option>
            </select>
          </div>
          <div class="style-group">
            <label>Text Content:</label>
            <input type="text" id="elementTextContent" placeholder="Enter text...">
          </div>
          <div class="style-group">
            <label>Element Type:</label>
            <div id="elementTypeIndicator" class="element-type"></div>
          </div>
          <div id="imageControls" class="element-type-controls" style="display:none;">
            <div class="style-group">
              <label>Replace Image:</label>
              <input type="file" id="imageUpload" accept="image/*">
              <div class="image-preview"></div>
            </div>
            <div class="style-group">
              <label>Alt Text:</label>
              <input type="text" id="imageAlt" placeholder="Describe the image...">
            </div>
          </div>

          <div id="linkControls" class="element-type-controls" style="display:none;">
            <div class="style-group">
              <label>Link URL:</label>
              <input type="url" id="linkUrl" placeholder="https://...">
            </div>
            <div class="style-group">
              <label>Open in new tab:</label>
              <input type="checkbox" id="linkNewTab">
            </div>
          </div>

          <div id="buttonControls" class="element-type-controls" style="display:none;">
            <div class="style-group">
              <label>Button Type:</label>
              <select id="buttonType">
                <option value="button">Button</option>
                <option value="submit">Submit</option>
                <option value="reset">Reset</option>
              </select>
            </div>
          </div>

          <div id="inputControls" class="element-type-controls" style="display:none;">
            <div class="style-group">
              <label>Input Type:</label>
              <select id="inputType">
                <option value="text">Text</option>
                <option value="password">Password</option>
                <option value="email">Email</option>
                <option value="number">Number</option>
                <option value="tel">Phone</option>
                <option value="date">Date</option>
              </select>
            </div>
            <div class="style-group">
              <label>Placeholder:</label>
              <input type="text" id="inputPlaceholder" placeholder="Enter placeholder text...">
            </div>
          </div>
          <button onclick="applyStyles()">Apply Styles</button>
        </div>
      </div>
    </div>
  </div>

  <div class="sidebar-section expanded">
    <div class="sidebar-section-title">
      Component Library
      <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="sidebar-section-content">
      <div class="component-tabs">
        <div class="component-tab active" data-tab="basic">Basic</div>
        <div class="component-tab" data-tab="forms">Forms</div>
        <div class="component-tab" data-tab="media">Media</div>
        <div class="component-tab" data-tab="layout">Layout</div>
      </div>
      <div class="component-library-content">
        <div class="component-category" data-category="basic">
          <div class="component-category-title">Basic Elements</div>
          <div class="component-library">
            <div class="component-item" draggable="true" data-type="heading" data-content="<h1>Heading</h1>">
              <div class="component-preview">H1</div>
              <div class="component-name">Heading</div>
            </div>
            <div class="component-item" draggable="true" data-type="paragraph" data-content="<p>Paragraph text</p>">
              <div class="component-preview">P</div>
              <div class="component-name">Paragraph</div>
            </div>
            <div class="component-item" draggable="true" data-type="button" data-content="<button>Button</button>">
              <div class="component-preview">Btn</div>
              <div class="component-name">Button</div>
            </div>
            <div class="component-item" draggable="true" data-type="link" data-content="<a href='#'>Link</a>">
              <div class="component-preview">A</div>
              <div class="component-name">Link</div>
            </div>
            <div class="component-item" draggable="true" data-type="list" data-content="<ul><li>Item 1</li><li>Item 2</li></ul>">
              <div class="component-preview">UL</div>
              <div class="component-name">List</div>
            </div>
            <div class="component-item" draggable="true" data-type="divider" data-content="<hr>">
              <div class="component-preview">HR</div>
              <div class="component-name">Divider</div>
            </div>
          </div>
        </div>

        <div class="component-category" data-category="forms" style="display:none;">
          <div class="component-category-title">Form Elements</div>
          <div class="component-library">
            <div class="component-item" draggable="true" data-type="form" data-content="<form><input type='text' placeholder='Name'><button type='submit'>Submit</button></form>">
              <div class="component-preview">Form</div>
              <div class="component-name">Form</div>
            </div>
            <div class="component-item" draggable="true" data-type="input" data-content="<input type='text' placeholder='Text input'>">
              <div class="component-preview">Input</div>
              <div class="component-name">Text Input</div>
            </div>
            <div class="component-item" draggable="true" data-type="textarea" data-content="<textarea placeholder='Textarea'></textarea>">
              <div class="component-preview">Textarea</div>
              <div class="component-name">Textarea</div>
            </div>
            <div class="component-item" draggable="true" data-type="select" data-content="<select><option>Option 1</option><option>Option 2</option></select>">
              <div class="component-preview">Select</div>
              <div class="component-name">Dropdown</div>
            </div>
            <div class="component-item" draggable="true" data-type="checkbox" data-content="<label><input type='checkbox'> Checkbox</label>">
              <div class="component-preview">‚úì</div>
              <div class="component-name">Checkbox</div>
            </div>
            <div class="component-item" draggable="true" data-type="radio" data-content="<label><input type='radio' name='group'> Option</label>">
              <div class="component-preview">‚óã</div>
              <div class="component-name">Radio</div>
            </div>
          </div>
        </div>

        <div class="component-category" data-category="media" style="display:none;">
          <div class="component-category-title">Media Elements</div>
          <div class="component-library">
            <div class="component-item" draggable="true" data-type="image" data-content="<img src='https://via.placeholder.com/150' alt='Image'>">
              <div class="component-preview">üñºÔ∏è</div>
              <div class="component-name">Image</div>
            </div>
            <div class="component-item" draggable="true" data-type="video" data-content="<video controls width='250'><source src='' type='video/mp4'></video>">
              <div class="component-preview">üé¨</div>
              <div class="component-name">Video</div>
            </div>
            <div class="component-item" draggable="true" data-type="audio" data-content="<audio controls><source src='' type='audio/mpeg'></audio>">
              <div class="component-preview">üéµ</div>
              <div class="component-name">Audio</div>
            </div>
            <div class="component-item" draggable="true" data-type="iframe" data-content="<iframe src='' width='300' height='150'></iframe>">
              <div class="component-preview">üì∫</div>
              <div class="component-name">Embed</div>
            </div>
          </div>
        </div>

        <div class="component-category" data-category="layout" style="display:none;">
          <div class="component-category-title">Layout Elements</div>
          <div class="component-library">
            <div class="component-item" draggable="true" data-type="container" data-content="<div style='padding: 20px; border: 1px dashed #ccc;'></div>">
              <div class="component-preview">üì¶</div>
              <div class="component-name">Container</div>
            </div>
            <div class="component-item" draggable="true" data-type="row" data-content="<div style='display: flex; gap: 10px; padding: 10px;'></div>">
              <div class="component-preview">‚ÜîÔ∏è</div>
              <div class="component-name">Row</div>
            </div>
            <div class="component-item" draggable="true" data-type="column" data-content="<div style='padding: 10px;'></div>">
              <div class="component-preview">‚ÜïÔ∏è</div>
              <div class="component-name">Column</div>
            </div>
            <div class="component-item" draggable="true" data-type="card" data-content="<div style='border: 1px solid #ccc; border-radius: 8px; padding: 15px;'></div>">
              <div class="component-preview">üÉè</div>
              <div class="component-name">Card</div>
            </div>
            <div class="component-item" draggable="true" data-type="hero" data-content="<div style='background: #f0f0f0; padding: 40px; text-align: center;'><h1>Hero Section</h1><p>Welcome message</p></div>">
              <div class="component-preview">üåü</div>
              <div class="component-name">Hero</div>
            </div>
            <div class="component-item" draggable="true" data-type="footer" data-content="<footer style='background: #333; color: white; padding: 20px; text-align: center;'>Footer content</footer>">
              <div class="component-preview">‚¨áÔ∏è</div>
              <div class="component-name">Footer</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    <div class="code-display hidden" id="codeDisplayContainer">
    <h2>Code Explorer</h2>
    <button onclick="downloadCurrentCode()" class="download-button">Download Updated Code</button>
    <div class="search-section">
      <input type="text" id="searchInput" placeholder="Search for elements or functions...">
      <select id="searchType">
        <option value="all">All</option>
        <option value="elements">Elements</option>
        <option value="functions">Functions</option>
      </select>
      <button onclick="performSearch()">Search</button>
    </div>
    <div id="searchResults"></div>
    <div id="codeOutput"></div>
  </div>

  
</div>

<button class="sidebar-toggle">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M9 18l6-6-6-6"/>
  </svg>
</button>

<!-- Container for playground and code display -->
<div class="container">
  <!-- Playground container: visible by default -->
  <div class="playground" id="playgroundContainer">
    <div style="position: relative;">
      <iframe id="preview-frame" sandbox="allow-same-origin allow-scripts"></iframe>
      <div class="iframe-overlay"></div>
    </div>  
    <!-- New Console Log Interface -->
    <div id="previewConsole"></div>
  </div>
  <!-- Code display container: hidden by default -->
</div>
  
<!-- Toggle view button -->
<button id="toggleViewButton" class="toggle-button">Switch to Code Explorer</button>

<!-- Edit mode controls -->
<div class="edit-mode-controls">
  <button id="toggleEditMode" class="edit-mode-button">Edit Mode</button>
  <button id="deleteElementButton" class="edit-mode-button delete" disabled>Delete Element</button>
</div>
  
<div class="chat-bubble">
  <svg viewBox="0 0 24 24">
    <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
  </svg>
</div>
  
<div class="chat-window">
  <div class="chat-header">
    <h3>Website Assistant</h3>
    <button class="chat-close">&#xd7;</button>
  </div>
  <div class="chat-messages"></div>
  <div class="chat-input">
    <input type="text" placeholder="Ask a question about the website...">
    <button>Send</button>
  </div>
</div>
  
<!-- AI Edit Modal -->
<div id="ai-edit-modal">
  <div class="ai-modal-content">
    <span class="ai-modal-close">&times;</span>
    <h2>Edit Function with AI</h2>
    <p>Enter instructions for editing the function: <span id="ai-function-name"></span></p>
    <textarea id="ai-edit-instructions" placeholder="Type your instructions here..."></textarea>
    <div class="ai-modal-buttons">
      <button id="ai-edit-submit-button">Submit</button>
      <button id="ai-edit-cancel-button">Cancel</button>
      <div class="loader" id="ai-edit-loader"></div>
    </div>
  </div>
</div>
  
<!-- Add new button for global AI edit -->
<button id="global-ai-edit">
  <span>AI Edit Website</span>
  <div class="loader"></div>
</button>

<!-- Add new modal for global AI edit -->
<div id="global-ai-modal">
  <div class="modal-content">
    <span class="modal-close" onclick="closeGlobalAIModal()">&times;</span>
    <h2>Edit Website with AI</h2>
    <p>Describe what changes you want to make to the website:</p>
    <textarea id="global-ai-instructions" placeholder="Example: Add a dark mode toggle button in the top right corner, or Make the search input wider and add a clear button..."></textarea>
    <div class="changes-summary"></div>
    <div class="modal-buttons">
      <button onclick="closeGlobalAIModal()">Cancel</button>
      <button onclick="processGlobalAIEdit()">Apply Changes</button>
    </div>
  </div>
</div>

<!-- Drop indicator for component placement -->
<div class="drop-indicator"></div>

<!-- Add code review modal -->
<div id="code-review-modal">
  <div class="code-review-content">
    <span class="code-review-close">&times;</span>
    <h2>Review and Edit Code</h2>
    <div class="code-review-buttons" style="margin-bottom: 10px;">
      <button onclick="saveCodeChanges()">Save Changes</button>

      <button onclick="removeLeadingSlashes()">Remove Leading Slashes</button>
      <div id="slashRemovalReport" style="display: none; margin: 10px 0; padding: 10px; background: #333; border-radius: 4px; max-height: 100px; overflow-y: auto;"></div>
    </div>
    <div id="code-editor"></div>
    <div class="code-review-buttons">
      <button onclick="closeCodeReview()">Cancel</button>
      <button onclick="confirmAndDownload()">Confirm & Download</button>
    </div>
  </div>
</div>

<!-- Add help guide modal -->
<div class="help-overlay"></div>
<div class="help-guide">
  <button class="close-button" onclick="toggleHelpGuide()">&times;</button>
  <h2>Website Editor User Guide</h2>
  
  <div class="help-guide-section">
    <h3>Getting Started</h3>
    <ul>
      <li>Upload your website by dragging an HTML file or ZIP archive into the upload area</li>
      <li>For multi-file projects, use a ZIP file containing your HTML, CSS, JS, and other assets</li>
      <li>The preview will automatically load your website in the main view</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Basic Navigation</h3>
    <ul>
      <li>Use the "Switch to Code Explorer" button to toggle between preview and code view</li>
      <li>The sidebar contains all your editing tools and can be toggled with the arrow button</li>
      <li>For ZIP projects, use the file browser in the sidebar to navigate between files</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Adding Components</h3>
    <ul>
      <li>First enable "Edit Mode" using the button at the bottom of the screen</li>
      <li>With Edit Mode enabled, find components in the Component Library section of the sidebar</li>
      <li>Drag and drop components directly onto your page</li>
      <li>Use the tabs to switch between different component categories</li>
      <li>Components will automatically become draggable and resizable</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Editing Elements</h3>
    <ul>
      <li>Click "Edit Mode" to enable element editing</li>
      <li>Click any element to select it for editing</li>
      <li>Use the Element Tools in the sidebar to modify properties:</li>
      <li>- Adjust dimensions and positioning</li>
      <li>- Change colors and transparency</li>
      <li>- Modify text content and styling</li>
      <li>- Edit element-specific attributes (links, images, etc.)</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Moving & Resizing</h3>
    <ul>
      <li>Enable "Element Movement" in the sidebar to drag elements (only works when Edit Mode is OFF)</li>
      <li>In Edit Mode, use the corner handles to resize elements</li>
      <li>Use the delete handle (√ó) to remove elements</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>AI Features</h3>
    <ul>
      <li>Use the chat bubble for general website assistance</li>
      <li>Click "AI Edit Website" for making broader changes</li>
      <li>Describe your desired changes in natural language</li>
      <li>Review and approve AI-suggested modifications</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Saving Your Work</h3>
    <ul>
      <li>Click "Switch to Code Explorer" then "Download Updated Code"</li>
      <li>Review your code in the editor before downloading</li>
      <li>Use the "Remove Leading Slashes" tool to fix file paths if needed</li>
      <li>Click "Confirm & Download" to save your changes</li>
      <li>For ZIP projects, all files will be included in the download</li>
    </ul>
  </div>
</div>


<!-- NEW: AUTH & PROJECT BROWSER MODALS -->
<div id="auth-modal" class="modal-overlay">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <h2>Login or Signup</h2>
    <div id="auth-form-container">
      <input type="text" id="auth-username" placeholder="Username">
      <input type="password" id="auth-password" placeholder="Password">
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button id="login-submit">Login</button>
        <button id="signup-submit">Signup</button>
      </div>
      <p id="auth-message" class="error-message"></p>
    </div>
  </div>
</div>

<div id="project-browser-modal" class="modal-overlay">
  <div class="modal-content">
     <span class="modal-close">&times;</span>
     <h2>My Projects</h2>
     <div id="project-list-container">
        <!-- Projects will be listed here -->
        <p>Loading projects...</p>
     </div>
     <button id="create-new-project-button">Start New Local Project</button>
     <p id="project-message"></p>
  </div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.0/ace.js"></script>
<script type="module">
import * as api from './api.js';

// --- STATE MANAGEMENT ---
let currentUser = null;
let currentProjectId = null;
let currentProjectName = 'Untitled Project';

  if (localStorage.getItem('justSaved') === 'true') {
  localStorage.removeItem('justSaved'); // clean up flag
  // Do not run saveProjectToStorage again
} else {
  // Safe to call saveProjectToStorage or other startup logic here
}

const openDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('WebCodeExplorerDB', 1);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('projects')) {
        db.createObjectStore('projects', { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains('files')) {
        const store = db.createObjectStore('files', { keyPath: 'path' });
        store.createIndex('projectId', 'projectId', { unique: false });
      }
    };
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

  
  // Global registries and history
  const functionHistory = [];
  let currentHistoryIndex = -1;
  const functionRegistry = {};
  let styleRegistry = {};
  let eventRegistry = {};
  let currentEditingFunction = null;
  const dropzone = document.getElementById('dropzone');
  const fileInput = document.getElementById('fileInput');
  const previewFrame = document.getElementById('preview-frame');
  let currentWebsiteCode = '';
  const chatBubble = document.querySelector('.chat-bubble');
  const chatWindow = document.querySelector('.chat-window');
  const chatClose = document.querySelector('.chat-close');
  const chatMessages = document.querySelector('.chat-messages');
  const chatInput = document.querySelector('.chat-input input');
  const chatSend = document.querySelector('.chat-input button');
  document.body.insertAdjacentHTML('beforeend', '<div class="chat-overlay"></div>');
  const chatOverlay = document.querySelector('.chat-overlay');
  
  let conversationHistory = [];
  let moveElementsEnabled = false;
  let selectedElement = null;
  let projectFiles = {};
  let isZipProject = false;
  let currentFilePath = '';
  let draggedComponent = null;
  let dropIndicator = document.querySelector('.drop-indicator');
  let editModeEnabled = false;
  let elementToDelete = null;

  const elementPositions = new WeakMap();

  const ProjectStorage = {
  async saveProject() {
    const projectData = {
      isZipProject: isZipProject,
      currentFilePath: currentFilePath,
      currentWebsiteCode: currentWebsiteCode,
      projectFiles: isZipProject ? this.processFilesForStorage(projectFiles) : null,
      lastUpdated: new Date().toISOString()
    };

    try {
      localStorage.setItem('webCodeExplorerProject', JSON.stringify(projectData));
    } catch (e) {
      console.error('Error saving project:', e);
      if (e.name === 'QuotaExceededError') {
        alert('Warning: Project structure saved, but you may need to re-add large files after refresh.');
      }
    }
  },

  processFilesForStorage(files) {
    const result = {};
    for (const [path, file] of Object.entries(files)) {
      // Only store metadata for binary files, not the content
      if (file.type === 'image' || file.type === 'binary') {
        result[path] = {
          type: file.type,
          mimeType: file.mimeType || getMimeType(path),
          size: file.blob?.size || 0,
          isBinary: true
        };
      } else {
        // Store full content for text files
        result[path] = file;
      }
    }
    return result;
  },

  async loadProject() {
    const savedData = localStorage.getItem('webCodeExplorerProject');
    if (!savedData) return false;

    try {
      const projectData = JSON.parse(savedData);
      
      isZipProject = projectData.isZipProject;
      currentFilePath = projectData.currentFilePath;
      currentWebsiteCode = projectData.currentWebsiteCode;
      
      if (isZipProject && projectData.projectFiles) {
        projectFiles = {};
        
        // Restore file references (actual binary files will need to be re-added)
        for (const [path, fileData] of Object.entries(projectData.projectFiles)) {
          if (fileData.isBinary) {
            projectFiles[path] = {
              type: fileData.type,
              mimeType: fileData.mimeType,
              needsReload: true // Flag that this file needs to be re-added
            };
          } else {
            projectFiles[path] = fileData;
          }
        }
        
        renderFileTree();
        if (currentFilePath) {
          await this.loadCurrentFileWithFallback();
        }
      } else if (currentWebsiteCode) {
        await processHTMLContent(currentWebsiteCode);
      }
      
      return true;
    } catch (e) {
      console.error('Error loading project:', e);
      return false;
    }
  },

  async loadCurrentFileWithFallback() {
    try {
      await loadProjectFile(currentFilePath);
    } catch (e) {
      console.warn('Failed to load main file, trying any HTML file');
      const htmlFiles = Object.keys(projectFiles).filter(path => 
        path.endsWith('.html') || path.endsWith('.htm'));
      if (htmlFiles.length > 0) {
        currentFilePath = htmlFiles[0];
        await loadProjectFile(currentFilePath);
      }
    }
  }
};
  
  // Component Library Toggle
  const componentTabs = document.querySelectorAll('.component-tab');
  const componentCategories = document.querySelectorAll('.component-category');

  // Edit mode controls
  const toggleEditModeButton = document.getElementById('toggleEditMode');
  const deleteElementButton = document.getElementById('deleteElementButton');

  // Initialize component library tabs
  componentTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      // Remove active class from all tabs
      componentTabs.forEach(t => t.classList.remove('active'));
      // Add active class to clicked tab
      tab.classList.add('active');
      
      // Hide all categories
      componentCategories.forEach(cat => cat.style.display = 'none');
      // Show selected category
      const category = tab.dataset.tab;
      document.querySelector(`.component-category[data-category="${category}"]`).style.display = 'block';
    });
  });

  // Initialize drag events for components
  const componentItems = document.querySelectorAll('.component-item');
  componentItems.forEach(item => {
    item.addEventListener('dragstart', handleComponentDragStart);
    item.addEventListener('dragend', handleComponentDragEnd);
    item.addEventListener('click', handleComponentTap);
  });

  function handleComponentDragStart(e) {
    draggedComponent = e.target;
    e.target.classList.add('dragging');
    e.dataTransfer.setData('text/plain', e.target.dataset.type);
    e.dataTransfer.effectAllowed = 'copy';
  }

  function handleComponentDragEnd(e) {
    e.target.classList.remove('dragging');
    draggedComponent = null;
    dropIndicator.style.display = 'none';
  }

  function handleComponentTap(e) {
    // Only proceed if we're on mobile
    if (window.innerWidth <= 768) {
      e.preventDefault();
      
      // Get the component data
      const componentData = e.currentTarget.dataset;
      
      // Get frame and document
      const frame = document.getElementById('preview-frame');
      const frameDoc = frame.contentDocument || frame.contentWindow.document;
      
      // Create the new element
      const newElement = frameDoc.createElement('div');
      newElement.innerHTML = componentData.content;
      const elementToInsert = newElement.firstElementChild;
      
      // Make draggable/resizable
      makeElementDraggable(elementToInsert);
      makeElementResizable(elementToInsert);
      
      // Position the element in the center of the viewport
      const frameRect = frame.getBoundingClientRect();
      const viewportHeight = frameDoc.documentElement.clientHeight;
      const scrollTop = frameDoc.documentElement.scrollTop || frameDoc.body.scrollTop;
      
      elementToInsert.style.position = 'absolute';
      elementToInsert.style.left = '50%';
      elementToInsert.style.top = (viewportHeight / 2 + scrollTop) + 'px';
      elementToInsert.style.transform = 'translate(-50%, -50%)';
      elementToInsert.style.zIndex = '1000';
      
      // Add to iframe
      frameDoc.body.appendChild(elementToInsert);
      
      // Update display
      const allElements = frameDoc.getElementsByTagName('*');
      Array.from(allElements).forEach(el => el.classList.remove('highlight'));
      elementToInsert.classList.add('highlight');
      
      // Update website code
      updateWebsiteCode(frameDoc);
      
      // Show a brief feedback toast
      showToast(`Added ${componentData.type} component`);
    }
  }

  function showToast(message) {
    // Create toast container if it doesn't exist
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.className = 'toast-container';
      document.body.appendChild(toastContainer);
    }
    
    // Create and show toast
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    toastContainer.appendChild(toast);
    
    // Remove toast after animation
    setTimeout(() => {
      toast.classList.add('fade-out');
      setTimeout(() => toast.remove(), 300);
    }, 2000);
  }

  // Set up drop events for the preview frame
  const iframeOverlay = document.querySelector('.iframe-overlay');
  iframeOverlay.addEventListener('dragover', handleFrameDragOver);
  iframeOverlay.addEventListener('dragleave', handleFrameDragLeave);
  iframeOverlay.addEventListener('drop', handleFrameDrop);

  function handleFrameDragOver(e) {
    e.preventDefault();
    if (!draggedComponent) return;
    
    const frameRect = previewFrame.getBoundingClientRect();
    const frameDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
    
    // Calculate position relative to iframe
    const x = e.clientX - frameRect.left;
    const y = e.clientY - frameRect.top;
    
    // Show drop indicator at cursor position
    dropIndicator.style.width = '100px';
    dropIndicator.style.height = '50px';
    dropIndicator.style.left = `${e.clientX - 50}px`;
    dropIndicator.style.top = `${e.clientY - 25}px`;
    
    dropIndicator.style.display = 'block';
    dropIndicator.classList.add('active');
  }

  function handleFrameDragLeave(e) {
    e.preventDefault();
    dropIndicator.style.display = 'none';
    dropIndicator.classList.remove('active');
  }

  function handleFrameDrop(e) {
    e.preventDefault();
    dropIndicator.style.display = 'none';
    dropIndicator.classList.remove('active');
    
    if (!draggedComponent) return;
    
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    
    // Calculate position relative to iframe
    const x = e.clientX - frameRect.left;
    const y = e.clientY - frameRect.top;
    
    // Create the new element
    const newElement = frameDoc.createElement('div');
    newElement.innerHTML = draggedComponent.dataset.content;
    const elementToInsert = newElement.firstElementChild;
    
    // Make draggable/resizable
    makeElementDraggable(elementToInsert);
    makeElementResizable(elementToInsert);
    
    // Position the element
    elementToInsert.style.position = 'absolute';
    elementToInsert.style.left = `${x}px`;
    elementToInsert.style.top = `${y}px`;
    elementToInsert.style.zIndex = '1000';
    
    // Add to iframe
    frameDoc.body.appendChild(elementToInsert);
    
    // Update display
    const allElements = frameDoc.getElementsByTagName('*');
    Array.from(allElements).forEach(el => el.classList.remove('highlight'));
    elementToInsert.classList.add('highlight');
    updateWebsiteCode(frameDoc);
  }

  // Update an existing website
// Enhanced update function for full website updates
async function updateWebsite(prompt) {
  const button = document.getElementById('generateButton');
  button.classList.add('generating');
  button.disabled = true;

  try {
    let currentContent = isZipProject ? 
      Object.entries(projectFiles)
        .map(([path, file]) => `=== ${path} ===\n${file.type === 'text' ? file.content : '[Binary/Image file]'}`)
        .join('\n\n') 
      : currentWebsiteCode;

    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-exp-03-25:generateContent?key=${geminiConfig.apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `Update this website according to: ${prompt}\n\nCurrent content:\n${currentContent}`
          }]
        }]
      })
    });

    if (!response.ok) throw new Error(`API request failed: ${response.status}`);
    const data = await response.json();
    const responseText = data.candidates[0].content.parts[0].text;

    if (isZipProject) {
      const updates = JSON.parse(responseText);
      Object.entries(updates.files).forEach(([path, content]) => {
        if (projectFiles[path]) {
          projectFiles[path].content = content;
        } else {
          projectFiles[path] = { type: 'text', content };
        }
      });
      await saveProjectToStorage();
      if (currentFilePath) await loadProjectFile(currentFilePath);
    } else {
      currentWebsiteCode = responseText.match(/<!DOCTYPE html>[\s\S]*<\/html>/i)?.[0] || responseText;
      await saveProjectToStorage();
      await processHTMLContent(currentWebsiteCode);
    }

    setTimeout(() => location.reload(), 500);
  } catch (error) {
    console.error('Error updating website:', error);
    alert('Error updating website: ' + error.message);
  } finally {
    button.classList.remove('generating');
    button.disabled = false;
  }
}

  function updateWebsiteCode(frameDoc) {
    // Get the current HTML content from the iframe
    const htmlContent = frameDoc.documentElement.outerHTML;

    if (isZipProject && projectFiles[currentFilePath]) {
      // Update the specific file's content in projectFiles
      projectFiles[currentFilePath].content = htmlContent;
      // Mark it as potentially needing path restoration during download
      projectFiles[currentFilePath].needsPathRestoration = true;
    } else if (!isZipProject) {
      // Update the main content for single HTML files
      currentWebsiteCode = htmlContent;
    }
    // Note: No immediate path cleanup here; defer to download.
  }
  // Edit mode toggle
  toggleEditModeButton.addEventListener('click', () => {
    editModeEnabled = !editModeEnabled;
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    const overlay = document.querySelector('.iframe-overlay');
    
    if (editModeEnabled) {
      toggleEditModeButton.classList.add('active');
      frameDoc.body.classList.add('edit-mode-active');
      overlay.style.display = 'block';
      
      // Enable all draggable elements
      const draggables = frameDoc.querySelectorAll('.draggable');
      draggables.forEach(el => {
        el.style.cursor = 'move';
      });
    } else {
      toggleEditModeButton.classList.remove('active');
      frameDoc.body.classList.remove('edit-mode-active');
      overlay.style.display = 'none';
      
      // Disable all draggable elements
      const draggables = frameDoc.querySelectorAll('.draggable');
      draggables.forEach(el => {
        el.style.cursor = '';
      });
    }
  });

  // Delete element button
  deleteElementButton.addEventListener('click', () => {
    if (!elementToDelete) return;
    
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    
    // Remove the element from the DOM
    elementToDelete.remove();
    elementToDelete = null;
    deleteElementButton.disabled = true;
    
    // Update the website code
    updateWebsiteCode(frameDoc);
  });

  // Initialize the move elements toggle
  document.getElementById('toggleMoveElements').addEventListener('change', function(e) {
    moveElementsEnabled = e.target.checked;
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    const elements = frameDoc.querySelectorAll('.draggable');
    
    elements.forEach(element => {
      if (moveElementsEnabled) {
        element.style.cursor = 'move';
        // Restore position if it exists
        if (elementPositions.has(element)) {
          const pos = elementPositions.get(element);
          element.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
        }
      } else {
        element.style.cursor = '';
        // Don't reset transform - just disable dragging
      }
    });
  });

  function addMessage(message, sender) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}`;
    messageDiv.textContent = message;
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Add to conversation history
    conversationHistory.push({
      role: sender === "user" ? "user" : "assistant",
      content: message
    });
    
    // Keep only last 10 messages in history
    if (conversationHistory.length > 10) {
      conversationHistory = conversationHistory.slice(-10);
    }
  }

  async function sendMessage() {
    const message = chatInput.value.trim();
    if (!message) return;
    
    chatInput.value = '';
    addMessage(message, 'user');
    
    try {
      // Create system message that includes code context
      let codeContext = '';
      if (isZipProject) {
        codeContext = Object.entries(projectFiles)
          .map(([path, file]) => `${path}:\n${file.type === 'text' ? file.content : '[Binary/Image file]'}`)
          .join('\n\n');
      } else {
        codeContext = currentWebsiteCode;
      }

      const completion = await websim.chat.completions.create({
        messages: [
          {
            role: "system",
            content: `You are a helpful assistant with expertise in web development. You have access to the following website code:\n\n${codeContext}\n\nAnalyze the code to provide accurate and contextual responses.`
          },
          ...conversationHistory
        ]
      });

      addMessage(completion.content, 'assistant');
    } catch (error) {
      console.error('Error sending message:', error);
      addMessage('Sorry, there was an error processing your request. Please try again.', 'assistant');
    }
  }

  // Update the event listeners for chat functionality
  chatBubble.addEventListener('click', () => {
    chatWindow.classList.toggle('open');
    chatOverlay.classList.toggle('open');
  });

  chatClose.addEventListener('click', () => {
    chatWindow.classList.remove('open');
    chatOverlay.classList.remove('open');
  });

  chatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      sendMessage();
    }
  });

  chatSend.addEventListener('click', sendMessage);

  chatOverlay.addEventListener('click', () => {
    chatWindow.classList.remove('open');
    chatOverlay.classList.remove('open');
  });

  // New view toggling globals and functions
  let currentView = "playground"; // "playground" or "code"
  function setView(view) {
    currentView = view;
    if(view === "playground") {
      document.getElementById("playgroundContainer").classList.remove("hidden");
      document.getElementById("codeDisplayContainer").classList.add("hidden");
      document.getElementById("toggleViewButton").textContent = "Switch to Code Explorer";
    } else if(view === "code") {
      document.getElementById("playgroundContainer").classList.add("hidden");
      document.getElementById("codeDisplayContainer").classList.remove("hidden");
      document.getElementById("toggleViewButton").textContent = "Switch to Playground";
    }
  }
  function toggleView() {
    if(currentView === "playground") {
      setView("code");
    } else {
      setView("playground");
    }
  }
  
  // Event listener for toggle button
  document.getElementById('toggleViewButton').addEventListener('click', toggleView);
  
  // File upload and processing
  dropzone.addEventListener('dragover', e => {
    e.preventDefault();
    dropzone.classList.add('dragover');
  });
  dropzone.addEventListener('dragleave', () => {
    dropzone.classList.remove('dragover');
  });
  dropzone.addEventListener('drop', async e => {
    e.preventDefault();
    dropzone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    await handleFile(file);
  });
  fileInput.addEventListener('change', async e => {
    const file = e.target.files[0];
    await handleFile(file);
  });

// Enhanced save function
async function saveProjectToStorage() {
  const db = await openDB();
  const tx = db.transaction(['projects', 'files'], 'readwrite');
  
  // Save project metadata
  const projectData = {
    id: 'current',
    isZipProject,
    currentFilePath,
    currentWebsiteCode,
    lastUpdated: new Date().toISOString()
  };
  tx.objectStore('projects').put(projectData);

  // Save files (including large ones)
  if (isZipProject) {
    for (const [path, file] of Object.entries(projectFiles)) {
      const fileData = {
        path,
        projectId: 'current',
        ...file
      };
      
      // Store blobs directly in IndexedDB
      if (file.blob) {
        fileData.blob = file.blob;
      }
      
      tx.objectStore('files').put(fileData);
    }
  }

  return new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}  

// Enhanced load function
async function loadProjectFromStorage() {
  const db = await openDB();
  
  // Get project metadata
  const projectData = await new Promise((resolve) => {
    const tx = db.transaction('projects');
    tx.objectStore('projects').get('current').onsuccess = (e) => resolve(e.target.result);
  });

  if (!projectData) return false;

  isZipProject = projectData.isZipProject;
  currentFilePath = projectData.currentFilePath;
  currentWebsiteCode = projectData.currentWebsiteCode;

  // Get all files
  if (isZipProject) {
    projectFiles = {};
    const files = await new Promise((resolve) => {
      const tx = db.transaction('files');
      const request = tx.objectStore('files')
        .index('projectId')
        .getAll('current');
      
      request.onsuccess = (e) => resolve(e.target.result);
    });

    for (const fileData of files) {
      projectFiles[fileData.path] = {
        type: fileData.type,
        content: fileData.content,
        blob: fileData.blob,
        url: fileData.blob ? URL.createObjectURL(fileData.blob) : fileData.url
      };
    }
    
    renderFileTree();
    if (currentFilePath) {
      await loadProjectFile(currentFilePath);
    }
  } else if (currentWebsiteCode) {
    await processHTMLContent(currentWebsiteCode);
  }

  return true;
}

  navigator.storage.estimate().then(estimate => {
  console.log(`Using ${estimate.usage} out of ${estimate.quota} bytes`);
});

  async function cleanupOldProjects() {
  const db = await openDB();
  const tx = db.transaction(['projects', 'files'], 'readwrite');
  tx.objectStore('projects').delete('current');
  
  // Delete all files for this project
  const index = tx.objectStore('files').index('projectId');
  index.openCursor('current').onsuccess = (e) => {
    const cursor = e.target.result;
    if (cursor) {
      cursor.delete();
      cursor.continue();
    }
  };
  
  await new Promise((resolve) => { tx.oncomplete = resolve; });
}

  function cleanupBlobUrls() {
  Object.values(projectFiles).forEach(file => {
    if (file.url && file.url.startsWith('blob:')) {
      URL.revokeObjectURL(file.url);
    }
  });
}


  
  // Clear stored project
function clearStoredProject() {
    localStorage.removeItem('webCodeExplorerProject');
    sessionStorage.removeItem('webCodeExplorerProject');
    delete window.tempProjectStorage;
}
// Clear current project
// Updated clear function
async function clearCurrentProject() {
    if (!currentWebsiteCode && Object.keys(projectFiles).length === 0) return;
    
    if (!confirm('Are you sure you want to clear the current project?')) return;

    // Clear all variables
    currentWebsiteCode = '';
    projectFiles = {};
    isZipProject = false;
    currentFilePath = '';
    currentProjectId = null;
    currentProjectName = 'Untitled Project';

    
    // Clear the preview iframe
    const frame = document.getElementById('preview-frame');
    if (frame) {
        const frameDoc = frame.contentDocument || frame.contentWindow.document;
        frameDoc.open();
        frameDoc.write('<html><head><title>Cleared</title></head><body></body></html>');
        frameDoc.close();
    }
    
    // Clear file browser
    const fileTree = document.getElementById('fileTree');
    if (fileTree) fileTree.innerHTML = '';
    
    // Clear any upload messages
    const uploadMessage = document.getElementById('zipUploadMessage');
    if (uploadMessage) uploadMessage.textContent = '';
    
    // Clear storage
    clearStoredProject();
    
    // Reset UI
    checkForProject();
    
    // Show create new section
    const createSection = document.querySelector('.create-new-section');
    if (createSection) createSection.classList.add('show');
}  
async function handleFile(file) {
  // Clear current project first
  currentWebsiteCode = '';
  projectFiles = {};
  isZipProject = false;
  currentFilePath = '';
  currentProjectId = null; // New project, not from cloud
  currentProjectName = file.name;
  clearStoredProject();
  
  if (!file) {
    checkForProject();
    return;
  }
  
  if (file.type.includes('html')) {
    // Single HTML file
    document.getElementById('fileBrowser').style.display = 'none';
    document.getElementById('zipUploadMessage').textContent = '';
    const content = await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = e => resolve(e.target.result);
      reader.readAsText(file);
    });
    processHTMLContent(content);
  } else if (file.name.endsWith('.zip')) {
    // ZIP file handling
    isZipProject = true;
    document.getElementById('zipUploadMessage').textContent = 'Extracting ZIP archive...';
    
    try {
      await extractZipFile(file);
      document.getElementById('zipUploadMessage').textContent = 'ZIP extracted successfully!';
      document.getElementById('fileBrowser').style.display = 'block';
      
      // Find the first HTML file to display
      const htmlFiles = Object.keys(projectFiles).filter(path => path.endsWith('.html') || path.endsWith('.htm'));
      if (htmlFiles.length > 0) {
        renderFileTree();
        await loadProjectFile(htmlFiles[0]);
      } else {
        document.getElementById('zipUploadMessage').textContent = 'No HTML files found in the ZIP archive.';
        checkForProject();
      }
    } catch (error) {
      console.error('Error extracting ZIP:', error);
      document.getElementById('zipUploadMessage').textContent = 'Error extracting ZIP: ' + error.message;
      checkForProject();
    }
  } else {
    alert('Please upload an HTML file or ZIP archive');
    checkForProject();
  }
}  
  async function extractZipFile(zipFile) {
    const zipJsLib = 'https://cdn.jsdelivr.net/npm/@zip.js/zip.js/dist/zip.min.js';
    
    // Load zip.js library if not already loaded
    if (!window.zip) {
       await new Promise((resolve, reject) => {
         const script = document.createElement('script');
         script.src = zipJsLib;
         script.onload = resolve;
         script.onerror = reject;
         document.head.appendChild(script);
       });
    }
    
    const reader = new zip.ZipReader(new zip.BlobReader(zipFile));
    const entries = await reader.getEntries();
    
    // Process all entries
    for (const entry of entries) {
      if (!entry.directory) {
        try {
          // First check if it's an image file
          const isImage = /\.(jpg|jpeg|png|gif|svg|webp|ico)$/i.test(entry.filename);
          
          if (isImage) {
            // For images, get as blob and create object URL
            const blob = await entry.getData(
              new zip.BlobWriter(getMimeType(entry.filename))
            );
            projectFiles[entry.filename] = {
              type: 'image',
              url: URL.createObjectURL(blob),
              blob: blob
            };
          } else {
            // Try to get as text first (for HTML, CSS, JS files)
            try {
              const content = await entry.getData(
                new zip.TextWriter()
              );
              projectFiles[entry.filename] = {
                type: 'text',
                content: content
              };
            } catch (e) {
              // If text extraction fails, get as binary
              const binaryContent = await entry.getData(
                new zip.BlobWriter(getMimeType(entry.filename))
              );
              projectFiles[entry.filename] = {
                type: 'binary',
                url: URL.createObjectURL(binaryContent),
                blob: binaryContent
              };
            }
          }
        } catch (binError) {
          console.error(`Failed to extract file ${entry.filename}:`, binError);
        }
      }
    }
    
    await reader.close();
  }
  
  function resolveRelativePath(baseDir, relativePath) {
    // Handle absolute paths within the zip
    if (relativePath.startsWith('/')) {
      // Absolute path within the zip
      return relativePath.substring(1);
    }
    
    const baseParts = baseDir.split('/').filter(Boolean);
    const relativeParts = relativePath.split('/').filter(Boolean);
    
    let resultParts = [...baseParts];
    
    for (let i = 0; i < relativeParts.length; i++) {
      if (relativeParts[i] === '..') {
        resultParts.pop();
      } else if (relativeParts[i] === '.') {
        // Do nothing for current directory
      } else {
        resultParts.push(relativeParts[i]);
      }
    }
    
    return resultParts.join('/');
  }
  
  function rewriteResourcePaths(htmlContent) {
    if (!isZipProject) return htmlContent;
    
    const tempContainer = document.createElement('div');
    tempContainer.innerHTML = htmlContent;
    
    // Get the directory of the current HTML file
    const currentDir = currentFilePath.substring(0, currentFilePath.lastIndexOf('/') + 1);

    // Process script tags
    Array.from(tempContainer.getElementsByTagName('script')).forEach(script => {
      if (script.src && !script.src.startsWith('http') && !script.src.startsWith('data:')) {
        const relativePath = resolveRelativePath(currentDir, script.src);
        if (projectFiles[relativePath]) {
          // Create a blob URL for the script
          const blob = new Blob([projectFiles[relativePath]], {type: 'application/javascript'});
          script.src = URL.createObjectURL(blob);
        }
      }
    });
    
    // Process links (CSS)
    Array.from(tempContainer.getElementsByTagName('link')).forEach(link => {
      if (link.rel === 'stylesheet' && link.href && !link.href.startsWith('http')) {
        const relativePath = resolveRelativePath(currentDir, link.href);
        if (projectFiles[relativePath]) {
          // Create a blob URL for the CSS
          const blob = new Blob([projectFiles[relativePath]], {type: 'text/css'});
          link.href = URL.createObjectURL(blob);
        }
      }
    });
    
    // Process images
    Array.from(tempContainer.querySelectorAll('img')).forEach(img => {
      if (img.src && !img.src.startsWith('http') && !img.src.startsWith('data:')) {
        const relativePath = resolveRelativePath(currentDir, img.src);
        if (projectFiles[relativePath]) {
          // For images, we need to determine the MIME type
          const mimeType = getMimeType(relativePath);
          const blob = new Blob([new TextEncoder().encode(projectFiles[relativePath])], {type: mimeType});
          img.src = URL.createObjectURL(blob);
        }
      }
    });
    
    return tempContainer.innerHTML;
  }
  
  function renderFileTree() {
    const fileTree = document.getElementById('fileTree');
    fileTree.innerHTML = '';
    
    // Create a hierarchical structure for files
    const fileStructure = {};
    
    Object.keys(projectFiles).forEach(path => {
      const parts = path.split('/').filter(Boolean);
      let current = fileStructure;
      
      parts.forEach((part, index) => {
        if (index === parts.length - 1) {
          // It's a file
          current[part] = path;
        } else {
          // It's a directory
          if (!current[part]) {
            current[part] = {};
          }
          current = current[part];
        }
      });
    });
    
    // Render the file tree
    renderFileStructure(fileStructure, fileTree, '');
  }
  
  function renderFileStructure(structure, container, prefix) {
    const ul = document.createElement('ul');
    ul.className = 'file-list';
    
    Object.keys(structure).sort().forEach(key => {
      const value = structure[key];
      
      if (typeof value === 'string') {
        // It's a file
        const fileType = key.split('.').pop().toLowerCase();
        const icon = getFileIcon(fileType);
        
        const li = document.createElement('li');
        li.className = 'file-item';
        li.innerHTML = `
          <span class="file-icon">${icon}</span>
          <span>${key}</span>
        `;
        li.addEventListener('click', () => loadProjectFile(value));
        li.dataset.path = value;
        
        if (value === currentFilePath) {
          li.classList.add('active');
        }
        ul.appendChild(li);
      } else {
        // It's a directory
        const li = document.createElement('li');
        li.innerHTML = `<strong>${key}/</strong>`;
        const folderDiv = document.createElement('div');
        folderDiv.className = 'file-tree-folder';
        li.appendChild(folderDiv);
        renderFileStructure(value, folderDiv, prefix + key + '/');
        ul.appendChild(li);
      }
    });
    
    container.appendChild(ul);
  }
  
  function getFileIcon(fileType) {
    const icons = {
      'html': 'üìÑ',
      'htm': 'üìÑ',
      'css': 'üé®',
      'js': 'üîß',
      'json': 'üìã',
      'png': 'üñºÔ∏è',
      'jpg': 'üñºÔ∏è',
      'jpeg': 'üñºÔ∏è',
      'gif': 'üñºÔ∏è',
      'svg': 'üñºÔ∏è',
      'webp': 'üñºÔ∏è',
      'ico': 'üñºÔ∏è',
      'txt': 'üìù'
    };
    
    return icons[fileType] || 'üìÑ';
  }
  
  async function loadProjectFile(filePath) {
    if (!projectFiles[filePath]) {
      console.error('File not found:', filePath);
      return;
    }

    currentFilePath = filePath;

    // Update file tree UI
    const fileItems = document.querySelectorAll('.file-item');
    fileItems.forEach(item => item.classList.remove('active'));
    const activeItem = document.querySelector(`.file-item[data-path="${filePath}"]`);
    if (activeItem) activeItem.classList.add('active');

    const fileData = projectFiles[filePath];
    const fileType = filePath.split('.').pop().toLowerCase();

    if (fileData.type === 'image') {
      displayImageFile(filePath, fileData.url);
    } else if (fileData.type === 'text') {
      if (fileType === 'html' || fileType === 'htm') {
        // Start with the canonical content stored in projectFiles
        let htmlContent = fileData.content;
        const baseDir = filePath.substring(0, filePath.lastIndexOf('/') + 1);

        // Use DOMParser for safer modification before writing to iframe
        const parser = new DOMParser();
        const tempDoc = parser.parseFromString(htmlContent, 'text/html');
        
        // Create promises for resolving resources
        const resourcePromises = [];

        // Function to resolve a resource path and update the element attribute
        const resolveAndUpdate = (element, attribute, mimeTypeHint = null) => {
            const originalPath = element.getAttribute(attribute);
            if (originalPath && !originalPath.startsWith('http') && !originalPath.startsWith('data:')) {
                const resourcePath = resolveRelativePath(baseDir, originalPath);
                const resource = projectFiles[resourcePath];
                if (resource) {
                    let promise;
                    if (resource.type === 'image' || resource.type === 'binary') {
                        promise = Promise.resolve(resource.url);
                    } else if (resource.type === 'text') {
                        const mimeType = mimeTypeHint || getMimeType(resourcePath);
                        const blob = new Blob([resource.content], { type: mimeType });
                        const blobUrl = URL.createObjectURL(blob);
                        // Store blob URL temporarily for potential later cleanup if needed
                        resource.tempBlobUrl = blobUrl;
                        promise = Promise.resolve(blobUrl);
                    } else {
                         promise = Promise.resolve(originalPath); // Keep original if type unknown/unsupported
                    }

                    resourcePromises.push(
                        promise.then(resolvedUrl => {
                            if (resolvedUrl !== originalPath) {
                                element.setAttribute(attribute, resolvedUrl);
                                // Add a data attribute to track the original path for download restoration
                                element.setAttribute('data-original-path', originalPath);
                            }
                        }).catch(err => {
                           console.warn(`Could not resolve resource ${originalPath} for preview: ${err}`);
                        })
                    );
                } else {
                   console.warn(`Resource not found in project: ${resourcePath} (from ${originalPath})`);
                }
            }
        };

        // Process elements that load external resources
        tempDoc.querySelectorAll('img[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('video[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('audio[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('source[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('track[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('embed[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('iframe[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('script[src]').forEach(el => resolveAndUpdate(el, 'src', 'application/javascript'));
        tempDoc.querySelectorAll('link[rel="stylesheet"][href]').forEach(el => resolveAndUpdate(el, 'href', 'text/css'));
        tempDoc.querySelectorAll('link[rel*="icon"][href]').forEach(el => resolveAndUpdate(el, 'href')); // Favicons etc.

        // Process inline styles with url()
        tempDoc.querySelectorAll('[style*="url("]').forEach(element => {
            let style = element.getAttribute('style');
            // Match blob URLs within url()
            style = style.replace(/url\(['"]?([^'")\s]+)['"]?\)/g, (match, blobUrl) => {
                let originalRelativePath = null;
                for (const [p, f] of Object.entries(projectFiles)) {
                    if (f.url === blobUrl || f.tempBlobUrl === blobUrl) {
                        originalRelativePath = resolveRelativePath(baseDir, p);
                        break;
                    }
                }
                if (originalRelativePath) {
                    console.log(`Restored style url() for ${blobUrl} to ${originalRelativePath}`);
                    return `url(${originalRelativePath})`;
                } else {
                    console.warn(`Could not find original path for style blob URL: ${blobUrl} in ${baseDir}`);
                    return match; // Keep original if not found
                }
            });
            element.setAttribute('style', style);
        });


        // Wait for all resources to be resolved before processing content
        await Promise.all(resourcePromises);

        // Serialize the modified document back to string for iframe loading
        const processedHtmlForPreview = tempDoc.documentElement.outerHTML;
        processHTMLContent(processedHtmlForPreview); // Load the processed HTML into the iframe

      } else {
        // Handle non-HTML text files (display as plain text or specific editor)
        displayTextFile(filePath, fileData.content);
      }
    } else if (fileData.type === 'binary') {
      displayBinaryFile(filePath, fileData.url);
    }
  }

  // Add helper function to display non-HTML text files
  function displayTextFile(filePath, content) {
      const frame = document.getElementById('preview-frame');
      const frameDoc = frame.contentDocument || frame.contentWindow.document;
      frameDoc.open();
      frameDoc.write(`
          <!DOCTYPE html>
          <html>
          <head>
              <title>${filePath}</title>
              <style>
                  body { background-color: #1e1e1e; color: #d4d4d4; font-family: monospace; white-space: pre; }
              </style>
          </head>
          <body>${escapeHtml(content)}</body>
          </html>
      `);
      frameDoc.close();
      // Clear code explorer details
      document.getElementById('codeOutput').innerHTML = `Displaying non-HTML file: ${filePath}`;
  }

  // Add helper function for binary files (if needed)
   function displayBinaryFile(filePath, url) {
      const frame = document.getElementById('preview-frame');
      const frameDoc = frame.contentDocument || frame.contentWindow.document;
      frameDoc.open();
      frameDoc.write(`
          <!DOCTYPE html>
          <html>
          <head><title>${filePath}</title></head>
          <body style="background:#1e1e1e; color:white; padding:20px;">
              <h2>Binary File</h2>
              <p>Cannot display content for: ${filePath}</p>
              <p><a href="${url}" download="${filePath.split('/').pop()}" style="color:#4fc3f7;">Download File</a></p>
          </body>
          </html>
      `);
      frameDoc.close();
      document.getElementById('codeOutput').innerHTML = `Displaying binary file: ${filePath}`;
   }

  async function handleAIEdit(prompt, content, loaderElement = null) {
    try {
      if (loaderElement) {
        loaderElement.classList.add('active');
      } else {
        document.querySelector('.loader').classList.add('active');
      }

      // Use websim.chat.completions API instead of fetch
      const response = await websim.chat.completions.create({
        messages: [
          {
            role: "system",
            content: `You are an expert web developer assistant. Edit the provided HTML/CSS/JS code based on the given instructions.
            Return ONLY the modified code without any explanations or markdown formatting.
            Preserve existing functionality while making the requested changes.`
          },
          {
            role: "user", 
            content: `Edit this code according to these instructions: ${prompt}

Original code:
${content}

Return only the edited code, maintaining the same format and structure.`
          }
        ]
      });

      return response.content;
      
    } catch (error) {
      console.error('Error getting AI edit:', error);
      return null;
    } finally {
      if (loaderElement) {
        loaderElement.classList.remove('active');
      } else {
        document.querySelector('.loader').classList.remove('active'); 
      }
    }
  }
  
  function handleElementClick(e) {
    const element = e.target;
    const allElements = e.target.ownerDocument.getElementsByTagName('*');
    Array.from(allElements).forEach(el => {
      el.classList.remove('highlight');
    });
    element.classList.add('highlight');
    
    // Update resize panel and keep sidebar open when clicking draggable elements
    if (element.classList.contains('draggable')) {
      updateResizePanel(element);
      //document.querySelector('.sidebar').classList.add('open');
    } else {
      //document.querySelector('.sidebar').classList.remove('open');
    }
    
    functionHistory.length = 0;
    currentHistoryIndex = -1;
    functionHistory.push({
      type: 'element',
      element: element,
      content: generateElementContent(element)
    });
    currentHistoryIndex = 0;
    displayElementInfo(element);
    
    // Enable delete button if in edit mode
    if (editModeEnabled) {
      elementToDelete = element;
      deleteElementButton.disabled = false;
    }
  }
  
  function generateElementContent(element) {
    let output = `
      <div class="edit-controls">
        <input type="text" class="edit-prompt" placeholder="Enter instructions to edit this content...">
        <button onclick="editCurrentContent(this)">Edit with AI</button>
        <div class="loader"></div>
      </div>
      <div class="code-block">
        <h3>Element: ${element.tagName ? element.tagName.toLowerCase() : 'unknown'}</h3>
        <pre class="code-content">${escapeHtml(element.outerHTML || '')}</pre>
      </div>
    `;
    const styles = getApplicableStyles(element);
    output += `
      <div class="css-rules">
        <h4>CSS Rules:</h4>
        <pre>${escapeHtml(styles)}</pre>
      </div>
    `;
    const eventHandlers = getEventHandlers(element);
    output += `
      <div class="event-handlers">
        <h4>Event Handlers:</h4>
        <pre>${escapeHtml(JSON.stringify(eventHandlers, null, 2))}</pre>
      </div>
    `;
    const relatedFunctions = getRelatedFunctions(element);
    if (relatedFunctions && relatedFunctions.length > 0) {
      output += `<div class="dependency-tree">
              <h4>Related Functions:</h4>
              ${relatedFunctions.map(func => displayFunctionAndDependencies(func)).join('')}
          </div>`;
    }
    const jsReferences = findJavaScriptReferences(element);
    if (jsReferences && jsReferences.length > 0) {
      output += `<div class="js-references">
              <h4>JavaScript References:</h4>
              ${jsReferences.map(code => `<pre class="code-content">${code}</pre>`).join('')}
          </div>`;
    }
    output += '</div>';
    const codeOutput = document.getElementById('codeOutput');
    if (codeOutput) {
      codeOutput.innerHTML = output;
    }
  }
  
  function displayElementInfo(element) {
    // Display the clicked element's details by reusing the generateElementContent() function.
    generateElementContent(element);
  }

  function getApplicableStyles(element) {
    let styles = '';
    for (const rule in styleRegistry) {
      // Skip selectors that are CSS at-rules (e.g., @keyframes, @media) which are not valid for element.matches
      if (rule.trim().startsWith('@')) continue;
      try {
        if (element.matches(rule)) {
          styles += styleRegistry[rule] + '\n';
        }
      } catch (e) {
        console.error(`Invalid selector '${rule}':`, e);
      }
    }
    return styles || 'No specific CSS rules found';
  }
  
  function getEventHandlers(element) {
    if (!element || !element.tagName) return 'No event handlers found';
    const tagName = element.tagName.toLowerCase();
    return eventRegistry[tagName] || 'No event handlers found';
  }
  
  function getRelatedFunctions(element) {
    if (!element || !element.attributes) return [];
    const functions = [];
    const attributes = element.attributes;
    Array.from(attributes).forEach(attr => {
      if (attr && attr.name && attr.name.startsWith('on')) {
        const functionName = attr.value.replace('()', '');
        if (functionRegistry[functionName]) {
          functions.push(functionName);
        }
      }
    });
    return functions;
  }
  
  function displayFunctionAndDependencies(functionName, level = 0) {
    if (!functionName || !functionRegistry[functionName]) return '';
    const func = functionRegistry[functionName];
    const indent = '  '.repeat(level);
    let output = `<div class="code-block">
          <span class="function-name">${escapeHtml(functionName)}</span>
          <div class="edit-buttons">
            <button onclick="toggleCodeEdit(this, '${functionName}')">Edit Manually</button>
            <button onclick="saveCodeEdit(this, '${functionName}')">Save Changes</button>
            <button onclick="editFunctionWithAI('${functionName}')">Edit with AI</button>
          </div>
          <pre class="code-content">${addFunctionLinks(escapeHtml(func.code || ''))}</pre>
          <div class="code-editor">
            <textarea>${escapeHtml(func.code || '')}</textarea>
          </div>`;
    if (func.dependencies && func.dependencies.length > 0) {
      output += `<div class="dependency-tree">
              <h4>Dependencies:</h4>
              ${func.dependencies.map(dep => displayFunctionAndDependencies(dep, level + 1)).join('')}
          </div>`;
    }
    output += '</div>';
    return output;
  }
  
  function addFunctionLinks(code) {
    const functionNames = Object.keys(functionRegistry);
    functionNames.sort((a, b) => b.length - a.length);
    let linkedCode = code;
    functionNames.forEach(funcName => {
      const regex = new RegExp(`\\b(${funcName})\\b(?=\\s*\\(|\\s*=\\s*function|\\s*=\\s*\\(|\\s*=>)`, 'g');
      linkedCode = linkedCode.replace(regex, `<span class="function-link" onclick="showFunction('${funcName}')">${funcName}</span>`);
    });
    return linkedCode;
  }
  
  function showFunction(functionName) {
    if (currentHistoryIndex < functionHistory.length - 1) {
      functionHistory.splice(currentHistoryIndex + 1);
    }
    functionHistory.push({
      type: 'function',
      name: functionName,
      content: displayFunctionAndDependencies(functionName)
    });
    currentHistoryIndex = functionHistory.length - 1;
    const output = `<div class="navigation-controls">
              <button ${currentHistoryIndex > 0 ? '' : 'disabled'} onclick="navigateHistory('back')" class="nav-button">
                  ‚Üê Back
              </button>
          </div>
          <div class="code-block">
              ${functionHistory[currentHistoryIndex].content}
          </div>`;
    document.getElementById('codeOutput').innerHTML = output;
  }
  
  function navigateHistory(direction) {
    if (direction === 'back' && currentHistoryIndex > 0) {
      currentHistoryIndex--;
      const previous = functionHistory[currentHistoryIndex];
      const output = `
          <div class="navigation-controls">
              <button ${currentHistoryIndex > 0 ? '' : 'disabled'} onclick="navigateHistory('back')" class="nav-button">
                  ‚Üê Back
              </button>
          </div>
          <div class="code-block">
              ${previous.content}
          </div>`;
      document.getElementById('codeOutput').innerHTML = output;
      if (previous.type === 'element' && previous.element) {
        const allElements = previous.element.ownerDocument.getElementsByTagName('*');
        Array.from(allElements).forEach(el => {
          el.classList.remove('highlight');
        });
        previous.element.classList.add('highlight');
      }
    }
  }
  
  function findJavaScriptReferences(element) {
    const references = [];
    const id = element.id;
    const classes = Array.from(element.classList);
    const tagName = element.tagName.toLowerCase();
    const scripts = Array.from(element.ownerDocument.getElementsByTagName('script'));
    scripts.forEach(script => {
      if (!script.textContent) return;
      const content = script.textContent;
      const patterns = [
        id ? new RegExp(`(getElementById\\(['"']${id}['"']\\)|#${id}|document\\.${id}|\\[['"]#${id}['"]]|querySelector\\(['"']#${id}['"']\\))`, 'g') : null,
        ...classes.map(cls => new RegExp(`(getElementsByClassName\\(['"']${cls}['"']\\)|\\.${cls}|querySelector\\(['"']\\.${cls}['"']\\))`, 'g')),
        new RegExp(`(getElementsByTagName\\(['"']${tagName}['"']\\)|querySelector\\(['"']${tagName}['"']\\))`, 'g')
      ].filter(Boolean);
      patterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(content)) !== null) {
          let blockStart = content.lastIndexOf('{', match.index);
          let contextStart = blockStart;
          const searchStartIndex = Math.max(0, blockStart - 500);
          const beforeContext = content.substring(searchStartIndex, blockStart);
          const functionDeclaration = beforeContext.match(/(?:async\s+)?function\s+(\w+)\s*\([^)]*\)\s*$/);
          const arrowFunction = beforeContext.match(/(?:const|let|var)?\s*(\w+)\s*=\s*(?:async\s*)?(?:\([^)]*\)|[^=]*)\s*=>/);
          const methodDeclaration = beforeContext.match(/(\w+)\s*:\s*(?:async\s*)?function\s*\([^)]*\)\s*$/);
          const classMethod = beforeContext.match(/(?:async\s+)?(\w+)\s*\([^)]*\)\s*$/);
          const eventListener = beforeContext.match(/addEventListener\([^)]+\)\s*=>\s*$/);
          if (functionDeclaration || arrowFunction || methodDeclaration || classMethod || eventListener) {
            const lastNewline = beforeContext.lastIndexOf('\n');
            if (lastNewline >= 0) {
              contextStart = searchStartIndex + lastNewline + 1;
            } else {
              contextStart = searchStartIndex;
            }
          }
          if (blockStart >= 0) {
            const completeBlock = content.substring(contextStart, blockStart).trim() + extractCompleteCodeBlock(content, blockStart);
            if (completeBlock && !references.includes(completeBlock)) {
              references.push(addFunctionLinks(completeBlock));
            }
          }
        }
      });
    });
    return references;
  }
  
  
  function extractFunctions(code) {
    try {
      // Basic function declaration regex
      const functionDeclRegex = /function\s+(\w+)\s*\([^)]*\)\s*{/g;
      let match;
      
      while ((match = functionDeclRegex.exec(code)) !== null) {
        const functionName = match[1];
        const startIndex = match.index;
        const functionBody = extractCompleteCodeBlock(code, code.indexOf('{', startIndex));
        
        if (functionBody) {
          const dependencies = findFunctionDependencies(functionBody);
          functionRegistry[functionName] = {
            code: functionBody,
            dependencies: dependencies
          };
        }
      }

      // Arrow function and variable assignment regex
      const arrowFuncRegex = /(?:const|let|var)?\s*(\w+)\s*=\s*(?:async\s*)?(?:\([^)]*\)|[^=]*)\s*=>/g;
      while ((match = arrowFuncRegex.exec(code)) !== null) {
        const functionName = match[1];
        const startIndex = match.index;
        let functionBody;
        
        // Find the function body
        const arrowIndex = code.indexOf('=>', startIndex);
        if (arrowIndex >= 0) {
          if (code[arrowIndex + 2] === '{') {
            functionBody = extractCompleteCodeBlock(code, arrowIndex + 2);
          } else {
            // Single line arrow function
            const lineEnd = code.indexOf('\n', arrowIndex);
            functionBody = code.substring(arrowIndex + 2, lineEnd > -1 ? lineEnd : code.length).trim();
          }
          
          if (functionBody) {
            const dependencies = findFunctionDependencies(functionBody);
            functionRegistry[functionName] = {
              code: `${code.substring(startIndex, arrowIndex + 2)} ${functionBody}`,
              dependencies: dependencies
            };
          }
        }
      }
    } catch (error) {
      console.error('Error extracting functions:', error);
    }
  }

  function extractCompleteCodeBlock(code, openBraceIndex) {
    if (openBraceIndex < 0) return null;
    
    let braceCount = 1;
    let currentIndex = openBraceIndex + 1;
    
    while (braceCount > 0 && currentIndex < code.length) {
      if (code[currentIndex] === '{') {
        braceCount++;
      } else if (code[currentIndex] === '}') {
        braceCount--;
      }
      currentIndex++;
    }
    
    if (braceCount === 0) {
      return code.substring(openBraceIndex, currentIndex);
    }
    
    return null;
  }

  function findFunctionDependencies(functionBody) {
    const dependencies = new Set();
    Object.keys(functionRegistry).forEach(funcName => {
      const regex = new RegExp(`\\b${funcName}\\b(?=\\s*\\()`, 'g');
      if (regex.test(functionBody)) {
        dependencies.add(funcName);
      }
    });
    return Array.from(dependencies);
  }

  function extractStyles(styleContent) {
    try {
      const ruleRegex = /([^{]+)\{([^}]+)\}/g;
      let match;
      
      while ((match = ruleRegex.exec(styleContent)) !== null) {
        const selector = match[1].trim();
        const rules = match[2].trim();
        styleRegistry[selector] = rules;
      }
    } catch (error) {
      console.error('Error extracting styles:', error);
    }
  }

  function extractEventHandlers(element) {
    try {
      const handlers = {};
      const attributes = element.attributes;
      
      if (attributes) {
        Array.from(attributes).forEach(attr => {
          if (attr.name.startsWith('on')) {
            const eventType = attr.name.substring(2);
            handlers[eventType] = attr.value;
          }
        });
      }
      
      if (Object.keys(handlers).length > 0) {
        const tagName = element.tagName.toLowerCase();
        eventRegistry[tagName] = handlers;
      }
    } catch (error) {
      console.error('Error extracting event handlers:', error);
    }
  }

  // Helper function to safely parse JSON
function safeJsonParse(str) {
  try {
    return JSON.parse(str);
  } catch (e) {
    console.error('JSON parse error:', e);
    return null;
  }
}

// Helper function to extract HTML from AI response
function extractHtmlFromResponse(response) {
  // First try to find complete HTML document
  const htmlMatch = response.match(/<!DOCTYPE html>[\s\S]*<\/html>/i);
  if (htmlMatch) return htmlMatch[0];
  
  // Then try to find HTML fragment
  const fragmentMatch = response.match(/<html[\s\S]*<\/html>/i);
  if (fragmentMatch) return fragmentMatch[0];
  
  // Finally, try to find body content
  const bodyMatch = response.match(/<body[\s\S]*<\/body>/i);
  if (bodyMatch) return `<html><head><title>Updated Website</title></head>${bodyMatch[0]}</html>`;
  
  return null;
}


  // Helper function to escape HTML special characters
  function escapeHtml(unsafe) {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

async function processGlobalAIEdit() {
  const instructions = document.getElementById('global-ai-instructions').value.trim();
  if (!instructions) {
    alert('Please describe what changes you want to make to the website.');
    return;
  }

  const editButton = document.getElementById('global-ai-edit');
  editButton.classList.add('processing');

  try {
    // Get current content (either from single file or project files)
    let currentContent;
    if (isZipProject) {
      currentContent = {};
      for (const [path, file] of Object.entries(projectFiles)) {
        currentContent[path] = file.type === 'text' ? file.content : '[Binary file]';
      }
    } else {
      currentContent = currentWebsiteCode;
    }

    // Create more explicit prompt
    const prompt = `I need to make specific changes to this website. Please provide ONLY the minimal changes needed in the exact required JSON format.
Current content: ${JSON.stringify(currentContent)}
Instructions: ${instructions}

Respond STRICTLY with a JSON object containing ONLY a "changes" property with the changed files. Example response:
{
  "changes": {
    "path/to/file.html": "<div>Updated content</div>",
    "styles/main.css": ".updated { color: red; }"
  }
}

Important rules:
1. Do NOT include any additional text, explanations, or markdown formatting
2. ONLY include files that need changes
3. Respond with ONLY the JSON object
4. Maintain all existing content that shouldn't change`;

    // Call AI API
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-exp-03-25:generateContent?key=${geminiConfig.apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }]
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`API request failed: ${response.status} - ${errorData.message || 'Unknown error'}`);
    }

    const data = await response.json();
    const responseText = data.candidates[0].content.parts[0].text;

    // Parse and validate the response
    let parsedResponse;
    try {
      // First try direct parse
      parsedResponse = JSON.parse(responseText);
    } catch (e) {
      // If direct parse fails, try to extract JSON from markdown or code blocks
      const jsonMatch = responseText.match(/\{(?:[^{}]|(?:\{[^{}]*\}))*\}/s);
      if (jsonMatch) {
        try {
          parsedResponse = JSON.parse(jsonMatch[0]);
        console.warn('Extracted JSON from formatted response');
        console.warn('Original response:', responseText);
        console.warn('Extracted JSON:', jsonMatch[0]);
        } catch (e2) {
          throw new Error('Could not extract valid JSON from AI response');
        }
      } else {
        throw new Error('AI response did not contain valid JSON');
      }
    }

    // Validate the response structure
    if (!parsedResponse?.changes || typeof parsedResponse.changes !== 'object') {
      throw new Error('AI response did not contain the required "changes" object');
    }

    const changes = parsedResponse.changes;

    // Validate each change
    for (const [path, newContent] of Object.entries(changes)) {
      if (typeof newContent !== 'string') {
        throw new Error(`Invalid content type for file ${path}`);
      }
      
      if (isZipProject && !projectFiles[path]) {
        console.warn(`File ${path} not found in project, will be created`);
        // Allow new files to be created in project mode
      }
    }

    if (Object.keys(changes).length === 0) {
      throw new Error('No valid changes to apply');
    }

    // Apply the changes
    if (isZipProject) {
      for (const [path, newContent] of Object.entries(changes)) {
        if (projectFiles[path]) {
          projectFiles[path].content = newContent;
        } else {
          // Create new file if it doesn't exist
          projectFiles[path] = {
            type: 'text',
            content: newContent
          };
        }
      }
    } else {
      // For single file, update the entire content
      const changedFiles = Object.keys(changes);
      if (changedFiles.length > 1) {
        throw new Error('Single file mode only supports changing one file at a time');
      }
      currentWebsiteCode = changes[changedFiles[0]];
    }

    // Save the updated project
    await saveProjectToStorage();

    // Reload the current view
    if (isZipProject && currentFilePath) {
      await loadProjectFile(currentFilePath);
    } else {
      await processHTMLContent(currentWebsiteCode);
    }

    // Show success and reload after short delay
    alert('Changes applied successfully!');
    setTimeout(() => location.reload(), 500);

  } catch (error) {
    console.error('Error processing AI edit:', error);
    alert('Error processing changes: ' + error.message);
    
    // Optionally log the full response for debugging
    if (error.message.includes('JSON') && responseText) {
      console.error('Full AI response:', responseText);
    }
  } finally {
    editButton.classList.remove('processing');
  }
}
  
  function getMimeType(filename) {
    const extension = filename.split('.').pop().toLowerCase();
    const mimeTypes = {
      'html': 'text/html',
      'css': 'text/css',
      'js': 'application/javascript',
      'json': 'application/json',
      'png': 'image/png',
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'gif': 'image/gif',
      'svg': 'image/svg+xml',
      'webp': 'image/webp',
      'ico': 'image/x-icon',
      'txt': 'text/plain'
    };
    return mimeTypes[extension] || 'application/octet-stream';
  }

  function closeGlobalAIModal() {
    const modal = document.getElementById('global-ai-modal');
    if(modal){
      modal.style.display = 'none';
    }
    document.getElementById('global-ai-instructions').value = '';
    const summaryElement = document.querySelector('.changes-summary');
    if (summaryElement) {
      summaryElement.textContent = '';
      summaryElement.classList.remove('show');
    }
  }

  document.getElementById('global-ai-edit').addEventListener('click', () => {
    document.getElementById('global-ai-modal').style.display = 'block';
  });

async function downloadCurrentCode() {
    if (!isZipProject && !currentWebsiteCode) {
        alert("No project loaded to download.");
        return;
    }
    if (isZipProject && Object.keys(projectFiles).length === 0) {
        alert("No project files found to download.");
        return;
    }

    // Ensure JSZip is loaded
    if (typeof JSZip === 'undefined') {
       alert('JSZip library is not loaded. Cannot create ZIP file.');
       // Optionally load it dynamically here if needed
       return;
    }


    try {
      const zip = new JSZip();
      
      // Add the edited file
      if (isZipProject) {
        // Process multi-file project
        const filePaths = Object.keys(projectFiles);

        for (const path of filePaths) {
          const file = projectFiles[path];
          let finalContent = null;

          if (file.type === 'text') {
            // Get the latest content
            let currentContent = file.content;

            // If it's the currently displayed HTML, get it from the iframe
            // as it might contain un-saved DOM manipulations (like drag/drop)
            if (path === currentFilePath && (path.endsWith('.html') || path.endsWith('.htm'))) {
                const frame = document.getElementById('preview-frame');
                if (frame && frame.contentDocument) {
                    currentContent = frame.contentDocument.documentElement.outerHTML;
                    console.log(`Using iframe content for ${path}`);
                } else {
                     console.warn(`Could not get iframe content for ${path}, using stored content.`);
                }
            }


            // If it's HTML, restore relative paths
            if (path.endsWith('.html') || path.endsWith('.htm')) {
                console.log(`Restoring paths for ${path}...`);
                const parser = new DOMParser();
                const tempDoc = parser.parseFromString(currentContent, 'text/html');
                const baseDir = path.substring(0, path.lastIndexOf('/') + 1);

                // Selectors for elements with paths to restore
                const selectors = [
                    'img[src]', 'video[src]', 'audio[src]', 'source[src]', 'track[src]',
                    'embed[src]', 'iframe[src]', 'script[src]',
                    'link[rel="stylesheet"][href]', 'link[rel*="icon"][href]',
                    'a[href]' // Also check links, though less critical for local execution usually
                ];

                tempDoc.querySelectorAll(selectors.join(', ')).forEach(element => {
                    const attribute = element.hasAttribute('src') ? 'src' : 'href';
                    const currentPath = element.getAttribute(attribute);

                    // Check if it's a blob URL we likely generated
                    if (currentPath && currentPath.startsWith('blob:')) {
                        let originalRelativePath = element.getAttribute('data-original-path'); // Check if we stored it

                        // Fallback: try to find the original path by matching blob URL
                        if (!originalRelativePath) {
                           for (const [p, f] of Object.entries(projectFiles)) {
                              if (f.url === currentPath || f.tempBlobUrl === currentPath) {
                                  originalRelativePath = calculateRelativePath(path, p);
                                  console.log(`Blob ${currentPath} mapped back to ${p}, relative: ${originalRelativePath}`);
                                  break;
                              }
                           }
                        }


                        if (originalRelativePath) {
                            element.setAttribute(attribute, originalRelativePath);
                            element.removeAttribute('data-original-path'); // Clean up attribute
                            console.log(`Restored ${attribute} in ${element.tagName} to ${originalRelativePath}`);
                        } else {
                            console.warn(`Could not find original path for blob URL: ${currentPath} in ${path}`);
                        }
                    }
                    // Remove data-original-path even if not a blob, for cleanup
                    if (element.hasAttribute('data-original-path')) {
                        element.removeAttribute('data-original-path');
                    }
                });

                // Restore paths in inline styles
                tempDoc.querySelectorAll('[style*="url("]').forEach(element => {
                    let style = element.getAttribute('style');
                    // Match blob URLs within url()
                    style = style.replace(/url\(['"]?([^'")\s]+)['"]?\)/g, (match, blobUrl) => {
                        let originalRelativePath = null;
                        for (const [p, f] of Object.entries(projectFiles)) {
                           if (f.url === blobUrl || f.tempBlobUrl === blobUrl) {
                               originalRelativePath = calculateRelativePath(path, p);
                               break;
                           }
                        }
                        if (originalRelativePath) {
                            console.log(`Restored style url() for ${blobUrl} to ${originalRelativePath}`);
                            return `url(${originalRelativePath})`;
                        } else {
                            console.warn(`Could not find original path for style blob URL: ${blobUrl} in ${path}`);
                            return match; // Keep original if not found
                        }
                    });
                    element.setAttribute('style', style);
                });

                // TODO: Address potential <style> tags that replaced <link> tags if that strategy was used.
                // If the preview uses blob URLs for <link href>, this step isn't needed.

                finalContent = tempDoc.documentElement.outerHTML;

            } else {
                 // For non-HTML text files, use the content directly
                 finalContent = currentContent;
            }

            zip.file(path, finalContent);
            console.log(`Added ${path} (text) to zip.`);
        } else if (file.type === 'image' || file.type === 'binary') {
            // For images/binary, fetch the blob data from the URL
             try {
                 const response = await fetch(file.url);
                 if (!response.ok) throw new Error(`Failed to fetch blob: ${response.statusText}`);
                 const blobData = await response.blob();
                 zip.file(path, blobData);
                 console.log(`Added ${path} (binary/image) to zip.`);
             } catch (fetchError) {
                  console.error(`Error fetching blob data for ${path}: ${fetchError}. Skipping file.`);
                  // Optionally add a placeholder or skip
             }
          }
        }

        // Generate the ZIP file
        const zipBlob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(zipBlob);

        // Create download link
        const link = document.createElement('a');
        link.href = url;
        link.download = 'edited_project.zip'; // Suggest a filename
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

      } else {
        // Handle single HTML file download (less complex, might not need path restoration if no ZIP involved)
        const frame = document.getElementById('preview-frame');
        const frameDoc = frame.contentDocument || frame.contentWindow.document;
        let contentToDownload = frameDoc.documentElement.outerHTML; // Get latest from iframe

        // Basic cleanup (might need more depending on edits)
        // Remove highlight class if present
        const tempDoc = document.createElement('div');
        tempDoc.innerHTML = contentToDownload;
        tempDoc.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
        tempDoc.querySelectorAll('.draggable').forEach(el => el.classList.remove('draggable','dragging'));
        tempDoc.querySelectorAll('.resize-handle, .element-delete-handle, .iframe-overlay').forEach(el => el.remove());
        contentToDownload = tempDoc.innerHTML;


        const blob = new Blob([contentToDownload], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'edited_page.html';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
    } catch (error) {
      console.error('Error creating or downloading archive:', error);
      alert('Error creating download: ' + error.message);
    }
  }
// Updated DOMContentLoaded handler
document.addEventListener('DOMContentLoaded', async function() {
  initApp();

  // Load API config
  const savedConfig = localStorage.getItem('geminiConfig');
  if (savedConfig) {
    geminiConfig = JSON.parse(savedConfig);
    document.getElementById('apiKey').value = geminiConfig.apiKey;
  }

  // Try to load project
  const projectLoaded = await ProjectStorage.loadProject();
  
  if (!projectLoaded) {
    checkForProject();
  }

  // Add warning for files that need reloading
  if (isZipProject) {
    const needsReload = Object.values(projectFiles).filter(f => f.needsReload).length;
    if (needsReload > 0) {
      alert(`Note: ${needsReload} binary files need to be re-added from your original project files.`);
    }
  }
});
  
  function updateResizePanel(element) {
    selectedElement = element;
    const panel = document.querySelector('.resize-control-panel');
    const widthInput = document.getElementById('elementWidth');
    const heightInput = document.getElementById('elementHeight');
    const widthUnit = document.getElementById('widthUnit');
    const heightUnit = document.getElementById('heightUnit');
    const bgColorInput = document.getElementById('elementBgColor');
    const textColorInput = document.getElementById('elementTextColor');
    const fontSizeInput = document.getElementById('elementFontSize');
    const fontSizeUnit = document.getElementById('fontSizeUnit');
    const fontFamilySelect = document.getElementById('elementFontFamily');
    const textContentInput = document.getElementById('elementTextContent');
    const elementTypeIndicator = document.getElementById('elementTypeIndicator');
    const imageControls = document.getElementById('imageControls');
    const linkControls = document.getElementById('linkControls');
    const buttonControls = document.getElementById('buttonControls');
    const inputControls = document.getElementById('inputControls');
    const imageUpload = document.getElementById('imageUpload');
    const imageAlt = document.getElementById('imageAlt');
    const imagePreview = document.querySelector('.image-preview');
    const linkUrl = document.getElementById('linkUrl');
    const linkNewTab = document.getElementById('linkNewTab');
    const buttonType = document.getElementById('buttonType');
    const inputType = document.getElementById('inputType');
    const inputPlaceholder = document.getElementById('inputPlaceholder');
    
    // Show element type
    elementTypeIndicator.textContent = element.tagName.toLowerCase();
    
    // Hide all type-specific controls first
    document.querySelectorAll('.element-type-controls').forEach(control => {
      control.style.display = 'none';
    });
    
    // Show specific controls based on element type
    switch(element.tagName.toLowerCase()) {
      case 'img':
        imageControls.style.display = 'block';
        imageAlt.value = element.alt || '';
        imagePreview.innerHTML = `<img src="${element.src}" alt="${element.alt || ''}">`;
        break;
        
      case 'a':
        linkControls.style.display = 'block';
        linkUrl.value = element.href || '';
        linkNewTab.checked = element.target === '_blank';
        break;
        
      case 'button':
        buttonControls.style.display = 'block';
        buttonType.value = element.type || 'button';
        break;
        
      case 'input':
        inputControls.style.display = 'block';
        inputType.value = element.type || 'text';
        inputPlaceholder.value = element.placeholder || '';
        break;
    }
    
    // Get computed style
    const style = window.getComputedStyle(element);
    
    // Parse current dimensions
    const width = parseFloat(style.width);
    const height = parseFloat(style.height);
    
    // Detect units (simplified version)
    const currentWidthUnit = style.width.includes('%') ? '%' : 'px';
    const currentHeightUnit = style.height.includes('%') ? '%' : 'px';
    
    // Set dimension values
    widthInput.value = Math.round(width);
    heightInput.value = Math.round(height);
    widthUnit.value = currentWidthUnit;
    heightUnit.value = currentHeightUnit;
    
    // Set style values
    const computedStyle = window.getComputedStyle(element);
    const bgColor = computedStyle.backgroundColor;
    
    // Check if background is transparent or has opacity
    const transparentCheckbox = document.getElementById('transparentBg');
    const opacitySlider = document.getElementById('bgOpacity');
    const opacityValue = document.getElementById('opacityValue');
    
    if (bgColor === 'transparent' || bgColor === 'rgba(0, 0, 0, 0)') {
      transparentCheckbox.checked = true;
      opacitySlider.disabled = true;
      opacitySlider.value = 0;
      opacityValue.textContent = '0%';
    } else {
      transparentCheckbox.checked = false;
      opacitySlider.disabled = false;
      
      // Extract opacity from rgba
      const match = bgColor.match(/rgba?\([\d\s,\.]+(?:,([\d.]+))?\)/);
      const opacity = match ? Math.round((match[1] || 1) * 100) : 100;
      
      opacitySlider.value = opacity;
      opacityValue.textContent = opacity + '%';
    }
    bgColorInput.value = rgbToHex(bgColor);
    textColorInput.value = rgbToHex(computedStyle.color);
    
    // Set font size
    const fontSize = parseFloat(computedStyle.fontSize);
    fontSizeInput.value = Math.round(fontSize);
    fontSizeUnit.value = computedStyle.fontSize.includes('em') ? 'em' : 
                        computedStyle.fontSize.includes('rem') ? 'rem' : 'px';
    
    // Set font family
    fontFamilySelect.value = computedStyle.fontFamily || 'inherit';
    
    // Improved text content handling
    // Check if element is a text node or contains only text
    const isTextEditable = element.nodeType === 3 || // Text node
                          (element.childNodes.length === 1 && element.childNodes[0].nodeType === 3) || // Single text node child
                          ['P', 'SPAN', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'BUTTON', 'A', 'LABEL', 'DIV'].includes(element.tagName);
    
    if (isTextEditable) {
        let textContent = element.textContent || element.innerText;
        textContentInput.value = textContent.trim();
        textContentInput.disabled = false;
    } else {
        textContentInput.value = '';
        textContentInput.disabled = true;
    }
    
    // Show panel and expand section
    panel.classList.add('active');
    const resizerSection = panel.closest('.sidebar-section');
    resizerSection.classList.add('expanded');
    
    // Open sidebar if closed
    //document.querySelector('.sidebar').classList.add('open');
  }

  function applyStyles() {
    if (!selectedElement) return;
    
    // Apply general styles 
    const bgColor = document.getElementById('elementBgColor').value;
    const isTransparent = document.getElementById('transparentBg').checked;
    const opacity = document.getElementById('bgOpacity').value;
    const textColor = document.getElementById('elementTextColor').value;
    const fontSize = document.getElementById('elementFontSize').value;
    const fontSizeUnit = document.getElementById('fontSizeUnit').value;
    const fontFamily = document.getElementById('elementFontFamily').value;
    const textContent = document.getElementById('elementTextContent').value;
    
    // Apply general styles
    if (isTransparent) {
      selectedElement.style.backgroundColor = 'transparent';
    } else {
      const r = parseInt(bgColor.slice(1,3), 16);
      const g = parseInt(bgColor.slice(3,5), 16);
      const b = parseInt(bgColor.slice(5,7), 16);
      const a = opacity / 100;
      selectedElement.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    
    selectedElement.style.color = textColor;
    selectedElement.style.fontSize = `${fontSize}${fontSizeUnit}`;
    selectedElement.style.fontFamily = fontFamily;
    
    // Apply type-specific attributes
    switch(selectedElement.tagName.toLowerCase()) {
      case 'img':
        selectedElement.alt = document.getElementById('imageAlt').value;
        break;
        
      case 'a':
        selectedElement.href = document.getElementById('linkUrl').value;
        selectedElement.target = document.getElementById('linkNewTab').checked ? '_blank' : '';
        break;
        
      case 'button':
        selectedElement.type = document.getElementById('buttonType').value;
        break;
        
      case 'input':
        selectedElement.type = document.getElementById('inputType').value;
        selectedElement.placeholder = document.getElementById('inputPlaceholder').value;
        break;
    }
    
    // Update text content if applicable and changed
    if (!document.getElementById('elementTextContent').disabled && 
        textContent !== '' && 
        textContent !== selectedElement.textContent) { 
    
      // Clear existing content first
      selectedElement.textContent = ''; 
    
      // Then set new content
      selectedElement.textContent = textContent;
    }
    
    // Update the website code
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    updateWebsiteCode(frameDoc);
  }

  function rgbToHex(rgb) {
    // Check if it's a named color or already hex
    if (!rgb.startsWith('rgb')) return rgb;
    
    const values = rgb.match(/\d+/g);
    if (!values) return '#000000';
    
    const r = parseInt(values[0]);
    const g = parseInt(values[1]);
    const b = parseInt(values[2]);
    
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  }

  function initializeDragAndResize() {
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    
    // Set up overlay events
    const iframeOverlay = document.querySelector('.iframe-overlay');
    iframeOverlay.addEventListener('dragover', handleFrameDragOver);
    iframeOverlay.addEventListener('dragleave', handleFrameDragLeave);
    iframeOverlay.addEventListener('drop', handleFrameDrop);
    
    // Initialize existing elements
    const elements = frameDoc.getElementsByTagName('*');
    Array.from(elements).forEach(element => {
      if (!['BODY', 'HTML', 'HEAD', 'SCRIPT'].includes(element.tagName)) {
        makeElementDraggable(element);
        makeElementResizable(element);
      }
    });
    saveProjectToStorage();
  }

  function makeElementDraggable(element) {
    element.classList.add('draggable');
    
    // Initialize position if not set
    if (!elementPositions.has(element)) {
      elementPositions.set(element, { x: 0, y: 0 });
    }
    
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    // Apply any existing position
    const pos = elementPositions.get(element);
    element.style.transform = `translate(${pos.x}px, ${pos.y}px)`;

    element.addEventListener('mousedown', dragStart);
    element.addEventListener('mousemove', drag);
    element.addEventListener('mouseup', dragEnd);
    element.addEventListener('mouseleave', dragEnd);

    element.addEventListener('touchstart', dragStart, { passive: true });
    element.addEventListener('touchmove', drag, { passive: false });
    element.addEventListener('touchend', dragEnd);

    function dragStart(e) {
      if ((!moveElementsEnabled && !editModeEnabled) || e.target.classList.contains('resize-handle') || e.target.classList.contains('element-delete-handle')) return;
      
      if (e.type === 'mousedown') {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
      } else {
        initialX = e.touches[0].clientX - xOffset;
        initialY = e.touches[0].clientY - yOffset;
      }

      if (e.target === element || element.contains(e.target)) {
        isDragging = true;
        element.classList.add('dragging');
      }
    }

    function drag(e) {
      if (isDragging && (moveElementsEnabled || editModeEnabled)) {
        e.preventDefault();

        if (e.type === 'mousemove') {
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
        } else {
          currentX = e.touches[0].clientX - initialX;
          currentY = e.touches[0].clientY - initialY;
        }

        xOffset = currentX;
        yOffset = currentY;

        element.style.transform = `translate(${currentX}px, ${currentY}px)`;
      }
    }

    function dragEnd() {
      if (!moveElementsEnabled && !editModeEnabled) return;
      
      // Store the final position
      elementPositions.set(element, { x: xOffset, y: yOffset });
      
      initialX = currentX;
      initialY = currentY;
      isDragging = false;
      element.classList.remove('dragging');
    }
  }

  function makeElementResizable(element) {
    // Add resize handles
    const handles = [
        { class: 'top-left', cursor: 'nw-resize' },
        { class: 'top-right', cursor: 'ne-resize' },
        { class: 'bottom-left', cursor: 'sw-resize' },
        { class: 'bottom-right', cursor: 'se-resize' }
    ];

    handles.forEach(handle => {
        const div = document.createElement('div');
        div.className = `resize-handle ${handle.class}`;
        element.appendChild(div);
    });

    // Only add delete handle if in edit mode
    if (editModeEnabled) {
        const deleteHandle = document.createElement('div');
        deleteHandle.className = 'element-delete-handle';
        deleteHandle.innerHTML = '√ó';
        deleteHandle.addEventListener('click', (e) => {
            e.stopPropagation();
            elementToDelete = element;
            deleteElementButton.disabled = false;
            
            // Highlight the element to be deleted
            const allElements = element.ownerDocument.getElementsByTagName('*');
            Array.from(allElements).forEach(el => {
                el.classList.remove('highlight');
            });
            element.classList.add('highlight');
        });
        element.appendChild(deleteHandle);
    }

    let isResizing = false;
    let currentHandle = null;
    let originalWidth = 0;
    let originalHeight = 0;
    let originalX = 0;
    let originalY = 0;
    let originalMouseX = 0;
    let originalMouseY = 0;

    const resizeHandles = element.querySelectorAll('.resize-handle');
    
    resizeHandles.forEach(handle => {
        handle.addEventListener('mousedown', initResize);
        handle.addEventListener('touchstart', initResize, { passive: true });
    });

    document.addEventListener('mousemove', resize);
    document.addEventListener('touchmove', resize, { passive: false });
    document.addEventListener('mouseup', stopResize);
    document.addEventListener('touchend', stopResize);

    function initResize(e) {
        if (!editModeEnabled) return;
        
        isResizing = true;
        currentHandle = e.target;
        
        const rect = element.getBoundingClientRect();
        originalWidth = rect.width;
        originalHeight = rect.height;
        originalX = rect.left;
        originalY = rect.top;
        
        if (e.type === 'mousedown') {
            originalMouseX = e.pageX;
            originalMouseY = e.pageY;
        } else {
            originalMouseX = e.touches[0].pageX;
            originalMouseY = e.touches[0].pageY;
        }
        
        e.stopPropagation();
    }

    function resize(e) {
        if (!isResizing) return;
        e.preventDefault();

        let currentX = e.type === 'mousemove' ? e.pageX : e.touches[0].pageX;
        let currentY = e.type === 'mousemove' ? e.pageY : e.touches[0].pageY;

        let deltaX = currentX - originalMouseX;
        let deltaY = currentY - originalMouseY;

        let newWidth = originalWidth;
        let newHeight = originalHeight;

        if (currentHandle.classList.contains('bottom-right')) {
            newWidth = originalWidth + deltaX;
            newHeight = originalHeight + deltaY;
        } else if (currentHandle.classList.contains('bottom-left')) {
            newWidth = originalWidth - deltaX;
            newHeight = originalHeight + deltaY;
            element.style.left = originalX + deltaX + 'px';
        } else if (currentHandle.classList.contains('top-right')) {
            newWidth = originalWidth + deltaX;
            newHeight = originalHeight - deltaY;
            element.style.top = originalY + deltaY + 'px';
        } else if (currentHandle.classList.contains('top-left')) {
            newWidth = originalWidth - deltaX;
            newHeight = originalHeight - deltaY;
            element.style.top = originalY + deltaY + 'px';
            element.style.left = originalX + deltaX + 'px';
        }

        element.style.width = Math.max(20, newWidth) + 'px';
        element.style.height = Math.max(20, newHeight) + 'px';
    }

    function stopResize() {
        isResizing = false;
        currentHandle = null;
    }
  }

  document.addEventListener('click', function(e) {
    const sidebar = document.querySelector('.sidebar');
    const sidebarToggle = document.querySelector('.sidebar-toggle');
    
    // Check if click is outside sidebar and sidebar toggle button
    if (!sidebar.contains(e.target) && 
        !sidebarToggle.contains(e.target) && 
        !e.target.closest('.draggable') &&  // Don't close when clicking draggable elements
        !e.target.closest('.resize-handle') && // Don't close when clicking resize handles
        !e.target.closest('.element-delete-handle') && // Don't close when clicking delete handle
        !e.target.closest('.component-item')) { // Don't close when clicking component items
      
      sidebar.classList.remove('open');
    }
  });

  function editCurrentContent(button) {
    let controls = button.parentElement; // the .edit-controls container
    let input = controls.querySelector('.edit-prompt');
    let instructions = input.value.trim();
    if (!instructions) {
      alert("Please provide editing instructions.");
      return;
    }
    let loader = controls.querySelector('.loader');
    let codeBlock = controls.nextElementSibling; // associated .code-block element
    if (!codeBlock) {
      alert("Associated code block not found.");
      return;
    }
    let codePre = codeBlock.querySelector('.code-content');
    let originalContent = codePre ? codePre.textContent : '';
    if (!originalContent) {
      alert("No content to edit found.");
      return;
    }
    // Call the AI edit function with the instructions and the current code.
    handleAIEdit(instructions, originalContent, loader).then(editedCode => {
      if (editedCode) {
        // Update the code block with the edited code.
        codePre.textContent = editedCode;
        // Also update the highlighted element in the preview frame, if any.
        const previewFrame = document.getElementById('preview-frame');
        if (previewFrame) {
          const frameDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
          const highlighted = frameDoc.querySelector('.highlight');
          if (highlighted) {
            highlighted.outerHTML = editedCode;
          }
        }
      } else {
        alert("AI edit failed. Please try again.");
      }
    }).catch(err => {
      console.error("Error in editCurrentContent:", err);
      alert("Error during AI edit.");
    });
  }

  // Sidebar toggle functionality
  document.querySelector('.sidebar-toggle').addEventListener('click', () => {
    document.querySelector('.sidebar').classList.toggle('open');
  });

  // Section collapse functionality
  document.querySelectorAll('.sidebar-section-title').forEach(title => {
    title.addEventListener('click', () => {
      const section = title.parentElement;
      section.classList.toggle('expanded');
    });
  });

  document.getElementById('imageUpload').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file && selectedElement && selectedElement.tagName.toLowerCase() === 'img') {
      const reader = new FileReader();
      reader.onload = function(event) {
        selectedElement.src = event.target.result;
        // Update preview
        const imagePreview = document.querySelector('.image-preview');
        imagePreview.innerHTML = `<img src="${event.target.result}" alt="${selectedElement.alt || ''}">`;
      };
      reader.readAsDataURL(file);
    }
  });

  document.getElementById('imageAlt').addEventListener('change', function(e) {
    if (selectedElement && selectedElement.tagName.toLowerCase() === 'img') {
      selectedElement.alt = e.target.value;
    }
  });

  document.getElementById('linkUrl').addEventListener('change', function(e) {
    if (selectedElement && selectedElement.tagName.toLowerCase() === 'a') {
      selectedElement.href = e.target.value;
    }
  });

  document.getElementById('linkNewTab').addEventListener('change', function(e) {
    if (selectedElement && selectedElement.tagName.toLowerCase() === 'a') {
      selectedElement.target = e.target.checked ? '_blank' : '';
    }
  });

  document.getElementById('buttonType').addEventListener('change', function(e) {
    if (selectedElement && selectedElement.tagName.toLowerCase() === 'button') {
      selectedElement.type = e.target.value;
    }
  });

  document.getElementById('inputType').addEventListener('change', function(e) {
    if (selectedElement && selectedElement.tagName.toLowerCase() === 'input') {
      selectedElement.type = e.target.value;
    }
  });

  document.getElementById('inputPlaceholder').addEventListener('change', function(e) {
    if (selectedElement && selectedElement.tagName.toLowerCase() === 'input') {
      selectedElement.placeholder = e.target.value;
    }
  });

  
  // Load JSZip library if not already loaded
  if (typeof JSZip === 'undefined') {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    document.head.appendChild(script);
  }

  // Initialize Ace Editor
  let editor;
  function initCodeEditor() {
    if (!editor) {
      editor = ace.edit("code-editor");
      editor.setTheme("ace/theme/monokai");
      editor.getSession().setMode("ace/mode/html");
      editor.setOptions({
        fontSize: "14px",
        showPrintMargin: false,
        enableLiveAutocompletion: true,
        enableSnippets: true,
        enableBasicAutocompletion: true
      });
    }
  }

  
  function showCodeReview(code) {
    const modal = document.getElementById('code-review-modal');
    modal.style.display = 'block';
    
    // First convert any blob URLs back to original paths
    let optimizedCode = code;
    
    if (isZipProject) {
        const parser = new DOMParser();
        const tempDoc = parser.parseFromString(optimizedCode, 'text/html');
        const baseDir = currentFilePath.substring(0, currentFilePath.lastIndexOf('/') + 1);

        // Process elements with src/href attributes
        const elements = tempDoc.querySelectorAll('img[src], script[src], link[href], video[src], audio[src], source[src], iframe[src], embed[src]');
        elements.forEach(element => {
            const attr = element.hasAttribute('src') ? 'src' : 'href';
            const currentPath = element.getAttribute(attr);
            
            // Check for blob URLs
            if (currentPath && currentPath.startsWith('blob:')) {
                // First try to get original path from data attribute
                let originalPath = element.getAttribute('data-original-path');
                
                // If no data attribute, try to find matching file in projectFiles
                if (!originalPath) {
                    for (const [path, file] of Object.entries(projectFiles)) {
                        if (file.url === currentPath || file.tempBlobUrl === currentPath) {
                            originalPath = calculateRelativePath(currentFilePath, path);
                            break;
                        }
                    }
                }
                
                if (originalPath) {
                    element.setAttribute(attr, originalPath);
                    element.removeAttribute('data-original-path');
                }
            }
        });

        // Process inline styles with url()
        const elementsWithBackgroundUrl = tempDoc.querySelectorAll('[style*="url("]');
        elementsWithBackgroundUrl.forEach(element => {
            let style = element.getAttribute('style');
            style = style.replace(/url\(['"]?([^'")\s]+)['"]?\)/g, (match, blobUrl) => {
                for (const [path, file] of Object.entries(projectFiles)) {
                    if (file.url === blobUrl || file.tempBlobUrl === blobUrl) {
                        const relativePath = calculateRelativePath(currentFilePath, path);
                        return `url('${relativePath}')`;
                    }
                }
                return match;
            });
            element.setAttribute('style', style);
        });

        // Clean up any remaining editor-specific classes and elements
        tempDoc.querySelectorAll('.highlight, .draggable, .dragging, .resize-handle, .element-delete-handle, .iframe-overlay')
            .forEach(el => {
                el.classList.remove('highlight', 'draggable', 'dragging');
                if (el.matches('.resize-handle, .element-delete-handle, .iframe-overlay')) {
                    el.remove();
                }
            });

        optimizedCode = tempDoc.documentElement.outerHTML;
    } else {
        // For single file projects, just clean up editor elements
        const tempDoc = document.createElement('div');
        tempDoc.innerHTML = optimizedCode;
        tempDoc.querySelectorAll('.highlight, .draggable, .dragging, .resize-handle, .element-delete-handle, .iframe-overlay')
            .forEach(el => {
                el.classList.remove('highlight', 'draggable', 'dragging');
                if (el.matches('.resize-handle, .element-delete-handle, .iframe-overlay')) {
                    el.remove();
                }
            });
        optimizedCode = tempDoc.innerHTML;
    }
    
    initCodeEditor();
    editor.setValue(optimizedCode, -1);
    editor.clearSelection();
  }

  function closeCodeReview() {
    document.getElementById('code-review-modal').style.display = 'none';
  }

  async function confirmAndDownload() {
    const finalCode = editor.getValue();
      
    try {
      if (isZipProject) {
        const zip = new JSZip();
        
        // Add the edited file
        if (currentFilePath) {
          zip.file(currentFilePath, finalCode);
          
          // Add other project files
          for (const [path, file] of Object.entries(projectFiles)) {
            if (path !== currentFilePath) {
              if (file.type === 'text') {
                zip.file(path, file.content);
              } else if (file.type === 'image' || file.type === 'binary') {
                try {
                  const response = await fetch(file.url);
                  const blob = await response.blob();
                  zip.file(path, blob);
                } catch (fetchError) {
                  console.error(`Error fetching binary data for ${path}: ${fetchError}. Skipping file.`);
                }
              }
            }
          }
        }

        const zipBlob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'edited_project.zip';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } else {
        // Single file download
        const blob = new Blob([finalCode], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'edited_page.html';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      closeCodeReview();
    } catch (error) {
      console.error('Error creating download:', error);
      alert('Error creating download: ' + error.message);
    }
  }

  // Add event listener for code review modal close button
  document.querySelector('.code-review-close').addEventListener('click', closeCodeReview);
  
  // Close modal when clicking outside
  document.getElementById('code-review-modal').addEventListener('click', function(e) {
    if (e.target === this) {
      closeCodeReview();
    }
  });
  
  function removeLeadingSlashes() {
    // Get all lines of code
    const code = editor.getValue();
    const lines = code.split('\n');
    const affectedLines = [];
    
    // Regular expressions to match file paths with leading slashes in different contexts
    const patterns = [
      /(src|href|url)\s*=\s*["']\/(.*?)["']/g,  // src="/path" or href="/path"
      /url\(\s*['"]?\/(.*?)['"]?\)/g,           // url('/path')
      /(src|href|url)\s*=\s*{\s*["']\/(.*?)['"]\s*}/g  // src={"/path"} (for JSX/templates)
    ];
    
    let modifiedCode = code;
    
    // Process each line
    lines.forEach((line, index) => {
      let lineModified = false;
      let newLine = line;
      
      patterns.forEach(pattern => {
        if (pattern.test(line)) {
          // Replace leading slashes while preserving the rest of the path
          newLine = newLine.replace(pattern, (match, attr, path) => {
            if (attr === 'url') {
              return `url('${path}')`;
            } else {
              return `${attr}="${path}"`;
            }
          });
          lineModified = true;
        }
      });
      
      if (lineModified) {
        affectedLines.push(index + 1); // Store the line number (1-based)
        modifiedCode = modifiedCode.replace(line, newLine);
      }
    });
    
    // Update the editor with modified code
    editor.setValue(modifiedCode, -1);
    editor.clearSelection();
    
    // Show report of changes
    const reportDiv = document.getElementById('slashRemovalReport');
    if (affectedLines.length > 0) {
      reportDiv.innerHTML = `Modified ${affectedLines.length} line${affectedLines.length > 1 ? 's' : ''}: ` +
        `Lines ${affectedLines.join(', ')}`;
      reportDiv.style.display = 'block';
    } else {
      reportDiv.innerHTML = 'No leading slashes found in file paths.';
      reportDiv.style.display = 'block';
    }
    
    // Scroll to the first modified line
    if (affectedLines.length > 0) {
      editor.scrollToLine(affectedLines[0], true, true, () => {});
      editor.gotoLine(affectedLines[0], 0, true);
    }
  }

  // Add this function before showCodeReview
  function calculateRelativePath(fromPath, toPath) {
    // Remove any leading slashes
    fromPath = fromPath.replace(/^\/+/, '');
    toPath = toPath.replace(/^\/+/, '');
    
    // Split the paths into segments
    const fromParts = fromPath.split('/').filter(Boolean);
    const toParts = toPath.split('/').filter(Boolean);
    
    // Remove the file name from fromPath
    fromParts.pop();
    
    // Find common path segments
    let commonLength = 0;
    while (commonLength < fromParts.length && commonLength < toParts.length &&
           fromParts[commonLength] === toParts[commonLength]) {
      commonLength++;
    }
    
    // Build the relative path
    const relativePath = [];
    
    // Add "../" for each remaining segment in fromPath
    for (let i = commonLength; i < fromParts.length; i++) {
      relativePath.push('..');
    }
    
    // Add the remaining segments from toPath
    for (let i = commonLength; i < toParts.length; i++) {
      relativePath.push(toParts[i]);
    }
    
    // Join the path segments
    return relativePath.join('/');
  }
  
  function toggleHelpGuide() {
    const helpGuide = document.querySelector('.help-guide');
    const helpOverlay = document.querySelector('.help-overlay');
    const isOpen = helpGuide.classList.contains('open');
    
    if (isOpen) {
      helpGuide.classList.remove('open');
      helpOverlay.classList.remove('open');
    } else {
      helpGuide.classList.add('open');
      helpOverlay.classList.add('open');
    }
  }

  document.querySelector('.help-overlay').addEventListener('click', () => {
    toggleHelpGuide();
  });

  // Add these functions to the existing JavaScript
// Update the panel based on whether we have a project loaded
function checkForProject() {
  const hasProject = isZipProject || currentWebsiteCode;
  const createNewSection = document.querySelector('.create-new-section');
  
  if (hasProject) {
    // Change to "Update Website" mode
    document.getElementById('websiteActionTitle').textContent = 'Update Website';
    document.getElementById('websiteActionDescription').textContent = 'Describe the changes you want to make to the current website...';
    document.getElementById('actionButtonText').textContent = 'Update Website';
    createNewSection.classList.add('show');
  } else {
    // Change to "Create Website" mode
    document.getElementById('websiteActionTitle').textContent = 'Create New Website';
    document.getElementById('websiteActionDescription').textContent = 'Describe the website you want to create and AI will generate it for you.';
    document.getElementById('actionButtonText').textContent = 'Generate Website';
    createNewSection.classList.add('show');
  }
}

// Handle both create and update actions
async function handleWebsiteAction() {
  const prompt = document.getElementById('websitePrompt').value.trim();
  if (!prompt) {
    alert('Please describe what you want to create or update.');
    return;
  }

  const hasProject = isZipProject || currentWebsiteCode;
  if (hasProject) {
    await updateWebsite(prompt);
  } else {
    await generateWebsite(prompt);
  }
}

// Modify the existing generateWebsite function to accept prompt as parameter
// Modify the existing generateWebsite function to accept prompt as parameter
async function generateWebsite(prompt) {
  if (!geminiConfig.apiKey) {
    alert('Please configure your Gemini API key first.');
    return;
  }

  const button = document.getElementById('generateButton');
  button.classList.add('generating');
  button.disabled = true;

  try {
    // ... rest of the existing generateWebsite code ...
  } catch (error) {
    console.error('Error generating website:', error);
    alert('Error generating website: ' + error.message);
  } finally {
    button.classList.remove('generating');
    button.disabled = false;
  }
}
  
  // Call checkForProject on page load and after file processing
  document.addEventListener('DOMContentLoaded', checkForProject);

  // Update the handleFile function to call checkForProject
// Updated handleFile function
async function handleFile(file) {
    // Clear current project
    await clearCurrentProject();
    
    if (!file) {
        checkForProject();
        return;
    }

    if (file.type.includes('html')) {
        // Process HTML file
        const content = await readFileAsText(file);
        currentWebsiteCode = content;
        isZipProject = false;
        await processHTMLContent(content);
    } else if (file.name.endsWith('.zip')) {
        // Process ZIP file
        isZipProject = true;
        document.getElementById('zipUploadMessage').textContent = 'Extracting ZIP archive...';
        
        try {
            await extractZipFile(file);
            document.getElementById('zipUploadMessage').textContent = 'ZIP extracted successfully!';
            document.getElementById('fileBrowser').style.display = 'block';
            
            // Find and load first HTML file
            const htmlFiles = Object.keys(projectFiles).filter(path => 
                path.endsWith('.html') || path.endsWith('.htm'));
                
            if (htmlFiles.length > 0) {
                renderFileTree();
                currentFilePath = htmlFiles[0];
                await loadProjectFile(currentFilePath);
            } else {
                document.getElementById('zipUploadMessage').textContent = 'No HTML files found in ZIP.';
                checkForProject();
            }
        } catch (error) {
            console.error('Error extracting ZIP:', error);
            document.getElementById('zipUploadMessage').textContent = 'Error: ' + error.message;
            checkForProject();
        }
    } else {
        alert('Please upload an HTML file or ZIP archive');
        checkForProject();
    }
}


  let geminiConfig = {
    apiKey: ''
  };

  // Load saved configuration on startup

  
  function saveApiConfig() {
    const apiKey = document.getElementById('apiKey').value.trim();
    const statusDiv = document.querySelector('.api-status');
  
    if (!apiKey) {
      statusDiv.textContent = 'Please enter your API key.';
      statusDiv.className = 'api-status error';
      return;
    }
  
    // Test the API key first
    fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-exp-03-25:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: "Hello! This is a test message."
          }]
        }]
      })
    })
    .then(response => {
      if (!response.ok) throw new Error('Invalid API key');
      return response.json();
    })
    .then(() => {
      geminiConfig = {
        apiKey: apiKey
      };
      
      // Save to localStorage
      localStorage.setItem('geminiConfig', JSON.stringify(geminiConfig));
    
      // Show success message
      statusDiv.textContent = 'API key verified and configuration saved successfully!';
      statusDiv.className = 'api-status success';
    
      // Hide message after 3 seconds
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 3000);
    })
    .catch(error => {
      statusDiv.textContent = 'Error validating API key: ' + error.message;
      statusDiv.className = 'api-status error';
    });
  }

  async function generateWebsite() {
    const prompt = document.getElementById('websitePrompt').value.trim();
    if (!prompt) {
      alert('Please describe the website you want to create.');
      return;
    }
  
    if (!geminiConfig.apiKey) {
      alert('Please configure your Gemini API key first.');
      return;
    }

    const button = document.getElementById('generateButton');
    button.classList.add('generating');
    button.disabled = true;

    try {
      // Call Gemini API with corrected model name
      const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-exp-03-25:generateContent?key=' + geminiConfig.apiKey, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: `Generate a complete, working website based on this description: ${prompt}

Requirements:
- Use semantic HTML5
- Include embedded CSS and JavaScript
- Make it responsive for mobile and desktop
- Use modern features like CSS Grid, Flexbox, and CSS Variables
- Include basic animations and transitions
- Keep it simple and clean
- No external dependencies except normalize.css
- Use inline SVG for icons
- Ensure it's accessible
- Include error handling in JavaScript
- Add helpful comments

Return only the complete HTML document with embedded styles and scripts. No explanation needed.`
            }]
          }]
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        throw new Error(
          `API request failed with status ${response.status}: ${
            errorData ? JSON.stringify(errorData) : response.statusText
          }`
        );
      }

      const data = await response.json();
      
      if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
        throw new Error('Invalid response format from API');
      }

      let generatedCode = data.candidates[0].content.parts[0].text;

      // Extract just the HTML if the response includes any explanatory text
      const htmlMatch = generatedCode.match(/<!DOCTYPE html>[\s\S]*<\/html>/i);
      if (htmlMatch) {
        generatedCode = htmlMatch[0];
      } else {
        throw new Error('No valid HTML found in the generated response');
      }

      // Process the generated code
      const parser = new DOMParser();
      const doc = parser.parseFromString(generatedCode, 'text/html');

      // Add normalize.css
      const normalizeLink = doc.createElement('link');
      normalizeLink.rel = 'stylesheet';
      normalizeLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css';
      doc.head.insertBefore(normalizeLink, doc.head.firstChild);

      // Add viewport meta if not present
      if (!doc.querySelector('meta[name="viewport"]')) {
        const viewport = doc.createElement('meta');
        viewport.name = 'viewport';
        viewport.content = 'width=device-width, initial-scale=1.0';
        doc.head.insertBefore(viewport, doc.head.firstChild);
      }

      // Update the current website code
      currentWebsiteCode = doc.documentElement.outerHTML;
      isZipProject = false;
      currentProjectId = null; // This is a new local project
      currentProjectName = 'AI Generated Project';
      processHTMLContent(currentWebsiteCode);

      // Hide the create new section
      checkForProject();

      // Update UI to show success
      alert('Website generated successfully!');
    } catch (error) {
      console.error('Error details:', error);
      alert('Error generating website: ' + error.message + '\nPlease check your API key and try again.');
    } finally {
      button.classList.remove('generating');
      button.disabled = false;
    }
  }

async function processHTMLContent(content) {
  try {
    currentWebsiteCode = '';
    
    // Clear previous registries
    Object.keys(functionRegistry).forEach(key => delete functionRegistry[key]);
    styleRegistry = {};
    eventRegistry = {};
    
    // Load the HTML into the preview frame
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    frameDoc.open();
    
    if (isZipProject) {
      // Create a new HTML document with rewritten resource paths
      const tempDoc = document.createElement('div');
      tempDoc.innerHTML = content;
      
      // Get the directory of the current HTML file
      const currentDir = currentFilePath.substring(0, currentFilePath.lastIndexOf('/') + 1);

      // Process all elements with src attributes
      ['img', 'video', 'audio', 'source', 'track', 'embed', 'iframe'].forEach(tagName => {
        Array.from(tempDoc.getElementsByTagName(tagName)).forEach(element => {
          const src = element.getAttribute('src');
          if (src && !src.startsWith('http') && !src.startsWith('data:')) {
            const resourcePath = resolveRelativePath(currentDir, src);
            const resource = projectFiles[resourcePath];
            if (resource) {
              if (resource.type === 'image' || resource.type === 'binary') {
                element.src = resource.url;
                // Store original path for download restoration
                element.setAttribute('data-original-path', src);
              }
            }
          }
        });
      });
      
      // Process links (CSS, favicons, etc.)
      Array.from(tempDoc.getElementsByTagName('link')).forEach(link => {
        if (link.rel === 'stylesheet' || link.rel.includes('icon')) {
          const href = link.getAttribute('href');
          if (href && !href.startsWith('http')) {
            const resourcePath = resolveRelativePath(currentDir, href);
            const resource = projectFiles[resourcePath];
            if (resource) {
              if (resource.type === 'text') {
                // Replace link with style tag for preview
                const style = document.createElement('style');
                style.textContent = resource.content;
                link.parentNode.replaceChild(style, link);
              } else if (resource.type === 'image' || resource.type === 'binary') {
                link.href = resource.url;
                // Store original path for download restoration
                link.setAttribute('data-original-path', href);
              }
            }
          }
        }
      });
      
      // Process background images in style attributes
      Array.from(tempDoc.querySelectorAll('[style*="background"]')).forEach(element => {
        let style = element.getAttribute('style');
        if (style) {
          const urlMatch = style.match(/url\(['"]?([^'")\s]+)['"]?\)/);
          if (urlMatch && !urlMatch[1].startsWith('http') && !urlMatch[1].startsWith('data:')) {
            const resourcePath = resolveRelativePath(currentDir, urlMatch[1]);
            const resource = projectFiles[resourcePath];
            if (resource && (resource.type === 'image' || resource.type === 'binary')) {
              element.style.cssText = style.replace(urlMatch[1], resource.url);
              // Store original path for download restoration
              element.setAttribute('data-original-style-url', urlMatch[1]);
            }
          }
        }
      });
      
      // Process scripts
      Array.from(tempDoc.getElementsByTagName('script')).forEach(script => {
        if (script.src && !script.src.startsWith('http')) {
          const resourcePath = resolveRelativePath(currentDir, script.src);
          const resource = projectFiles[resourcePath];
          if (resource && resource.type === 'text') {
            script.removeAttribute('src');
            script.textContent = resource.content;
          }
        }
      });
      
      // Write the processed HTML
      frameDoc.write(tempDoc.innerHTML);
    } else {
      // For single HTML files
      frameDoc.write(content);
      currentWebsiteCode = content;
    }
    
    frameDoc.close();
    
    // Inject console logging script
    if (frameDoc.body) {
      const scriptEl = frameDoc.createElement('script');
      scriptEl.textContent = `
        (function() {
          var originalLog = console.log;
          var originalError = console.error;
          var originalWarn = console.warn;
          var originalInfo = console.info;
          function sendToParent(type, args) {
            try {
              window.parent.receiveConsoleLog(type, args);
            } catch(e) {}
          }
          console.log = function() {
            originalLog.apply(console, arguments);
            sendToParent('log', Array.from(arguments));
          };
          console.error = function() {
            originalError.apply(console, arguments);
            sendToParent('error', Array.from(arguments));
          };
          console.warn = function() {
            originalWarn.apply(console, arguments);
            sendToParent('warn', Array.from(arguments));
          };
          console.info = function() {
            originalInfo.apply(console, arguments);
            sendToParent('info', Array.from(arguments));
          };
          window.onerror = function(message, source, lineno, colno, error) {
            sendToParent('error', [message, 'Source:', source, 'Line:', lineno, 'Col:', colno, error ? error.stack : '']);
          };
          window.onunhandledrejection = function(event) {
            sendToParent('error', ['Unhandled rejection:', event.reason]);
          };
        })();
      `;
      frameDoc.body.appendChild(scriptEl);
    }
    
    // Process JavaScript and CSS
    const scripts = frameDoc.getElementsByTagName('script');
    Array.from(scripts).forEach(script => {
      if (script.textContent) {
        extractFunctions(script.textContent);
      }
    });
    
    const styles = frameDoc.getElementsByTagName('style');
    Array.from(styles).forEach(style => {
      if (style.textContent) {
        extractStyles(style.textContent);
      }
    });
    
    // Extract event handlers and set up click handling
    if (frameDoc.body) {
      extractEventHandlers(frameDoc.body);
      frameDoc.body.addEventListener('click', handleElementClick);
    }
    
    // Initialize drag and resize after the content is loaded
    setTimeout(() => {
      initializeDragAndResize();
      
      // Update the UI to reflect we have content
      checkForProject();
      
      // If this is a ZIP project, ensure the file tree is rendered
      if (isZipProject) {
        renderFileTree();
      }
      
      // Save to localStorage
      saveProjectToStorage();
    }, 500);
  } catch (error) {
    console.error('Error processing HTML content:', error);
    alert('Error loading website content: ' + error.message);
    checkForProject();
  }
  
}
  





  
  // Global function to receive console logs from the preview iframe and display them in #previewConsole
  function receiveConsoleLog(type, args) {
    const logContainer = document.getElementById('previewConsole');
    if (!logContainer) return;
    const logEntry = document.createElement('div');
    logEntry.className = `console-entry ${type}`;
    logEntry.textContent = '[' + type.toUpperCase() + '] ' + args.join(' ');
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
    
    // Add to conversation history
    conversationHistory.push({
      role: "assistant",
      content: `[${type.toUpperCase()}] ${args.join(' ')}`
    });
    
    // Keep only last 10 messages in history
    if (conversationHistory.length > 10) {
      conversationHistory = conversationHistory.slice(-10);
    }
  }

  // Add this near the other event listeners
document.getElementById('editCodeButton').addEventListener('click', openCodeEditor);

function openCodeEditor() {
  let codeToEdit = '';
  
  if (isZipProject) {
    // For ZIP projects, get the current file content
    if (currentFilePath && projectFiles[currentFilePath] && projectFiles[currentFilePath].type === 'text') {
      codeToEdit = projectFiles[currentFilePath].content;
    } else {
      alert('Please select a text file to edit.');
      return;
    }
  } else {
    // For single HTML files, get the current website code
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    codeToEdit = frameDoc.documentElement.outerHTML;
  }
  
  // Initialize and show code editor
  showCodeEditor(codeToEdit);
}

function showCodeEditor(code) {
  const modal = document.getElementById('code-review-modal');
  modal.style.display = 'block';
  
  initCodeEditor();
  editor.setValue(code, -1);
  editor.clearSelection();
}

async function saveCodeChanges() {
  const editedCode = editor.getValue();
  
  try {
    if (isZipProject) {
      // Update the project file content
      if (currentFilePath && projectFiles[currentFilePath]) {
        projectFiles[currentFilePath].content = editedCode;
        
        // Save to storage first
        await saveProjectToStorage();
        
        // Reload the file to show changes
        await loadProjectFile(currentFilePath);
        
        // Close the editor
        closeCodeReview();
        
        // Reload after a short delay to ensure everything completes
        setTimeout(() => {
          location.reload();
        }, 500); // 500ms delay
      }
    } else {
      // Update single HTML file
      currentWebsiteCode = editedCode;
      
      // Save to storage first
      await saveProjectToStorage();
      
      // Process the content
      await processHTMLContent(currentWebsiteCode);
      
      // Close the editor
      closeCodeReview();
      
      // Reload after a short delay
      setTimeout(() => {
        location.reload();
      }, 500); // 500ms delay
    }
  } catch (error) {
    console.error('Error saving changes:', error);
    alert('Error saving changes: ' + error.message);
  }
}
  const StorageUtils = {
    async compress(data) {
        try {
            const stream = new Blob([JSON.stringify(data)]).stream();
            const compressedStream = stream.pipeThrough(new CompressionStream('gzip'));
            const compressedBlob = await new Response(compressedStream).blob();
            return await new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.readAsDataURL(compressedBlob);
            });
        } catch (e) {
            console.warn('Compression failed, storing uncompressed', e);
            return JSON.stringify(data);
        }
    },

    async decompress(data) {
        try {
            // Check if it's compressed (starts with H4sI which is gzip magic number)
            if (data.startsWith('H4sI')) {
                const blob = await fetch(`data:application/gzip;base64,${data}`).then(r => r.blob());
                const stream = blob.stream().pipeThrough(new DecompressionStream('gzip'));
                const decompressed = await new Response(stream).text();
                return JSON.parse(decompressed);
            }
            return JSON.parse(data);
        } catch (e) {
            console.warn('Decompression failed, parsing as-is', e);
            return JSON.parse(data);
        }
    }
};

async function processFilesForStorage(files) {
  const result = {};
  
  for (const [path, file] of Object.entries(files)) {
    if (file.type === 'image' || file.type === 'binary') {
      // For binary files, store metadata and the blob URL
      result[path] = {
        type: file.type,
        mimeType: file.mimeType || getMimeType(path),
        size: file.blob?.size || 0,
        url: file.url, // Store the blob URL
        isBinary: true
      };
      
      // If we have a blob, store it as base64 if it's small enough
      if (file.blob && file.blob.size < 500000) { // 500KB limit
        try {
          result[path].content = await blobToBase64(file.blob);
          result[path].oversized = false;
        } catch (e) {
          console.warn(`Couldn't convert blob to base64 for ${path}`, e);
          result[path].oversized = true;
        }
      } else if (file.blob) {
        result[path].oversized = true;
      }
    } else {
      // For text files, store the content directly
      result[path] = {
        type: 'text',
        content: file.content
      };
    }
  }
  
  return result;
}
  
// --- AUTH & PROJECT MANAGEMENT ---

function initApp() {
    const savedUser = localStorage.getItem('currentUser');
    if (savedUser) {
        currentUser = JSON.parse(savedUser);
    }
    updateUserUI();
    setupEventListeners();
}

function updateUserUI() {
    const userInfo = document.getElementById('user-info');
    const authButton = document.getElementById('auth-button');
    const logoutButton = document.getElementById('logout-button');
    const projectsButton = document.getElementById('projects-button');
    const saveButton = document.getElementById('save-project-button');

    if (currentUser) {
        userInfo.textContent = `Welcome, ${currentUser.username}`;
        userInfo.style.display = 'inline';
        authButton.style.display = 'none';
        logoutButton.style.display = 'inline-block';
        projectsButton.style.display = 'inline-block';
        saveButton.style.display = 'inline-block';
    } else {
        userInfo.style.display = 'none';
        authButton.style.display = 'inline-block';
        logoutButton.style.display = 'none';
        projectsButton.style.display = 'none';
        saveButton.style.display = 'none';
    }
}

function setupEventListeners() {
    document.getElementById('auth-button').addEventListener('click', () => showAuthModal(true));
    document.getElementById('logout-button').addEventListener('click', handleLogout);
    document.getElementById('projects-button').addEventListener('click', handleOpenProjectBrowser);
    document.getElementById('save-project-button').addEventListener('click', handleSaveProject);
    document.getElementById('login-submit').addEventListener('click', handleLogin);
    document.getElementById('signup-submit').addEventListener('click', handleSignup);
    document.getElementById('create-new-project-button').addEventListener('click', () => {
        clearCurrentProject();
        showProjectBrowser(false);
    });
    
    document.querySelectorAll('.modal-close').forEach(btn => {
        btn.addEventListener('click', () => {
            showAuthModal(false);
            showProjectBrowser(false);
        });
    });
}

function showAuthModal(show) {
    document.getElementById('auth-modal').style.display = show ? 'block' : 'none';
    document.getElementById('auth-message').textContent = '';
}

function showProjectBrowser(show) {
    document.getElementById('project-browser-modal').style.display = show ? 'block' : 'none';
    document.getElementById('project-message').textContent = '';
}

async function handleLogin() {
    const username = document.getElementById('auth-username').value;
    const password = document.getElementById('auth-password').value;
    const messageEl = document.getElementById('auth-message');

    if (!username || !password) {
        messageEl.textContent = 'Please enter both username and password.';
        return;
    }
    messageEl.textContent = 'Logging in...';

    try {
        const user = await api.login(username, password);
        currentUser = user;
        localStorage.setItem('currentUser', JSON.stringify(user));
        updateUserUI();
        showAuthModal(false);
        handleOpenProjectBrowser();
    } catch (error) {
        messageEl.textContent = `Login failed: ${error.message}`;
    }
}

async function handleSignup() {
    const username = document.getElementById('auth-username').value;
    const password = document.getElementById('auth-password').value;
    const messageEl = document.getElementById('auth-message');

    if (!username || !password) {
        messageEl.textContent = 'Please enter both username and password.';
        return;
    }
    messageEl.textContent = 'Signing up...';

    try {
        const response = await api.signup(username, password);
        messageEl.textContent = 'Signup successful! Please log in.';
    } catch (error) {
        messageEl.textContent = `Signup failed: ${error.message}`;
    }
}

function handleLogout() {
    currentUser = null;
    localStorage.removeItem('currentUser');
    updateUserUI();
    clearCurrentProject();
}

async function handleOpenProjectBrowser() {
    if (!currentUser) {
        showAuthModal(true);
        return;
    }
    showProjectBrowser(true);
    const container = document.getElementById('project-list-container');
    container.innerHTML = '<p>Loading projects...</p>';

    try {
        const projects = await api.listProjects(currentUser.id);
        if (projects.length === 0) {
            container.innerHTML = '<p>No projects found. Start a new one!</p>';
        } else {
            container.innerHTML = '';
            projects.forEach(proj => {
                const item = document.createElement('div');
                item.className = 'project-item';
                item.innerHTML = `
                    <span class="project-item-name">${escapeHtml(proj.name)}</span>
                    <div class="project-item-actions">
                        <button class="load-btn">Load</button>
                        <button class="delete-btn delete">Delete</button>
                    </div>
                `;
                item.querySelector('.load-btn').onclick = () => handleLoadProject(proj.id);
                item.querySelector('.delete-btn').onclick = () => handleDeleteProject(proj.id, proj.name);
                container.appendChild(item);
            });
        }
    } catch (error) {
        container.innerHTML = `<p class="error-message">Error loading projects: ${error.message}</p>`;
    }
}

async function handleLoadProject(projectId) {
    showProjectBrowser(false);
    showToast(`Loading project...`);
    try {
        const project = await api.loadProject(currentUser.id, projectId);
        const projectData = JSON.parse(project.projectData);
        await applyLoadedProjectData(projectData);
        currentProjectId = projectId; // Set the current project ID
        currentProjectName = projectData.name || 'Untitled Project';
        showToast('Project loaded successfully!');
    } catch (error) {
        alert(`Failed to load project: ${error.message}`);
    }
}

async function handleDeleteProject(projectId, projectName) {
    if (!confirm(`Are you sure you want to delete "${projectName}"? This cannot be undone.`)) {
        return;
    }
    try {
        await api.deleteProject(currentUser.id, projectId);
        showToast('Project deleted.');
        // Refresh the list
        handleOpenProjectBrowser();
    } catch (error) {
        alert(`Failed to delete project: ${error.message}`);
    }
}

async function handleSaveProject() {
    if (!currentUser) {
        alert('Please log in to save projects to the cloud.');
        return;
    }

    if (!currentProjectId) {
        const name = prompt('Please enter a name for this new project:', currentProjectName);
        if (!name) return; // User cancelled
        currentProjectName = name;
        currentProjectId = `proj_${Date.now()}`;
    }
    
    showToast('Saving project to cloud...');
    try {
        const projectData = await gatherProjectDataForSaving();
        api.saveProject(currentUser.id, currentProjectId, projectData); // This is fire-and-forget due to the queue
        showToast(`Project "${currentProjectName}" is being saved.`);
    } catch (error) {
        alert(`Failed to save project: ${error.message}`);
    }
}

async function gatherProjectDataForSaving() {
    const data = {
        name: currentProjectName,
        isZipProject,
        currentFilePath,
        currentWebsiteCode,
        projectFiles: {}
    };

    if (isZipProject) {
        for (const [path, file] of Object.entries(projectFiles)) {
             if (file.type === 'text') {
                data.projectFiles[path] = { type: 'text', content: file.content };
            } else if ((file.type === 'image' || file.type === 'binary') && file.blob) {
                // Convert blob to base64 to save in JSON
                data.projectFiles[path] = {
                    type: file.type,
                    content: await blobToBase64(file.blob), // Await the conversion
                    mimeType: getMimeType(path)
                };
            }
        }
    }
    return data;
}

async function applyLoadedProjectData(data) {
    await clearCurrentProject(); // Start with a clean slate
    isZipProject = data.isZipProject;
    currentFilePath = data.currentFilePath;
    currentWebsiteCode = data.currentWebsiteCode;
    projectFiles = {};

    if (isZipProject && data.projectFiles) {
        for (const [path, fileData] of Object.entries(data.projectFiles)) {
            if (fileData.type === 'text') {
                projectFiles[path] = { type: 'text', content: fileData.content };
            } else if (fileData.type === 'image' || fileData.type === 'binary') {
                // Convert base64 back to blob URL
                const blob = await base64ToBlob(fileData.content, fileData.mimeType);
                projectFiles[path] = {
                    type: fileData.type,
                    blob: blob,
                    url: URL.createObjectURL(blob)
                };
            }
        }
        renderFileTree();
        if (currentFilePath) {
            await loadProjectFile(currentFilePath);
        }
    } else if (currentWebsiteCode) {
        await processHTMLContent(currentWebsiteCode);
    }
}


function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result.split(',')[1]);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

async function base64ToBlob(base64, mimeType = '') {
    const res = await fetch(`data:${mimeType};base64,${base64}`);
    return await res.blob();
}

function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => resolve(e.target.result);
    reader.onerror = e => reject(new Error('File read failed'));
    reader.readAsText(file);
  });
}
  
</script>
</body>
  </html>
