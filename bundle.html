<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VibeParticles - Interactive Generative Art</title>
    <style>body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
            color: white;
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .ui-layer {
            position: relative;
            z-index: 10;
            pointer-events: none;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
        }

        .header {
            pointer-events: auto;
        }

        .header h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2.5rem;
            margin: 0;
            background: linear-gradient(90deg, #fff, #4F46E5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls-panel {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            border-radius: 1.5rem;
            width: fit-content;
            max-width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .controls-group {
            margin-bottom: 1.5rem;
        }

        .controls-group:last-child { margin-bottom: 0; }

        .controls-group label {
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #9CA3AF;
            margin-bottom: 0.75rem;
        }

        .mode-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid transparent;
            color: white;
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .mode-btn.active {
            background: #4F46E5;
            border-color: #6366F1;
        }

        .tracking-btn {
            margin-top: 1rem;
            width: 100%;
            background: rgba(79, 70, 229, 0.2);
            border: 1px solid rgba(79, 70, 229, 0.4);
            color: #A5B4FC;
            display: block;
        }

        .tracking-btn.active {
            background: #4F46E5;
            color: white;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #4F46E5;
        }

        .info-text {
            font-size: 0.875rem;
            color: #9CA3AF;
            margin-top: 1rem;
        }

        .cam-preview-container {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 160px;
            height: 120px;
            border-radius: 1rem;
            overflow: hidden;
            border: 2px solid rgba(79, 70, 229, 0.5);
            background: #000;
            z-index: 100;
            display: none;
            transform: scaleX(-1); /* Mirror effect for intuitive tracking */
        }

        #vibe-video {
            display: none;
        }

        #hand-landmarks-canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }</style>
</head>
<body>
<canvas data-vibe-node-id="html-particle-canvas" data-vibe-node-id="html-particle-canvas" id="particle-canvas"></canvas>
<main data-vibe-node-id="html-main-section-1" data-vibe-node-id="html-main-section-1" class="ui-layer" id="main-section-1">
        <header class="header">
            <h1>VibeParticles</h1>
            <p>Interactive Generative Art</p>
        </header>

        <div class="controls-panel">
            <div class="controls-group">
                <label>Particle Mode</label>
                <div class="mode-grid">
                    <button class="mode-btn active" data-mode="constellation">Constellation</button>
                    <button class="mode-btn" data-mode="fireflies">Fireflies</button>
                    <button class="mode-btn" data-mode="vortex">Vortex</button>
                    <button class="mode-btn" data-mode="matrix">Matrix</button>
                </div>
            </div>

            <div class="controls-group">
                <label id="count-label">Density: 100</label>
                <input type="range" id="particle-count" min="20" max="500" value="100">
            </div>

            <div class="controls-group">
                <label>Speed</label>
                <input type="range" id="particle-speed" min="1" max="10" value="2">
            </div>

            <div class="controls-group">
                <label>Interaction</label>
                <button id="toggle-hand-tracking" class="mode-btn tracking-btn">Enable Hand Tracking</button>
            </div>

            <p class="info-text">Move your mouse or enable tracking to interact.</p>
        </div>
    </main>
<div data-vibe-node-id="html-cam-preview-container" data-vibe-node-id="html-cam-preview-container" id="cam-preview-container" class="cam-preview-container">
        <video id="vibe-video" playsinline=""></video>
        <canvas id="hand-landmarks-canvas"></canvas>
    </div>
    <script>
/* --- Vibe Database Connector --- */
(function() {
    const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbx5p0NpHuIfVUuziW4VkqwTJERjAMpgIdKz0yCO4vVkFt38FerGObaxQQxqPJ2h8RB1yA/exec';
    const USER_ID = 'user-e4a3399d-d41c-423f-9f0d-05603a1b4e4b';
    const PROJECT_ID = 'functors';
    const CHUNK_SIZE = 1500;

    if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes('YOUR_APPS_SCRIPT') || !USER_ID || !PROJECT_ID) {
        window.vibe = { loadData: () => Promise.resolve([]) };
        return;
    }

    const getFormDbId = (formId) => `${PROJECT_ID}__form__${formId}`;

    function jsonpRequest(action, params = {}) {
        return new Promise((resolve, reject) => {
            const callbackName = 'vibe_jsonp_callback_' + Math.round(100000 * Math.random());
            const script = document.createElement('script');
            let url = `${APPS_SCRIPT_URL}?action=${action}&callback=${callbackName}`;
            for (const key in params) {
                url += `&${key}=${encodeURIComponent(params[key])}`;
            }
            script.src = url;
            window[callbackName] = (data) => {
                delete window[callbackName];
                document.body.removeChild(script);
                if (data.status === 'success') resolve(data.data);
                else reject(new Error(data.message || 'API Error'));
            };
            script.onerror = () => {
                delete window[callbackName];
                document.body.removeChild(script);
                reject(new Error('API request failed.'));
            };
            document.body.appendChild(script);
        });
    }
    
    function decompressData(dataString) {
        const binaryString = atob(dataString);
        const uint8Array = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            uint8Array[i] = binaryString.charCodeAt(i);
        }
        const jsonString = new TextDecoder().decode(uint8Array);
        return JSON.parse(jsonString);
    }

    async function saveProjectInChunks(projectId, data) {
        const jsonString = JSON.stringify(data);
        const uint8Array = new TextEncoder().encode(jsonString);
        let binaryString = '';
        uint8Array.forEach(byte => { binaryString += String.fromCharCode(byte); });
        const dataString = btoa(binaryString);

        const chunks = [];
        for (let i = 0; i < dataString.length; i += CHUNK_SIZE) {
            chunks.push(dataString.substring(i, i + CHUNK_SIZE));
        }

        for (let i = 0; i < chunks.length; i++) {
            await jsonpRequest('saveProjectChunk', {
                userId: USER_ID,
                projectId: projectId,
                chunkData: chunks[i],
                chunkIndex: i,
                totalChunks: chunks.length,
                compressed: false,
            });
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    async function saveFormData(formId, formData) {
        const formDbId = getFormDbId(formId);
        let submissions = [];
        try {
            const existingData = await window.vibe.loadData(formId);
            if (Array.isArray(existingData)) {
                submissions = existingData;
            }
        } catch (e) {
            console.log('No existing data for this form, creating new list.');
        }
        
        submissions.push({
            timestamp: new Date().toISOString(),
            data: formData
        });

        await saveProjectInChunks(formDbId, submissions);
    }

    window.vibe = {
        loadData: async function(formId) {
            if (!formId) {
                return Promise.reject(new Error('formId is required.'));
            }
            try {
                const formDbId = getFormDbId(formId);
                const compressedData = await jsonpRequest('loadProject', { userId: USER_ID, projectId: formDbId });
                return decompressData(compressedData);
            } catch (e) {
                return [];
            }
        }
    };

    document.addEventListener('submit', async (e) => {
        const form = e.target;
        const formId = form.getAttribute('data-vibe-form');
        if (!formId) return;

        e.preventDefault();
        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        const submitButton = form.querySelector('button[type="submit"], input[type="submit"]');
        let originalButtonContent = '';
        if (submitButton) {
            originalButtonContent = submitButton.innerHTML || submitButton.value;
            submitButton.disabled = true;
            submitButton.value = 'Submitting...';
            submitButton.innerHTML = 'Submitting...';
        }

        try {
            await saveFormData(formId, data);
            form.innerHTML = '<p style="text-align: center; color: green; padding: 20px;">Thank you for your submission!</p>';
        } catch (error) {
            console.error('Form submission failed:', error);
            const errorEl = document.createElement('p');
            errorEl.style.color = 'red';
            errorEl.textContent = 'Submission failed. Please try again later.';
            form.appendChild(errorEl);
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.value = originalButtonContent;
                submitButton.innerHTML = originalButtonContent;
            }
        }
    }, true);
})();
</script>
    <script>(function() {/* --- Vibe Database Connector --- */
    (function() {
        const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbx5p0NpHuIfVUuziW4VkqwTJERjAMpgIdKz0yCO4vVkFt38FerGObaxQQxqPJ2h8RB1yA/exec';
        const USER_ID = 'user-e4a3399d-d41c-423f-9f0d-05603a1b4e4b';
        const PROJECT_ID = 'functors';
        const CHUNK_SIZE = 1500;

        if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes('YOUR_APPS_SCRIPT') || !USER_ID || !PROJECT_ID) {
            window.vibe = { loadData: () => Promise.resolve([]) };
            return;
        }

        const getFormDbId = (formId) => `${PROJECT_ID}__form__${formId}`;

        function jsonpRequest(action, params = {}) {
            return new Promise((resolve, reject) => {
                const callbackName = 'vibe_jsonp_callback_' + Math.round(100000 * Math.random());
                const script = document.createElement('script');
                let url = `${APPS_SCRIPT_URL}?action=${action}&callback=${callbackName}`;
                for (const key in params) {
                    url += `&${key}=${encodeURIComponent(params[key])}`;
                }
                script.src = url;
                window[callbackName] = (data) => {
                    delete window[callbackName];
                    document.body.removeChild(script);
                    if (data.status === 'success') resolve(data.data);
                    else reject(new Error(data.message || 'API Error'));
                };
                script.onerror = () => {
                    delete window[callbackName];
                    document.body.removeChild(script);
                    reject(new Error('API request failed.'));
                };
                document.body.appendChild(script);
            });
        }
        
        function decompressData(dataString) {
            const binaryString = atob(dataString);
            const uint8Array = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                uint8Array[i] = binaryString.charCodeAt(i);
            }
            const jsonString = new TextDecoder().decode(uint8Array);
            return JSON.parse(jsonString);
        }

        async function saveProjectInChunks(projectId, data) {
            const jsonString = JSON.stringify(data);
            const uint8Array = new TextEncoder().encode(jsonString);
            let binaryString = '';
            uint8Array.forEach(byte => { binaryString += String.fromCharCode(byte); });
            const dataString = btoa(binaryString);

            const chunks = [];
            for (let i = 0; i < dataString.length; i += CHUNK_SIZE) {
                chunks.push(dataString.substring(i, i + CHUNK_SIZE));
            }

            for (let i = 0; i < chunks.length; i++) {
                await jsonpRequest('saveProjectChunk', {
                    userId: USER_ID,
                    projectId: projectId,
                    chunkData: chunks[i],
                    chunkIndex: i,
                    totalChunks: chunks.length,
                    compressed: false,
                });
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        async function saveFormData(formId, formData) {
            const formDbId = getFormDbId(formId);
            let submissions = [];
            try {
                const existingData = await window.vibe.loadData(formId);
                if (Array.isArray(existingData)) {
                    submissions = existingData;
                }
            } catch (e) {
                console.log('No existing data for this form, creating new list.');
            }
            
            submissions.push({
                timestamp: new Date().toISOString(),
                data: formData
            });

            await saveProjectInChunks(formDbId, submissions);
        }

        window.vibe = {
            loadData: async function(formId) {
                if (!formId) {
                    return Promise.reject(new Error('formId is required.'));
                }
                try {
                    const formDbId = getFormDbId(formId);
                    const compressedData = await jsonpRequest('loadProject', { userId: USER_ID, projectId: formDbId });
                    return decompressData(compressedData);
                } catch (e) {
                    return [];
                }
            }
        };

        document.addEventListener('submit', async (e) => {
            const form = e.target;
            const formId = form.getAttribute('data-vibe-form');
            if (!formId) return;

            e.preventDefault();
            const formData = new FormData(form);
            const data = Object.fromEntries(formData.entries());
            const submitButton = form.querySelector('button[type="submit"], input[type="submit"]');
            let originalButtonContent = '';
            if (submitButton) {
                originalButtonContent = submitButton.innerHTML || submitButton.value;
                submitButton.disabled = true;
                submitButton.value = 'Submitting...';
                submitButton.innerHTML = 'Submitting...';
            }

            try {
                await saveFormData(formId, data);
                form.innerHTML = '<p style="text-align: center; color: green; padding: 20px;">Thank you for your submission!</p>';
            } catch (error) {
                console.error('Form submission failed:', error);
                const errorEl = document.createElement('p');
                errorEl.style.color = 'red';
                errorEl.textContent = 'Submission failed. Please try again later.';
                form.appendChild(errorEl);
                if (submitButton) {
                    submitButton.disabled = false;
                    submitButton.value = originalButtonContent;
                    submitButton.innerHTML = originalButtonContent;
                }
            }
        }, true);
    })();

(function() {
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let particles = [];
        let mouse = { x: -100, y: -100 };
        let currentMode = 'constellation';
        let speedMultiplier = 2;
        let targetDensity = 100;

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            if (typeof initParticles === 'function') initParticles();
        }

        window.addEventListener('resize', resize);

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * speedMultiplier;
                this.vy = (Math.random() - 0.5) * speedMultiplier;
                this.size = Math.random() * 2 + 1;
                this.alpha = Math.random();
                this.hue = Math.random() * 40 + 220;
            }

            update() {
                if (currentMode === 'constellation') {
                    this.x += this.vx;
                    this.y += this.vy;
                    if (this.x < 0 || this.x > width) this.vx *= -1;
                    if (this.y < 0 || this.y > height) this.vy *= -1;
                } else if (currentMode === 'fireflies') {
                    this.x += this.vx + Math.sin(Date.now() * 0.001 + this.x) * 0.5;
                    this.y += this.vy + Math.cos(Date.now() * 0.001 + this.y) * 0.5;
                    this.alpha = 0.3 + Math.abs(Math.sin(Date.now() * 0.002 + this.x)) * 0.7;
                    if (this.x < -10) this.x = width + 10;
                    if (this.x > width + 10) this.x = -10;
                    if (this.y < -10) this.y = height + 10;
                    if (this.y > height + 10) this.y = -10;
                } else if (currentMode === 'vortex') {
                    const dx = width / 2 - this.x;
                    const dy = height / 2 - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    const force = 0.01 * speedMultiplier;
                    this.vx += Math.cos(angle + Math.PI/2) * force + dx * 0.0001;
                    this.vy += Math.sin(angle + Math.PI/2) * force + dy * 0.0001;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.98;
                    this.vy *= 0.98;
                    if (dist < 10) this.reset();
                } else if (currentMode === 'matrix') {
                    this.y += (this.size * 2) * (speedMultiplier / 2);
                    if (this.y > height) {
                        this.y = -20;
                        this.x = Math.random() * width;
                    }
                }
            }

            draw() {
                if (currentMode === 'matrix') {
                    ctx.fillStyle = '#0F0';
                    ctx.font = '10px monospace';
                    ctx.fillText(Math.floor(Math.random()*10), this.x, this.y);
                    return;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                if (currentMode === 'fireflies') {
                    ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${this.alpha})`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `hsla(${this.hue}, 100%, 70%, 1)`;
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,' + this.alpha + ')';
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
            }
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < targetDensity; i++) {
                particles.push(new Particle());
            }
        }

        function drawConnections() {
            if (currentMode !== 'constellation') return;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 100) {
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
                const dxMouse = particles[i].x - mouse.x;
                const dyMouse = particles[i].y - mouse.y;
                const distMouse = Math.sqrt(dxMouse * dxMouse + dyMouse * dyMouse);
                if (distMouse < 150) {
                    ctx.strokeStyle = `rgba(79, 70, 229, ${1 - distMouse / 150})`;
                    ctx.beginPath();
                    ctx.moveTo(particles[i].x, particles[i].y);
                    ctx.lineTo(mouse.x, mouse.y);
                    ctx.stroke();
                }
            }
        }

        function loop() {
            ctx.clearRect(0, 0, width, height);
            drawConnections();
            particles.forEach(p => {
                p.update();
                p.draw();
            });
            requestAnimationFrame(loop);
        }

        document.querySelectorAll('.mode-btn:not(.tracking-btn)').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelector('.mode-btn.active').classList.remove('active');
                e.target.classList.add('active');
                currentMode = e.target.dataset.mode;
                initParticles();
            });
        });

        document.getElementById('particle-count').addEventListener('input', (e) => {
            targetDensity = parseInt(e.target.value);
            document.getElementById('count-label').textContent = `Density: ${targetDensity}`;
            initParticles();
        });

        document.getElementById('particle-speed').addEventListener('input', (e) => {
            speedMultiplier = parseInt(e.target.value);
            particles.forEach(p => {
                p.vx = (Math.random() - 0.5) * speedMultiplier;
                p.vy = (Math.random() - 0.5) * speedMultiplier;
            });
        });

        resize();
        loop();

        const videoElement = document.getElementById('vibe-video');
        const camContainer = document.getElementById('cam-preview-container');
        const toggleBtn = document.getElementById('toggle-hand-tracking');
        const landmarkCanvas = document.getElementById('hand-landmarks-canvas');
        const lmCtx = landmarkCanvas.getContext('2d');

        let handTrackingEnabled = false;
        let camera = null;

        function onResults(results) {
            lmCtx.save();
            lmCtx.clearRect(0, 0, landmarkCanvas.width, landmarkCanvas.height);
            lmCtx.drawImage(results.image, 0, 0, landmarkCanvas.width, landmarkCanvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8];

                mouse.x = (1 - indexTip.x) * width;
                mouse.y = indexTip.y * height;

                lmCtx.fillStyle = '#4F46E5';
                lmCtx.beginPath();
                lmCtx.arc(indexTip.x * landmarkCanvas.width, indexTip.y * landmarkCanvas.height, 5, 0, Math.PI * 2);
                lmCtx.fill();
            }
            lmCtx.restore();
        }

        async function toggleCamera() {
            if (!handTrackingEnabled) {
                try {
                    if (!camera) {
                        camera = new Camera(videoElement, {
                            onFrame: async () => {
                                await hands.send({image: videoElement});
                            },
                            width: 640,
                            height: 480
                        });
                    }
                    await camera.start();
                    handTrackingEnabled = true;
                    camContainer.style.display = 'block';
                    toggleBtn.textContent = 'Disable Hand Tracking';
                    toggleBtn.classList.add('active');
                } catch (err) {
                    console.error("Camera access denied", err);
                    alert("Could not access camera for hand tracking. Please ensure you have granted camera permissions.");
                }
            } else {
                if (camera) await camera.stop();
                handTrackingEnabled = false;
                camContainer.style.display = 'none';
                toggleBtn.textContent = 'Enable Hand Tracking';
                toggleBtn.classList.remove('active');
                mouse.x = -100;
                mouse.y = -100;
            }
        }

        // Initialize Hands after MediaPipe script is loaded
        let hands;
        try {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);
        } catch (e) {
            console.error("Failed to initialize MediaPipe Hands. Check your internet connection or script sources.", e);
        }

        toggleBtn.addEventListener('click', toggleCamera);
        landmarkCanvas.width = 160;
        landmarkCanvas.height = 120;
    })();})();</script>
</body>
</html>