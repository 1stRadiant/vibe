html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Code Merger (Robust Parser)</title>
    <style>
        /* --- CSS VARIABLES & RESET --- */
        :root {
            --bg: #1e1e1e;
            --panel: #252526;
            --border: #3c3c3c;
            --text: #d4d4d4;
            --accent: #007acc;
            --success: #2ea043;
            --danger: #f85149;
            --code-del: #451818;
            --code-add: #133618;
            --line-num: #858585;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }

        h1, h2, h3 { margin-top: 0; font-size: 1.1rem; color: #fff; margin-bottom: 10px; }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
        }

        /* --- CONTROLS --- */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding: 15px;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            align-items: center;
            flex-shrink: 0;
        }

        .file-upload-group { flex: 1; min-width: 250px; }
        .action-group { display: flex; gap: 10px; }

        /* --- WORKSPACE --- */
        .workspace {
            display: flex;
            gap: 20px;
            flex: 1;
            min-height: 0;
        }

        .column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
        }

        /* Text Input */
        textarea {
            width: 100%;
            height: 100%;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: none;
            border-radius: 4px;
            box-sizing: border-box;
            white-space: pre;
        }

        /* Diff List Scroll Area */
        .diff-list {
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding-right: 5px;
            height: 100%;
            padding-bottom: 40px;
        }

        /* --- DIFF CARD STYLING --- */
        .diff-card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .diff-header {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid var(--border);
            background: #2d2d2d;
            border-radius: 6px 6px 0 0;
            flex-wrap: wrap;
            gap: 10px;
        }

        .diff-info { display: flex; flex-direction: column; gap: 5px; }
        .diff-type { font-weight: bold; font-size: 0.9em; }
        .type-replace { color: #faa356; }
        .type-insert { color: #89d185; }

        .diff-actions { display: flex; flex-direction: column; align-items: flex-end; gap: 8px; }
        .btn-row { display: flex; gap: 8px; }
        
        .location-wrapper {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        select.location-select {
            background: var(--bg);
            color: white;
            border: 1px solid var(--border);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            max-width: 200px;
        }

        input.line-input {
            background: var(--bg);
            color: white;
            border: 1px solid var(--border);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            width: 60px;
        }
        
        .hidden { display: none; }

        /* --- BUTTONS --- */
        button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: white;
            font-size: 12px;
            transition: opacity 0.2s;
        }
        button:hover { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: not-allowed; background-color: var(--border); }

        .btn-primary { background-color: var(--accent); }
        .btn-success { background-color: var(--success); }
        .btn-secondary { background-color: var(--border); color: var(--text); }

        /* --- CODE VIEW --- */
        .code-compare-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            background: #1e1e1e;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.5;
            border-radius: 0 0 6px 6px;
            overflow: hidden;
        }
        
        .code-compare-container.insert-mode {
            grid-template-columns: 1fr;
        }

        .code-pane {
            display: flex;
            overflow-x: auto;
            padding: 10px 0;
            position: relative;
        }

        .original { background-color: #2d1818; border-right: 1px solid var(--border); }
        .replacement { background-color: #122615; }
        .insert-only { background-color: #122615; }

        .line-numbers {
            text-align: right;
            padding: 0 10px;
            color: var(--line-num);
            border-right: 1px solid var(--border);
            user-select: none;
            min-width: 30px;
        }

        .code-content {
            padding: 0 10px;
            white-space: pre;
            color: #d4d4d4;
            tab-size: 4;
            flex: 1;
            outline: none;
        }

        .code-content[contenteditable="true"] { cursor: text; }
        .code-content[contenteditable="true"]:focus { background-color: #18301b; }

        /* --- BADGES --- */
        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            text-transform: uppercase;
            font-weight: bold;
            margin-top: 5px;
            align-self: flex-start;
        }
        .status-pending { background: #444; color: #ddd; }
        .status-approved { background: var(--success); color: white; }
        .status-rejected { background: var(--border); color: #888; text-decoration: line-through; }
        
        .match-reason {
            font-size: 0.8em;
            color: #888;
            font-style: italic;
        }

        @media (max-width: 900px) {
            body { padding: 10px; height: auto; min-height: 100vh; overflow: auto; }
            .workspace { flex-direction: column; height: auto; }
            .column { min-height: 500px; }
            .code-compare-container { grid-template-columns: 1fr; }
            .original { border-bottom: 1px solid var(--border); border-right: none; }
            .diff-header { flex-direction: column; align-items: stretch; }
            .diff-actions { align-items: stretch; margin-top: 10px; }
            .btn-row { justify-content: space-between; }
        }
    </style>
</head>
<body>

    <div class="container">
        <!-- Top Controls -->
        <div class="controls">
            <div class="file-upload-group">
                <label for="fileInput" style="display:block; font-size:0.8em; margin-bottom:4px; color:#aaa;">1. Load Source File (.js/.ts)</label>
                <input type="file" id="fileInput" accept=".js,.jsx,.ts,.tsx" style="color:white;">
            </div>
            <div class="action-group">
                <button id="analyzeBtn" class="btn-primary" disabled>Analyze Segments</button>
                <button id="downloadBtn" class="btn-success" disabled>Download Updated File</button>
            </div>
        </div>

        <div class="workspace">
            <!-- Left: Input Area -->
            <div class="column">
                <h3>2. Paste AI Code Segment</h3>
                <textarea id="aiInput" placeholder="// Paste code here...&#10;function existingFunc() {&#10;   // This parser will handle brackets inside strings correctly!&#10;   const s = 'string with } bracket';&#10;}"></textarea>
            </div>

            <!-- Right: Interactive Diff -->
            <div class="column">
                <h3>3. Review, Edit & Merge</h3>
                <div id="diffContainer" class="diff-list">
                    <div style="text-align: center; color: #666; margin-top: 50px;">
                        Load a file and paste AI code to begin...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- STATE MANAGEMENT ---
        let sourceCode = "";
        let rawOriginalSource = ""; 
        let sourceFilename = "updated_script.js";
        let proposedPatches = [];
        let globalSourceSegments = [];

        // --- DOM ELEMENTS ---
        const fileInput = document.getElementById('fileInput');
        const aiInput = document.getElementById('aiInput');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const diffContainer = document.getElementById('diffContainer');

        // --- EVENT LISTENERS ---
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            sourceFilename = file.name;
            const reader = new FileReader();
            reader.onload = (event) => {
                rawOriginalSource = event.target.result;
                sourceCode = rawOriginalSource;
                checkReady();
            };
            reader.readAsText(file);
        });

        aiInput.addEventListener('input', checkReady);

        function checkReady() {
            if (rawOriginalSource && aiInput.value.trim().length > 0) {
                analyzeBtn.disabled = false;
            }
        }

        analyzeBtn.addEventListener('click', () => {
            const updateCode = aiInput.value;
            performAnalysis(rawOriginalSource, updateCode);
        });

        downloadBtn.addEventListener('click', () => {
            applyPatchesToSource(); 
            downloadString(sourceCode, "updated_" + sourceFilename);
        });

        // --- CORE LOGIC: ROBUST PARSING & MATCHING ---

        function performAnalysis(source, update) {
            // Use the new Robust Parser
            globalSourceSegments = robustParser(source); 
            const updateSegments = robustParser(update);
            
            proposedPatches = [];
            diffContainer.innerHTML = '';

            const matchedSourceIndices = new Set();

            updateSegments.forEach((uSeg) => {
                let bestMatch = null;
                
                // 1. Strict Name Match (Best reliability)
                if (uSeg.name) {
                    // Try to find exact name match
                    const match = globalSourceSegments.find((sSeg, idx) => 
                        !matchedSourceIndices.has(idx) && sSeg.name === uSeg.name
                    );
                    if (match) {
                        bestMatch = { seg: match, reason: `Matched Name: "${uSeg.name}"`, index: globalSourceSegments.indexOf(match) };
                    }
                }

                // 2. Loose Name Match (Case insensitive or minor variance)
                if (!bestMatch && uSeg.name) {
                     const match = globalSourceSegments.find((sSeg, idx) => 
                        !matchedSourceIndices.has(idx) && 
                        sSeg.name && 
                        sSeg.name.toLowerCase() === uSeg.name.toLowerCase()
                    );
                    if (match) {
                        bestMatch = { seg: match, reason: `Matched Name (Approx): "${uSeg.name}"`, index: globalSourceSegments.indexOf(match) };
                    }
                }

                // 3. Normalized Signature Match (For anonymous functions or weird formatting)
                // We strip all whitespace to compare "function foo () {" vs "function foo(){"
                if (!bestMatch) {
                    const uSigNorm = cleanSignature(uSeg.signature);
                    const match = globalSourceSegments.find((sSeg, idx) => {
                        if (matchedSourceIndices.has(idx)) return false;
                        const sSigNorm = cleanSignature(sSeg.signature);
                        // Very high threshold for signature matching
                        return similarity(uSigNorm, sSigNorm) > 0.95; 
                    });
                    if (match) {
                        bestMatch = { seg: match, reason: "Matched Signature Logic", index: globalSourceSegments.indexOf(match) };
                    }
                }

                if (bestMatch) {
                    matchedSourceIndices.add(bestMatch.index);
                    // Check if content is actually different (ignoring simple whitespace changes)
                    if (cleanContent(bestMatch.seg.content) !== cleanContent(uSeg.content)) {
                        addPatchUI('replace', bestMatch.seg, uSeg, bestMatch.reason);
                    }
                } else {
                    addPatchUI('insert', null, uSeg, "No matching block found");
                }
            });

            if (proposedPatches.length === 0) {
                diffContainer.innerHTML = '<div style="padding:20px; text-align:center; color:#888;">No relevant changes detected.</div>';
                downloadBtn.disabled = true;
            } else {
                downloadBtn.disabled = false;
            }
        }

        // --- NEW: ROBUST STATE-MACHINE PARSER ---
        // Handles strings and comments correctly so brackets aren't miscounted.

        function robustParser(code) {
            const segments = [];
            const len = code.length;
            
            // State
            let i = 0;
            let braceDepth = 0;
            let inString = null; // null, ', ", `
            let inComment = null; // null, line, block
            
            // Block Tracking
            let blockStartIndex = -1;
            let potentialStart = 0; // Where the current "statement" might have begun
            
            // Helper to get line number from index
            const getLineNum = (index) => {
                return code.substring(0, index).split('\n').length;
            };

            while (i < len) {
                const char = code[i];
                const nextChar = code[i+1] || '';
                const prevChar = code[i-1] || '';

                // Handle Comments & Strings (Ignore content inside them)
                if (inComment) {
                    if (inComment === 'line' && char === '\n') inComment = null;
                    else if (inComment === 'block' && char === '*' && nextChar === '/') {
                        inComment = null;
                        i++; // skip /
                    }
                } else if (inString) {
                    if (char === '\\') {
                        i++; // skip escaped char
                    } else if (char === inString) {
                        inString = null;
                    }
                } else {
                    // Normal Code State
                    if (char === '/' && nextChar === '/') {
                        inComment = 'line';
                        i++;
                    } else if (char === '/' && nextChar === '*') {
                        inComment = 'block';
                        i++;
                    } else if (char === '"' || char === "'" || char === '`') {
                        inString = char;
                    } else if (char === '{') {
                        // Start of a block?
                        if (braceDepth === 0) {
                            blockStartIndex = potentialStart; 
                        }
                        braceDepth++;
                    } else if (char === '}') {
                        braceDepth--;
                        // End of a block?
                        if (braceDepth === 0 && blockStartIndex !== -1) {
                            const endIndex = i + 1; // include }
                            const fullContent = code.substring(blockStartIndex, endIndex);
                            
                            // Determine signature (everything before the first {)
                            const firstBraceRel = fullContent.indexOf('{');
                            const sigRaw = fullContent.substring(0, firstBraceRel);
                            
                            // Cleanup: Start index should skip leading empty newlines for cleaner replacement
                            // But we need to be careful. Let's trust the potentialStart which updates after previous block.
                            
                            segments.push({
                                name: extractName(sigRaw),
                                signature: sigRaw.trim(),
                                content: fullContent,
                                startIndex: blockStartIndex,
                                endIndex: endIndex,
                                startLine: getLineNum(blockStartIndex)
                            });
                            
                            blockStartIndex = -1;
                            potentialStart = i + 1;
                        } else if (braceDepth < 0) {
                            braceDepth = 0; // Reset if unbalanced
                        }
                    } else if (char === ';') {
                         // If we are at depth 0, a semicolon ends a loose statement
                         if (braceDepth === 0) {
                             // Optional: Capture loose lines? 
                             // For this logic, we primarily focus on blocks { }. 
                             // If you want loose lines, we'd capture them here.
                             // Reset start for next block
                             potentialStart = i + 1;
                         }
                    } else if (char !== '\n' && char !== ' ' && char !== '\t') {
                        // If we see actual code characters at depth 0, ensure potentialStart is set correctly
                        // (Usually handled by resetting at end of block)
                    }
                }
                i++;
            }

            // Post-processing: Filter out tiny blocks (like `if(x){}`) if needed, 
            // or ensure names are extracted correctly.
            
            // Refine Start Indices: `potentialStart` logic is basic. 
            // Better approach: When `blockStartIndex` is used, look backwards from the `{` 
            // to find the start of the line or the statement.
            // *Correction*: The parser above captures from `potentialStart`. 
            // If there was junk between blocks, it gets included in the next block's "signature".
            // Let's refine the segment trimming.
            
            return segments.map(seg => {
                // Trim leading whitespace from content but adjust startIndex accordingly
                const leadingSpace = seg.content.match(/^\s*/)[0];
                if (leadingSpace.length > 0) {
                    seg.startIndex += leadingSpace.length;
                    seg.content = seg.content.substring(leadingSpace.length);
                    // Re-extract signature
                    const firstBrace = seg.content.indexOf('{');
                    seg.signature = seg.content.substring(0, firstBrace).trim();
                    seg.name = extractName(seg.signature);
                }
                return seg;
            });
        }

        // --- UI GENERATION ---

        function addPatchUI(type, origSeg, newSeg, reason) {
            const id = Date.now() + Math.random();
            const patch = { id, type, original: origSeg, new: newSeg, status: 'pending' };
            proposedPatches.push(patch);

            const card = document.createElement('div');
            card.className = 'diff-card';
            card.id = `card-${id}`;

            let headerLeftHtml = '', bodyHtml = '', headerRightHtml = '';

            // --- Generate Insert Location Controls ---
            let locationControlsHtml = '';
            if (type === 'insert') {
                locationControlsHtml = `
                <div class="location-wrapper">
                    <select id="loc-${id}" class="location-select" onchange="toggleLineInput('${id}')">
                        <option value="bottom" selected>Insert at Bottom</option>
                        <option value="top">Insert at Top</option>
                        <option value="line">At Specific Line...</option>
                        <optgroup label="After Existing Block:">
                `;
                
                // Sort segments by line number for easier reading
                const sortedSegs = [...globalSourceSegments].sort((a,b) => a.startLine - b.startLine);
                sortedSegs.forEach(seg => {
                    if (seg.name) {
                        locationControlsHtml += `<option value="${seg.endIndex}">After ${seg.name}</option>`;
                    }
                });
                
                locationControlsHtml += `
                        </optgroup>
                    </select>
                    <input type="number" id="line-input-${id}" class="line-input hidden" placeholder="Line #" min="1">
                </div>
                `;
            }

            // --- Generate Body ---
            if (type === 'replace') {
                headerLeftHtml = `
                    <span class="diff-type type-replace">Replace Block</span>
                    <span class="match-reason">${reason}</span>
                    <span id="status-${id}" class="status-badge status-pending">Pending</span>
                `;
                
                bodyHtml = `
                    <div class="code-compare-container">
                        <div class="code-pane original">
                            <div class="line-numbers">${genLineNums(origSeg.content, origSeg.startLine)}</div>
                            <div class="code-content">${escapeHtml(origSeg.content)}</div>
                        </div>
                        <div class="code-pane replacement">
                            <div class="line-numbers" id="ln-${id}">${genLineNums(newSeg.content, newSeg.startLine || 1)}</div>
                            <div class="code-content" id="edit-${id}" contenteditable="true" spellcheck="false" oninput="handleCodeEdit('${id}')">${escapeHtml(newSeg.content)}</div>
                        </div>
                    </div>`;
                
                headerRightHtml = `
                    <div class="btn-row">
                        <button class="btn-success" onclick="setPatchStatus('${id}', 'approved')">Confirm Replace</button>
                        <button class="btn-secondary" onclick="setPatchStatus('${id}', 'rejected')">Ignore</button>
                    </div>
                `;

            } else {
                // INSERT
                headerLeftHtml = `
                    <span class="diff-type type-insert">Insert New Block</span>
                    <span class="match-reason">${reason}</span>
                    <span id="status-${id}" class="status-badge status-pending">Pending</span>
                `;

                bodyHtml = `
                    <div class="code-compare-container insert-mode">
                        <div class="code-pane insert-only">
                            <div class="line-numbers" id="ln-${id}">${genLineNums(newSeg.content, 1)}</div>
                            <div class="code-content" id="edit-${id}" contenteditable="true" spellcheck="false" oninput="handleCodeEdit('${id}')">${escapeHtml(newSeg.content)}</div>
                        </div>
                    </div>`;

                headerRightHtml = `
                    ${locationControlsHtml}
                    <div class="btn-row">
                        <button class="btn-primary" onclick="setPatchStatus('${id}', 'approved')">Confirm Insert</button>
                        <button class="btn-secondary" onclick="setPatchStatus('${id}', 'rejected')">Ignore</button>
                    </div>
                `;
            }

            card.innerHTML = `
                <div class="diff-header">
                    <div class="diff-info">
                        ${headerLeftHtml}
                    </div>
                    <div class="diff-actions">
                        ${headerRightHtml}
                    </div>
                </div>
                ${bodyHtml}
            `;
            diffContainer.appendChild(card);
        }

        // --- INTERACTIVE FUNCTIONS ---

        function genLineNums(text, start) {
            const count = text.split('\n').length;
            let html = '';
            for(let i=0; i<count; i++) html += (start + i) + '<br>';
            return html;
        }

        window.handleCodeEdit = function(id) {
            const editor = document.getElementById(`edit-${id}`);
            const lnContainer = document.getElementById(`ln-${id}`);
            lnContainer.innerHTML = genLineNums(editor.innerText, 1);
        };

        window.toggleLineInput = function(id) {
            const select = document.getElementById(`loc-${id}`);
            const input = document.getElementById(`line-input-${id}`);
            if (select.value === 'line') {
                input.classList.remove('hidden');
                input.focus();
            } else {
                input.classList.add('hidden');
            }
        };

        window.setPatchStatus = function(id, status) {
            const patch = proposedPatches.find(p => p.id == id);
            if (!patch) return;
            patch.status = status;
            
            const card = document.getElementById(`card-${id}`);
            const badge = document.getElementById(`status-${id}`);
            
            if (status === 'approved') {
                badge.className = 'status-badge status-approved';
                badge.innerText = patch.type === 'replace' ? 'Will Replace' : 'Will Insert';
                card.style.opacity = '1';
                card.style.borderColor = 'var(--success)';
            } else {
                badge.className = 'status-badge status-rejected';
                badge.innerText = 'Ignored';
                card.style.opacity = '0.5';
                card.style.borderColor = 'var(--border)';
            }
        };

        // --- APPLY LOGIC ---

        window.applyPatchesToSource = function() {
            const validPatches = proposedPatches.filter(p => p.status === 'approved');
            let operations = [];

            validPatches.forEach(p => {
                const editor = document.getElementById(`edit-${p.id}`);
                const finalCode = editor ? editor.innerText : p.new.content; 
                
                if (p.type === 'replace') {
                    operations.push({
                        index: p.original.startIndex,
                        content: finalCode,
                        removeEndIndex: p.original.endIndex,
                        type: 'replace'
                    });
                } else {
                    const locSelect = document.getElementById(`loc-${p.id}`);
                    const locValue = locSelect ? locSelect.value : 'bottom';
                    let insertIndex;

                    if (locValue === 'top') {
                        insertIndex = 0;
                    } else if (locValue === 'bottom') {
                        insertIndex = Infinity; 
                    } else if (locValue === 'line') {
                        const lineInput = document.getElementById(`line-input-${p.id}`);
                        let lineNum = parseInt(lineInput.value) || 0;
                        if(lineNum < 1) lineNum = 1;
                        insertIndex = getIndexFromLineNumber(rawOriginalSource, lineNum);
                    } else {
                        insertIndex = parseInt(locValue);
                    }

                    operations.push({
                        index: insertIndex,
                        content: "\n" + finalCode + "\n",
                        removeEndIndex: insertIndex, 
                        type: 'insert'
                    });
                }
            });

            // Sort operations descending by index to apply safely
            let bottomAppends = "";
            operations = operations.filter(op => {
                if (op.index === Infinity) {
                    bottomAppends += op.content;
                    return false;
                }
                return true;
            });
            operations.sort((a, b) => b.index - a.index);

            let tempCode = rawOriginalSource;
            operations.forEach(op => {
                const before = tempCode.substring(0, op.index);
                const after = tempCode.substring(op.removeEndIndex);
                tempCode = before + op.content + after;
            });

            if (bottomAppends) tempCode += "\n" + bottomAppends;
            sourceCode = tempCode;
        }

        // --- UTILS ---

        function getIndexFromLineNumber(text, lineNum) {
            if (lineNum <= 1) return 0;
            const lines = text.split('\n');
            if (lineNum > lines.length) return text.length;
            const precedingText = lines.slice(0, lineNum - 1).join('\n');
            return precedingText.length + 1; // +1 for newline
        }

        function extractName(str) {
            // Supports: function foo, class Foo, const foo =, let foo =, async function foo
            let m = str.match(/(?:function|class|const|let|var)\s+(?:[\w$]+\s+)?([a-zA-Z0-9_$]+)/);
            // Handle "async function foo" (name is group 1 matches the identifier)
            // Simplified regex:
            // 1. Look for 'function', 'class', 'const', 'let', 'var'
            // 2. Allow optional space/words (like 'async')
            // 3. Capture identifier
            
            // Standard declarations
            m = str.match(/(?:function|class)\s+\*?\s*([a-zA-Z0-9_$]+)/);
            if(m) return m[1];
            
            // Variable assignments (const x = ...)
            m = str.match(/(?:const|let|var)\s+([a-zA-Z0-9_$]+)\s*=/);
            if(m) return m[1];

            return null;
        }

        function cleanSignature(str) {
            // Remove all whitespace for comparison
            return str.replace(/\s+/g, '');
        }

        function cleanContent(str) { return str.replace(/\s+/g, '').trim(); }
        
        function escapeHtml(text) {
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }

        function downloadString(text, filename) {
            var blob = new Blob([text], { type: 'text/javascript' });
            var link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        function similarity(s1, s2) {
            let longer = s1, shorter = s2;
            if (s1.length < s2.length) { longer = s2; shorter = s1; }
            if (longer.length == 0) return 1.0;
            return (longer.length - editDistance(longer, shorter)) / parseFloat(longer.length);
        }

        function editDistance(s1, s2) {
            s1 = s1.toLowerCase(); s2 = s2.toLowerCase();
            const costs = new Array();
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i == 0) costs[j] = j;
                    else {
                        if (j > 0) {
                            let newValue = costs[j - 1];
                            if (s1.charAt(i - 1) != s2.charAt(j - 1))
                                newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                            costs[j - 1] = lastValue;
                            lastValue = newValue;
                        }
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }
    </script>
</body>
</html>
