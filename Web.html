

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Web Code Explorer - Upload and Analyze</title>
<style>
    /* Update/add responsive styles */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: #1e1e1e;
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Update container styles */
    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }

    /* Update sidebar styles */
    .sidebar {
      position: fixed;
      left: -100%;
      top: 0;
      width: min(320px, 90vw);
      height: 100vh;
      background: #2d2d2d;
      transition: left 0.3s ease;
      z-index: 1200;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0,0,0,0.2);
      padding: 20px;
      box-sizing: border-box;
    }

    .sidebar.open {
      left: 0;
    }

    /* Update playground and preview styles */
    #playgroundContainer,
    #codeDisplayContainer {
      width: 100%;
      height: 100%;
      padding: 20px;
      box-sizing: border-box;
      overflow: auto;
    }

    #preview-frame {
      width: 100%;
      height: calc(100vh - 200px) !important;
      min-height: 400px;
      border: 1px solid #444;
      border-radius: 4px;
      background: white;
      margin-bottom: 20px;
    }

    /* Update chat window styles */
    .chat-window {
      position: fixed;
      bottom: 90px;
      right: 20px;
      width: min(350px, 90vw);
      height: min(500px, 80vh);
      background: #2d2d2d;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: none;
      flex-direction: column;
      z-index: 1000;
    }

    /* Update help guide styles */
    .help-guide {
      width: min(800px, 90vw);
      max-height: 90vh;
      overflow-y: auto;
    }

    /* Update modal styles */
    #code-review-modal .code-review-content,
    #global-ai-modal .modal-content,
    #ai-edit-modal .ai-modal-content {
      width: min(90%, 600px);
      max-height: 90vh;
      overflow-y: auto;
    }

    /* Add responsive font sizes */
    @media (max-width: 768px) {
      body {
        font-size: 14px;
      }

      h1 { font-size: 1.8em; }
      h2 { font-size: 1.5em; }
      h3 { font-size: 1.2em; }

      .chat-bubble {
        width: 50px;
        height: 50px;
      }

      .chat-bubble svg {
        width: 25px;
        height: 25px;
      }

      .edit-buttons,
      .modal-buttons,
      .code-review-buttons {
        flex-wrap: wrap;
      }

      button {
        padding: 8px 16px;
        font-size: 0.9em;
      }

      .component-library {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      }
    }

    /* Add styles for landscape orientation */
    @media (orientation: landscape) and (max-height: 600px) {
      .sidebar {
        padding: 10px;
      }

      #preview-frame {
        height: calc(100vh - 100px) !important;
      }

      .chat-window {
        height: 70vh;
      }
    }

    /* Add flex styles for component sections */
    .component-category {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .component-library {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 10px;
    }

    /* Make forms more responsive */
    .edit-controls,
    .style-controls,
    .config-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    input[type="text"],
    input[type="password"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 8px;
    }

    /* Update draggable element styles */
    .draggable {
      touch-action: none;
      position: relative !important;
      max-width: 100%;
    }

    .resize-handle {
      min-width: 20px;
      min-height: 20px;
    }
    
    /* Base styles from previous version */
    .edit-buttons {
      display: flex;
      gap: 10px;
      margin: 10px 0;
    }

    .chat-bubble {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      background: #0078d4;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
    }
    .chat-bubble svg {
      width: 30px;
      height: 30px;
      fill: white;
    }
    .chat-window {
      position: fixed;
      bottom: 90px;
      right: 20px;
      width: min(350px, 90vw);
      height: min(500px, 80vh);
      background: #2d2d2d;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: none;
      flex-direction: column;
      z-index: 1000;
    }
    .chat-header {
      padding: 15px;
      background: #1e1e1e;
      border-radius: 8px 8px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .chat-header h3 {
      margin: 0;
      color: #fff;
    }
    .chat-close {
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
      padding: 5px;
    }
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
    }
    .message {
      margin-bottom: 15px;
      max-width: 80%;
    }
    .message.user {
      margin-left: auto;
      background: #0078d4;
      color: white;
      padding: 10px;
      border-radius: 15px 15px 0 15px;
    }
    .message.assistant {
      margin-right: auto;
      background: #3d3d3d;
      color: white;
      padding: 10px;
      border-radius: 15px 15px 15px 0;
    }
    .chat-input {
      padding: 15px;
      border-top: 1px solid #444;
      display: flex;
      gap: 10px;
    }
    .chat-input input {
      flex: 1;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
    }
    .chat-input button {
      padding: 8px 15px;
    }
    .loading-dots {
      display: inline-block;
    }
    .loading-dots:after {
      content: '.';
      animation: dots 1.5s steps(5, end) infinite;
    }
    @keyframes dots {
      0%, 20% {
        content: '.';
      }
      40% {
        content: '..';   
      }
      60% {
        content: '...';
      }
      80%, 100% {
        content: '';
      }
    }
    .chat-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 999;
    }
    .chat-overlay.open {
      display: block;
    }
    .download-button {
      margin-bottom: 15px;
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .download-button:hover {
      background: #218838;
    }
    /* AI Edit Modal Styles */
    #ai-edit-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.6);
    }
    #ai-edit-modal .ai-modal-content {
      background-color: #2d2d2d;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      width: min(90%, 500px);
      max-width: 500px;
      border-radius: 8px;
      color: #fff;
    }
    #ai-edit-modal .ai-modal-close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    #ai-edit-modal .ai-modal-close:hover,
    #ai-edit-modal .ai-modal-close:focus {
      color: #fff;
      text-decoration: none;
      cursor: pointer;
    }
    #ai-edit-modal textarea {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
      resize: vertical;
    }
    #ai-edit-modal .ai-modal-buttons {
      margin-top: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #ai-edit-modal .ai-modal-buttons button {
      padding: 10px 20px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    #ai-edit-modal .ai-modal-buttons button:hover {
      background: #005a9e;
    }
    #ai-edit-loader {
      margin-left: 10px;
    }
    /* Add new styles for the global edit feature */
    #global-ai-edit {
      position: fixed;
      bottom: 20px;
      left: 20px;
      padding: 15px 25px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #global-ai-edit:hover {
      background: #218838;
    }

    #global-ai-edit .loader {
      display: none;
      width: 20px;
      height: 20px;
      border: 2px solid #fff;
      border-top: 2px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    #global-ai-edit.processing {
      pointer-events: none;
      opacity: 0.8;
    }

    #global-ai-edit.processing .loader {
      display: inline-block;
    }

    #global-ai-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.6);
    }

    #global-ai-modal .modal-content {
      background-color: #2d2d2d;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      width: min(90%, 600px);
      max-width: 600px;
      border-radius: 8px;
      color: #fff;
    }

    #global-ai-modal textarea {
      width: 100%;
      min-height: 150px;
      padding: 15px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
      margin: 15px 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      resize: vertical;
    }

    #global-ai-modal .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .changes-summary {
      background: #1e1e1e;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
      font-family: monospace;
      white-space: pre-wrap;
      display: none;
    }

    .changes-summary.show {
      display: block;
    }
    
    /* Add styles for edit mode */
    .code-editor {
      display: none;
      margin: 10px 0;
    }
    .code-editor textarea {
      width: 100%;
      min-height: 200px;
      font-family: 'Consolas', monospace;
      background: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
      padding: 10px;
      border-radius: 4px;
    }
    .editing .code-content {
      display: none;
    }
    .editing .code-editor {
      display: block;
    }
  
  /* Add this to your existing CSS */
.iframe-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
    display: none;
}

.edit-mode-active .iframe-overlay {
    display: block;
}
    /* Originally a grid layout - now overridden below for full screen toggling */
    /* Give each view full viewport height */
    /* Same styles as before */
    .playground {
      background: #2d2d2d;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      height: auto;
      min-height: 100vh;
    }
    .code-display {
      background: #2d2d2d;
      padding: 20px;
      border-radius: 8px;
      overflow-y: auto;
    }
    .code-block {
      background: #1e1e1e;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 10px;
      font-family: 'Consolas', monospace;
    }
    .function-name {
      color: #569cd6;
    }
    .code-content {
      color: #ce9178;
    }
    .dependency-tree {
      margin-left: 20px;
      border-left: 1px solid #569cd6;
      padding-left: 10px;
    }
    .css-rules {
      color: #b5cea8;
      margin-top: 10px;
    }
    .event-handlers {
      color: #dcdcaa;
      margin-top: 10px;
    }
    .js-references {
      margin-top: 20px;
      padding: 10px;
      background: #1e1e1e;
      border-radius: 4px;
    }
    .js-references pre {
      margin: 10px 0;
      padding: 10px;
      background: #2d2d2d;
      border-radius: 4px;
      overflow-x: auto;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #005a9e;
    }
    .highlight {
      background: #264f78;
      transition: background 0.3s;
    }
    #upload-section {
      margin-bottom: 20px;
    }
    #previewConsole {
      height: 20vh; 
      background: #000;
      color: #0f0;
      font-family: monospace;
      font-size: 0.85em;
      padding: 10px;
      margin-top: 10px;
      overflow-y: auto;
      border: 1px solid #444;
      border-radius: 4px;
    }
    .console-entry {
      margin-bottom: 5px;
    }
    .console-entry.error {
      color: #ff5555;
    }
    .console-entry.warn {
      color: #ffbb33;
    }
    .console-entry.info {
      color: #55ddff;
    }
    .dropzone {
      border: 2px dashed #666;
      padding: 20px;
      text-align: center;
      margin: 10px 0;
      border-radius: 4px;
    }
    .dropzone.dragover {
      border-color: #0078d4;
      background: rgba(0, 120, 212, 0.1);
    }
    .search-section {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
    }
    #searchInput {
      flex: 1;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
    }
    #searchType {
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
    }
    .search-result {
      padding: 10px;
      margin: 5px 0;
      background: #2d2d2d;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .search-result:hover {
      background: #3d3d3d;
    }
    .result-type {
      color: #569cd6;
      font-size: 0.9em;
      margin-right: 10px;
    }
    .result-name {
      color: #ce9178;
    }
    .function-link {
      color: #4fc3f7;
      text-decoration: underline;
      cursor: pointer;
    }
    .function-link:hover {
      color: #81d4fa;
    }
    .navigation-controls {
      margin-bottom: 15px;
    }
    .nav-button {
      padding: 8px 16px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .nav-button:hover:not([disabled]) {
      background: #005a9e;
    }
    .nav-button[disabled] {
      background: #666;
      cursor: not-allowed;
      opacity: 0.6;
    }
    .edit-controls {
      margin: 10px 0;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .edit-prompt {
      flex: 1;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1e1e1e;
      color: #fff;
    }
    .loader {
      display: none;
      width: 24px;
      height: 24px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .loader.active {
      display: inline-block;
    }
    /* Add styles for edit mode */
    .code-editor {
      display: none;
      margin: 10px 0;
    }
    .code-editor textarea {
      width: 100%;
      min-height: 200px;
      font-family: 'Consolas', monospace;
      background: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
      padding: 10px;
      border-radius: 4px;
    }
    .editing .code-content {
      display: none;
    }
    .editing .code-editor {
      display: block;
    }
    /* Add styles for global ai edit modal close button */
    #global-ai-modal .modal-close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      margin-top: -10px;
    }
    #global-ai-modal .modal-close:hover,
    #global-ai-modal .modal-close:focus {
      color: #fff;
      text-decoration: none;
    }
    
    /* Add styles for file browser and zip upload */
    .file-browser {
      background: #2d2d2d;
      border-radius: 8px;
      margin-bottom: 20px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .file-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    
    .file-item {
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
    }
    
    .file-item:hover {
      background: #3d3d3d;
    }
    
    .file-item.active {
      background: #0078d4;
    }
    
    .file-icon {
      margin-right: 8px;
      width: 16px;
      height: 16px;
    }
    
    .file-tree {
      font-family: monospace;
    }
    
    .file-tree-folder {
      margin-left: 15px;
    }
    
    .zip-upload-message {
      text-align: center;
      padding: 10px;
      margin-top: 10px;
      color: #4fc3f7;
    }
    
    /* Add new styles for draggable/resizable elements */
    /* Add new styles for drag and resize functionality */
    .draggable {
      position: relative !important;
      user-select: none;
      touch-action: none;
    }

    .draggable:hover {
      outline: 2px dashed #0078d4;
    }

    .draggable.dragging {
      opacity: 0.8;
      z-index: 1000;
    }

    .resize-handle {
      position: absolute;
      width: 20px;
      height: 20px;
      background: #0078d4;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1001;
    }

    .draggable:hover .resize-handle {
      opacity: 0.8;
    }

    .resize-handle.top-left { top: -10px; left: -10px; cursor: nw-resize; }
    .resize-handle.top-right { top: -10px; right: -10px; cursor: ne-resize; }
    .resize-handle.bottom-left { bottom: -10px; left: -10px; cursor: sw-resize; }
    .resize-handle.bottom-right { bottom: -10px; right: -10px; cursor: se-resize; }

    /* Mobile-specific styles */
    @media (max-width: 768px) {
      .resize-handle {
        width: 30px;
        height: 30px;
        opacity: 0.8;
      }
      
      .resize-handle.top-left { top: -15px; left: -15px; }
      .resize-handle.top-right { top: -15px; right: -15px; }
      .resize-handle.bottom-left { bottom: -15px; left: -15px; }
      .resize-handle.bottom-right { bottom: -15px; right: -15px; }
    }
    
    .resize-control-panel {
      position: relative;
      background: #1e1e1e;
      margin: 10px 0;
      border-radius: 4px;
      display: none;
      padding: 15px;
    }

    .resize-control-panel.active {
      display: block;
    }

    .dimension-group {
      margin-bottom: 15px;
    }

    .style-controls {
      margin-top: 15px;
      border-top: 1px solid #444;
      padding-top: 15px;
    }

    .style-group {
      margin-bottom: 10px;
    }

    .style-group label {
      display: block;
      margin-bottom: 5px;
    }

    .style-group input, .style-group select {
      width: 100%;
      padding: 5px;
      background: #2d2d2d;
      border: 1px solid #444;
      color: #fff;
      border-radius: 4px;
    }

    .color-picker {
      width: 100%;
      height: 40px;
      padding: 5px;
      background: #2d2d2d;
      border: 1px solid #444;
      border-radius: 4px;
    }
    /* Add new styles for the sidebar */
    .sidebar {
      position: fixed;
      left: -100%;
      top: 0;
      width: min(320px, 90vw);
      height: 100vh;
      background: #2d2d2d;
      transition: left 0.3s ease;
      z-index: 1200;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0,0,0,0.2);
      padding: 20px;
      box-sizing: border-box;
    }

    .sidebar.open {
      left: 0;
    }

    .sidebar-toggle {
      position: fixed;
      left: 20px;
      top: 20px;
      z-index: 1201;
      background: #0078d4;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .sidebar-toggle svg {
      width: 20px;
      height: 20px;
      transition: transform 0.3s;
    }

    .sidebar.open + .sidebar-toggle svg {
      transform: rotate(180deg);
    }

    /* Update container padding to accommodate sidebar */
    .container {
      padding-left: 60px !important;
    }

    /* Section titles */
    .sidebar-section {
      margin-bottom: 20px;
    }

    .sidebar-section-title {
      font-size: 1.1em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .sidebar-section-content {
      display: none;
      transition: all 0.3s ease;
    }

    .sidebar-section.expanded .sidebar-section-content {
      display: block;
    }

    .collapse-icon {
      cursor: pointer;
      transition: transform 0.3s;
    }

    .sidebar-section.expanded .collapse-icon {
      transform: rotate(180deg);
    }

    /* Tool toggle styles */
    .tool-toggle {
      padding: 10px;
      background: #1e1e1e;
      border-radius: 4px;
      margin-bottom: 10px;
    }

    .tool-toggle label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .tool-toggle input[type="checkbox"] {
      margin: 0;
    }

    /* Dimension controls */
    .dimension-group {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 10px;
    }

    .dimension-group label {
      min-width: 50px;
    }

    .dimension-group input {
      width: 60px;
      padding: 5px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #2d2d2d;
      color: #fff;
    }

    .dimension-group select {
      padding: 5px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #2d2d2d;
      color: #fff;
    }

    /* Component Library Styles */
    .component-library {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 10px;
    }

    .component-category {
      width: 100%;
      margin-bottom: 15px;
    }

    .component-category-title {
      font-size: 0.9em;
      font-weight: bold;
      margin-bottom: 8px;
      padding-bottom: 5px;
      border-bottom: 1px solid #444;
    }

    .component-item {
      background: #3d3d3d;
      border-radius: 4px;
      padding: 8px;
      cursor: grab;
      transition: transform 0.2s, background 0.2s;
      text-align: center;
    }

    .component-item:hover {
      background: #0078d4;
      transform: translateY(-2px);
    }

    .component-preview {
      font-size: 20px;
      margin-bottom: 4px;
    }

    .component-name {
      font-size: 0.8em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .drop-indicator {
      position: absolute;
      border: 2px dashed #0078d4;
      background: rgba(0, 120, 212, 0.1);
      z-index: 1000;
      pointer-events: none;
      display: none;
    }

    .drop-indicator.active {
      display: block;
    }

    .component-library-toggle,
    .component-library-window {
      display: none;
    }

    .component-tabs {
      display: flex;
      border-bottom: 1px solid #444;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .component-tab {
      padding: 8px 15px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      font-size: 0.9em;
    }

    .component-tab.active {
      border-bottom: 2px solid #0078d4;
      color: #0078d4;
    }
    /* Edit mode controls */
    .edit-mode-controls {
      position: fixed;
      bottom: 20px;
      right: 100px;
      display: flex;
      gap: 10px;
      z-index: 1000;
    }

    .edit-mode-button {
      padding: 10px 15px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .edit-mode-button.active {
      background: #28a745;
    }

    .edit-mode-button.delete {
      background: #dc3545;
    }

    .element-delete-handle {
      position: absolute;
      top: -10px;
      right: -10px;
      width: 20px;
      height: 20px;
      background: #dc3545;
      border-radius: 50%;
      display: none;
      cursor: pointer;
      z-index: 1002;
    }

    .draggable:hover .element-delete-handle {
      display: block;
    }

    .edit-mode-active .draggable {
      outline: 2px dashed #0078d4;
    }

    .edit-mode-active .draggable:hover .resize-handle,
    .edit-mode-active .draggable:hover .element-delete-handle {
      opacity: 1;
    }
    .color-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .transparency-control {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .transparency-control label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .transparency-control input[type="range"] {
      flex: 1;
      min-width: 100px;
    }

    #opacityValue {
      min-width: 48px;
    }
    
    /* New styles for element type controls */
    .element-type {
      padding: 5px 10px;
      background: #444;
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 0.9em;
    }

    .element-type-controls {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #444;
    }

    .image-preview {
      max-width: 100%;
      height: 100px;
      background: #333;
      margin-top: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .image-preview img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    /* Add new styles for code review modal */
    #code-review-modal {
      display: none;
      position: fixed;
      z-index: 2100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      overflow: auto;
    }

    .code-review-content {
      background-color: #2d2d2d;
      margin: 2% auto;
      padding: 20px;
      width: min(90%, 600px);
      height: 85vh;
      border-radius: 8px;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    #code-editor {
      width: 100%;
      height: calc(100% - 60px);
      border-radius: 4px;
      margin-bottom: 15px;
      border: 1px solid #444;
    }

    .code-review-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .code-review-close {
      position: absolute;
      right: 20px;
      top: 10px;
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .code-review-close:hover {
      color: #fff;
    }
    #slashRemovalReport {
      font-family: monospace;
      font-size: 0.9em;
      color: #4fc3f7;
      white-space: pre-wrap;
      word-break: break-word;
    }
  
    .code-review-buttons button {
      margin-right: 10px;
      padding: 8px 16px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
  
    .code-review-buttons button:hover {
      background: #005a9e;
    }
    /* Add new styles for the help guide */
    .help-guide {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(800px, 90vw);
      max-height: 90vh;
      background: #2d2d2d;
      border-radius: 8px;
      padding: 20px;
      z-index: 2200;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      overflow-y: auto;
    }

    .help-guide.open {
      display: block;
    }

    .help-guide h2 {
      margin-top: 0;
      padding-bottom: 10px;
      border-bottom: 1px solid #444;
    }

    .help-guide-section {
      margin: 20px 0;
    }

    .help-guide-section h3 {
      color: #0078d4;
      margin-bottom: 10px;
    }

    .help-guide-section ul {
      list-style-type: none;
      padding-left: 0;
    }

    .help-guide-section li {
      margin: 10px 0;
      padding-left: 20px;
      position: relative;
    }

    .help-guide-section li:before {
      content: "‚Ä¢";
      color: #0078d4;
      position: absolute;
      left: 0;
      top: 0;
    }

    .help-guide .close-button {
      position: absolute;
      right: 20px;
      top: 20px;
      background: none;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
    }

    .help-button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      background: #0078d4;
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 20px;
      cursor: pointer;
      margin: 10px auto;
      transition: background 0.3s;
    }

    .help-button:hover {
      background: #005a9e;
    }

    .help-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 2100;
    }

    .help-overlay.open {
      display: block;
    }
    /* Add styles for create new section */
    .create-new-section {
      padding: 15px;
      margin: 15px 0;
      background: #2d2d2d;
      border-radius: 8px;
      display: none; /* Hidden by default, shown when no project */
    }

    .create-new-section.show {
      display: block;
    }

    .create-new-section h3 {
      margin: 0 0 10px 0;
      color: #fff;
    }

    .create-new-section p {
      color: #aaa;
      font-size: 0.9em;
      margin-bottom: 15px;
    }

    .create-new-section textarea {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      margin-bottom: 10px;
      background: #1e1e1e;
      border: 1px solid #444;
      border-radius: 4px;
      color: #fff;
      font-family: inherit;
      resize: vertical;
    }

    .create-new-section button {
      width: 100%;
      padding: 10px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .create-new-section button:hover {
      background: #218838;
    }

    .create-new-section button.generating {
      background: #666;
      cursor: not-allowed;
    }

    .create-new-section .loader {
      display: none;
      width: 20px;
      height: 20px;
      border: 2px solid #fff;
      border-top: 2px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .create-new-section button.generating .loader {
      display: inline-block;
    }
    .api-config {
      padding: 15px;
      background: #1e1e1e;
      border-radius: 4px;
      margin-top: 10px;
    }

    .config-group {
      margin-bottom: 15px;
    }

    .config-group label {
      display: block;
      margin-bottom: 5px;
      color: #aaa;
      font-size: 0.9em;
    }

    .config-group input {
      width: 100%;
      padding: 8px;
      background: #2d2d2d;
      border: 1px solid #444;
      color: #fff;
      font-family: inherit;
    }

    .save-config-button {
      width: 100%;
      padding: 10px;
      background: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }

    .save-config-button:hover {
      background: #005a9e;
    }

    .api-status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
      font-size: 0.9em;
      display: none;
    }

    .api-status.success {
      display: block;
      background: rgba(40, 167, 69, 0.2);
      color: #28a745;
    }

    .api-status.error {
      display: block;
      background: rgba(220, 53, 69, 0.2);
      color: #dc3545;
    }
    /* Add these styles to your existing CSS */
    .toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2000;
      pointer-events: none;
    }
    
    .toast {
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 20px;
      margin: 10px;
      text-align: center;
      animation: toast-in 0.3s ease-out;
    }
    
    .toast.fade-out {
      opacity: 0;
      transition: opacity 0.3s ease-out;
    }
    
    @keyframes toast-in {
      from {
        transform: translateY(100%);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    /* Update component items to be more tap-friendly on mobile */
    @media (max-width: 768px) {
      .component-item {
        padding: 15px;
        min-height: 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
      
      .component-item:active {
        transform: scale(0.95);
        background: #005a9e;
      }
      
      .component-preview {
        font-size: 24px;
      }
      
      .component-name {
        font-size: 0.9em;
        margin-top: 5px;
      }
    }

    /* === NEW STYLES FOR AUTH & PROJECT BROWSER === */
    /* User Controls */
    #user-controls {
      padding: 10px 20px;
      background: #1e1e1e;
      border-bottom: 1px solid #444;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    #user-info {
      font-weight: bold;
      margin-right: auto;
    }

    /* General Modal Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      z-index: 3000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.7);
    }
    .modal-overlay .modal-content {
      background-color: #2d2d2d;
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: min(90%, 500px);
      border-radius: 8px;
      color: #fff;
      position: relative;
    }
    .modal-overlay .modal-close {
      color: #aaa;
      position: absolute;
      right: 15px;
      top: 10px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .error-message { color: #dc3545; }
    .success-message { color: #28a745; }

    #auth-form-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    /* Project List Styles */
    #project-list-container {
      max-height: 40vh;
      overflow-y: auto;
      margin-bottom: 20px;
      border: 1px solid #444;
      padding: 10px;
      border-radius: 4px;
    }
    .project-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: #3d3d3d;
      border-radius: 4px;
      margin-bottom: 8px;
    }
    .project-item-name {
      font-weight: bold;
    }
    .project-item-actions button {
      margin-left: 5px;
      padding: 5px 10px;
      font-size: 0.8em;
    }
    .project-item-actions button.delete {
        background-color: #dc3545;
    }
    .project-item-actions button.delete:hover {
        background-color: #c82333;
    }
</style>
</head>
<body>
<div class="sidebar">
  <div id="user-controls">
    <span id="user-info" style="display: none;"></span>
    <button id="auth-button">Login</button>
    <button id="logout-button" style="display: none;">Logout</button>
    <button id="projects-button" style="display: none;">My Projects</button>
    <button id="save-project-button" style="display: none;">Save Project</button>
  </div>
<div class="create-new-section">
  <h3 id="websiteActionTitle">Create New Website</h3>
  <p id="websiteActionDescription">Describe the website you want to create and AI will generate it for you.</p>
  <textarea id="websitePrompt" placeholder="Example: Create a modern portfolio website with a hero section, about me, skills, and contact form. Use a dark theme with blue accents..."></textarea>
  <button id="generateButton">
    <span id="actionButtonText">Generate Website</span>
    <div class="loader"></div>
  </button>
</div>
  <div class="sidebar-section">
    <div class="sidebar-section-title">
      API Configuration
      <span class="collapse-icon">‚ñº</span>
    </div>  
    <div class="sidebar-section-content">
      <div class="api-config">
        <div class="config-group">
          <label for="apiKey">Gemini API Key:</label>
          <input type="password" id="apiKey" placeholder="Enter your Gemini API key">
        </div>
        <button id="save-config-button" class="save-config-button">Save Configuration</button>
        <div class="api-status"></div>
      </div>
    </div>
  </div>
  <button class="help-button" id="help-button">?</button>
  <div class="sidebar-section expanded">
    <div class="sidebar-section-title">
      Upload Project
      <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="sidebar-section-content">
      <div id="upload-section">
        <div class="dropzone" id="dropzone">
          Drag &amp; drop HTML file or ZIP archive here or
          <input type="file" id="fileInput" accept=".html,.htm,.zip" style="display: none;">
          <button id="browse-files-button">Browse</button>
        </div>
        <div class="zip-upload-message" id="zipUploadMessage"></div>
      </div>
    </div>
  </div>

  <div class="sidebar-section expanded">
    <div class="sidebar-section-title">
      Project Files
      <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="sidebar-section-content">
          <button id="editCodeButton" class="download-button">Edit Code</button>
      <div class="file-browser" id="fileBrowser">
        <div class="file-tree" id="fileTree"></div>
      </div>
    </div>
  </div>

  <div class="sidebar-section expanded">
    <div class="sidebar-section-title">
      Element Tools
      <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="sidebar-section-content">
      <div class="tool-toggle">
        <label>
          <input type="checkbox" id="toggleMoveElements"> Enable Element Movement
        </label>
      </div>
      <div class="resize-control-panel">
        <div class="dimension-group">
          <label>Width:</label>
          <input type="number" id="elementWidth" min="0" step="1">
          <select id="widthUnit">
            <option value="px">px</option>
            <option value="%">%</option>
            <option value="vw">vw</option>
          </select>
        </div>
        <div class="dimension-group">
          <label>Height:</label>
          <input type="number" id="elementHeight" min="0" step="1">
          <select id="heightUnit">
            <option value="px">px</option>
            <option value="%">%</option>
            <option value="vh">vh</option>
          </select>
        </div>
        <button id="apply-dimensions-button">Apply Dimensions</button>
        
        <div class="style-controls">
          <div class="style-group">
            <label>Background Color:</label>
            <div class="color-controls">
              <input type="color" id="elementBgColor" class="color-picker">
              <div class="transparency-control">
                <label>
                  <input type="checkbox" id="transparentBg"> Transparent
                </label>
                <input type="range" id="bgOpacity" min="0" max="100" value="100" disabled>
                <span id="opacityValue">100%</span>
              </div>
            </div>
          </div>
          <div class="style-group">
            <label>Text Color:</label>
            <input type="color" id="elementTextColor" class="color-picker">
          </div>
          <div class="style-group">
            <label>Font Size:</label>
            <input type="number" id="elementFontSize" min="0" step="1">
            <select id="fontSizeUnit">
              <option value="px">px</option>
              <option value="em">em</option>
              <option value="rem">rem</option>
            </select>
          </div>
          <div class="style-group">
            <label>Font Family:</label>
            <select id="elementFontFamily">
              <option value="inherit">Default</option>
              <option value="Arial, sans-serif">Arial</option>
              <option value="'Times New Roman', serif">Times New Roman</option>
              <option value="'Courier New', monospace">Courier New</option>
              <option value="Georgia, serif">Georgia</option>
              <option value="Verdana, sans-serif">Verdana</option>
            </select>
          </div>
          <div class="style-group">
            <label>Text Content:</label>
            <input type="text" id="elementTextContent" placeholder="Enter text...">
          </div>
          <div class="style-group">
            <label>Element Type:</label>
            <div id="elementTypeIndicator" class="element-type"></div>
          </div>
          <div id="imageControls" class="element-type-controls" style="display:none;">
            <div class="style-group">
              <label>Replace Image:</label>
              <input type="file" id="imageUpload" accept="image/*">
              <div class="image-preview"></div>
            </div>
            <div class="style-group">
              <label>Alt Text:</label>
              <input type="text" id="imageAlt" placeholder="Describe the image...">
            </div>
          </div>

          <div id="linkControls" class="element-type-controls" style="display:none;">
            <div class="style-group">
              <label>Link URL:</label>
              <input type="url" id="linkUrl" placeholder="https://...">
            </div>
            <div class="style-group">
              <label>Open in new tab:</label>
              <input type="checkbox" id="linkNewTab">
            </div>
          </div>

          <div id="buttonControls" class="element-type-controls" style="display:none;">
            <div class="style-group">
              <label>Button Type:</label>
              <select id="buttonType">
                <option value="button">Button</option>
                <option value="submit">Submit</option>
                <option value="reset">Reset</option>
              </select>
            </div>
          </div>

          <div id="inputControls" class="element-type-controls" style="display:none;">
            <div class="style-group">
              <label>Input Type:</label>
              <select id="inputType">
                <option value="text">Text</option>
                <option value="password">Password</option>
                <option value="email">Email</option>
                <option value="number">Number</option>
                <option value="tel">Phone</option>
                <option value="date">Date</option>
              </select>
            </div>
            <div class="style-group">
              <label>Placeholder:</label>
              <input type="text" id="inputPlaceholder" placeholder="Enter placeholder text...">
            </div>
          </div>
          <button id="apply-styles-button">Apply Styles</button>
        </div>
      </div>
    </div>
  </div>

  <div class="sidebar-section expanded">
    <div class="sidebar-section-title">
      Component Library
      <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="sidebar-section-content">
      <div class="component-tabs">
        <div class="component-tab active" data-tab="basic">Basic</div>
        <div class="component-tab" data-tab="forms">Forms</div>
        <div class="component-tab" data-tab="media">Media</div>
        <div class="component-tab" data-tab="layout">Layout</div>
      </div>
      <div class="component-library-content">
        <div class="component-category" data-category="basic">
          <div class="component-category-title">Basic Elements</div>
          <div class="component-library">
            <div class="component-item" draggable="true" data-type="heading" data-content="<h1>Heading</h1>">
              <div class="component-preview">H1</div>
              <div class="component-name">Heading</div>
            </div>
            <div class="component-item" draggable="true" data-type="paragraph" data-content="<p>Paragraph text</p>">
              <div class="component-preview">P</div>
              <div class="component-name">Paragraph</div>
            </div>
            <div class="component-item" draggable="true" data-type="button" data-content="<button>Button</button>">
              <div class="component-preview">Btn</div>
              <div class="component-name">Button</div>
            </div>
            <div class="component-item" draggable="true" data-type="link" data-content="<a href='#'>Link</a>">
              <div class="component-preview">A</div>
              <div class="component-name">Link</div>
            </div>
            <div class="component-item" draggable="true" data-type="list" data-content="<ul><li>Item 1</li><li>Item 2</li></ul>">
              <div class="component-preview">UL</div>
              <div class="component-name">List</div>
            </div>
            <div class="component-item" draggable="true" data-type="divider" data-content="<hr>">
              <div class="component-preview">HR</div>
              <div class="component-name">Divider</div>
            </div>
          </div>
        </div>

        <div class="component-category" data-category="forms" style="display:none;">
          <div class="component-category-title">Form Elements</div>
          <div class="component-library">
            <div class="component-item" draggable="true" data-type="form" data-content="<form><input type='text' placeholder='Name'><button type='submit'>Submit</button></form>">
              <div class="component-preview">Form</div>
              <div class="component-name">Form</div>
            </div>
            <div class="component-item" draggable="true" data-type="input" data-content="<input type='text' placeholder='Text input'>">
              <div class="component-preview">Input</div>
              <div class="component-name">Text Input</div>
            </div>
            <div class="component-item" draggable="true" data-type="textarea" data-content="<textarea placeholder='Textarea'></textarea>">
              <div class="component-preview">Textarea</div>
              <div class="component-name">Textarea</div>
            </div>
            <div class="component-item" draggable="true" data-type="select" data-content="<select><option>Option 1</option><option>Option 2</option></select>">
              <div class="component-preview">Select</div>
              <div class="component-name">Dropdown</div>
            </div>
            <div class="component-item" draggable="true" data-type="checkbox" data-content="<label><input type='checkbox'> Checkbox</label>">
              <div class="component-preview">‚úì</div>
              <div class="component-name">Checkbox</div>
            </div>
            <div class="component-item" draggable="true" data-type="radio" data-content="<label><input type='radio' name='group'> Option</label>">
              <div class="component-preview">‚óã</div>
              <div class="component-name">Radio</div>
            </div>
          </div>
        </div>

        <div class="component-category" data-category="media" style="display:none;">
          <div class="component-category-title">Media Elements</div>
          <div class="component-library">
            <div class="component-item" draggable="true" data-type="image" data-content="<img src='https://via.placeholder.com/150' alt='Image'>">
              <div class="component-preview">üñºÔ∏è</div>
              <div class="component-name">Image</div>
            </div>
            <div class="component-item" draggable="true" data-type="video" data-content="<video controls width='250'><source src='' type='video/mp4'></video>">
              <div class="component-preview">üé¨</div>
              <div class="component-name">Video</div>
            </div>
            <div class="component-item" draggable="true" data-type="audio" data-content="<audio controls><source src='' type='audio/mpeg'></audio>">
              <div class="component-preview">üéµ</div>
              <div class="component-name">Audio</div>
            </div>
            <div class="component-item" draggable="true" data-type="iframe" data-content="<iframe src='' width='300' height='150'></iframe>">
              <div class="component-preview">üì∫</div>
              <div class="component-name">Embed</div>
            </div>
          </div>
        </div>

        <div class="component-category" data-category="layout" style="display:none;">
          <div class="component-category-title">Layout Elements</div>
          <div class="component-library">
            <div class="component-item" draggable="true" data-type="container" data-content="<div style='padding: 20px; border: 1px dashed #ccc;'></div>">
              <div class="component-preview">üì¶</div>
              <div class="component-name">Container</div>
            </div>
            <div class="component-item" draggable="true" data-type="row" data-content="<div style='display: flex; gap: 10px; padding: 10px;'></div>">
              <div class="component-preview">‚ÜîÔ∏è</div>
              <div class="component-name">Row</div>
            </div>
            <div class="component-item" draggable="true" data-type="column" data-content="<div style='padding: 10px;'></div>">
              <div class="component-preview">‚ÜïÔ∏è</div>
              <div class="component-name">Column</div>
            </div>
            <div class="component-item" draggable="true" data-type="card" data-content="<div style='border: 1px solid #ccc; border-radius: 8px; padding: 15px;'></div>">
              <div class="component-preview">üÉè</div>
              <div class="component-name">Card</div>
            </div>
            <div class="component-item" draggable="true" data-type="hero" data-content="<div style='background: #f0f0f0; padding: 40px; text-align: center;'><h1>Hero Section</h1><p>Welcome message</p></div>">
              <div class="component-preview">üåü</div>
              <div class="component-name">Hero</div>
            </div>
            <div class="component-item" draggable="true" data-type="footer" data-content="<footer style='background: #333; color: white; padding: 20px; text-align: center;'>Footer content</footer>">
              <div class="component-preview">‚¨áÔ∏è</div>
              <div class="component-name">Footer</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    <div class="code-display hidden" id="codeDisplayContainer">
    <h2>Code Explorer</h2>
    <button id="download-code-button" class="download-button">Download Updated Code</button>
    <div class="search-section">
      <input type="text" id="searchInput" placeholder="Search for elements or functions...">
      <select id="searchType">
        <option value="all">All</option>
        <option value="elements">Elements</option>
        <option value="functions">Functions</option>
      </select>
      <button id="search-button">Search</button>
    </div>
    <div id="searchResults"></div>
    <div id="codeOutput"></div>
  </div>

  
</div>

<button class="sidebar-toggle">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M9 18l6-6-6-6"/>
  </svg>
</button>

<!-- Container for playground and code display -->
<div class="container">
  <!-- Playground container: visible by default -->
  <div class="playground" id="playgroundContainer">
    <div style="position: relative;">
      <iframe id="preview-frame" sandbox="allow-same-origin allow-scripts"></iframe>
      <div class="iframe-overlay"></div>
    </div>  
    <!-- New Console Log Interface -->
    <div id="previewConsole"></div>
  </div>
  <!-- Code display container: hidden by default -->
</div>
  
<!-- Toggle view button -->
<button id="toggleViewButton" class="toggle-button">Switch to Code Explorer</button>

<!-- Edit mode controls -->
<div class="edit-mode-controls">
  <button id="toggleEditMode" class="edit-mode-button">Edit Mode</button>
  <button id="deleteElementButton" class="edit-mode-button delete" disabled>Delete Element</button>
</div>
  
<div class="chat-bubble">
  <svg viewBox="0 0 24 24">
    <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
  </svg>
</div>
  
<div class="chat-window">
  <div class="chat-header">
    <h3>Website Assistant</h3>
    <button class="chat-close">&#xd7;</button>
  </div>
  <div class="chat-messages"></div>
  <div class="chat-input">
    <input type="text" placeholder="Ask a question about the website...">
    <button>Send</button>
  </div>
</div>
  
<!-- AI Edit Modal -->
<div id="ai-edit-modal">
  <div class="ai-modal-content">
    <span class="ai-modal-close">&times;</span>
    <h2>Edit Function with AI</h2>
    <p>Enter instructions for editing the function: <span id="ai-function-name"></span></p>
    <textarea id="ai-edit-instructions" placeholder="Type your instructions here..."></textarea>
    <div class="ai-modal-buttons">
      <button id="ai-edit-submit-button">Submit</button>
      <button id="ai-edit-cancel-button">Cancel</button>
      <div class="loader" id="ai-edit-loader"></div>
    </div>
  </div>
</div>
  
<!-- Add new button for global AI edit -->
<button id="global-ai-edit">
  <span>AI Edit Website</span>
  <div class="loader"></div>
</button>

<!-- Add new modal for global AI edit -->
<div id="global-ai-modal">
  <div class="modal-content">
    <span class="modal-close" id="global-ai-modal-close">&times;</span>
    <h2>Edit Website with AI</h2>
    <p>Describe what changes you want to make to the website:</p>
    <textarea id="global-ai-instructions" placeholder="Example: Add a dark mode toggle button in the top right corner, or Make the search input wider and add a clear button..."></textarea>
    <div class="changes-summary"></div>
    <div class="modal-buttons">
      <button id="global-ai-cancel-button">Cancel</button>
      <button id="global-ai-apply-button">Apply Changes</button>
    </div>
  </div>
</div>

<!-- Drop indicator for component placement -->
<div class="drop-indicator"></div>

<!-- Add code review modal -->
<div id="code-review-modal">
  <div class="code-review-content">
    <span class="code-review-close">&times;</span>
    <h2>Review and Edit Code</h2>
    <div class="code-review-buttons" style="margin-bottom: 10px;">
      <button id="save-code-changes-button">Save Changes</button>

      <button id="remove-slashes-button">Remove Leading Slashes</button>
      <div id="slashRemovalReport" style="display: none; margin: 10px 0; padding: 10px; background: #333; border-radius: 4px; max-height: 100px; overflow-y: auto;"></div>
    </div>
    <div id="code-editor"></div>
    <div class="code-review-buttons">
      <button id="code-review-cancel-button">Cancel</button>
      <button id="confirm-download-button">Confirm & Download</button>
    </div>
  </div>
</div>

<!-- Add help guide modal -->
<div class="help-overlay"></div>
<div class="help-guide">
  <button class="close-button" id="help-guide-close-button">&times;</button>
  <h2>Website Editor User Guide</h2>
  
  <div class="help-guide-section">
    <h3>Getting Started</h3>
    <ul>
      <li>Upload your website by dragging an HTML file or ZIP archive into the upload area</li>
      <li>For multi-file projects, use a ZIP file containing your HTML, CSS, JS, and other assets</li>
      <li>The preview will automatically load your website in the main view</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Basic Navigation</h3>
    <ul>
      <li>Use the "Switch to Code Explorer" button to toggle between preview and code view</li>
      <li>The sidebar contains all your editing tools and can be toggled with the arrow button</li>
      <li>For ZIP projects, use the file browser in the sidebar to navigate between files</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Adding Components</h3>
    <ul>
      <li>First enable "Edit Mode" using the button at the bottom of the screen</li>
      <li>With Edit Mode enabled, find components in the Component Library section of the sidebar</li>
      <li>Drag and drop components directly onto your page</li>
      <li>Use the tabs to switch between different component categories</li>
      <li>Components will automatically become draggable and resizable</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Editing Elements</h3>
    <ul>
      <li>Click "Edit Mode" to enable element editing</li>
      <li>Click any element to select it for editing</li>
      <li>Use the Element Tools in the sidebar to modify properties:</li>
      <li>- Adjust dimensions and positioning</li>
      <li>- Change colors and transparency</li>
      <li>- Modify text content and styling</li>
      <li>- Edit element-specific attributes (links, images, etc.)</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Moving & Resizing</h3>
    <ul>
      <li>Enable "Element Movement" in the sidebar to drag elements (only works when Edit Mode is OFF)</li>
      <li>In Edit Mode, use the corner handles to resize elements</li>
      <li>Use the delete handle (√ó) to remove elements</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>AI Features</h3>
    <ul>
      <li>Use the chat bubble for general website assistance</li>
      <li>Click "AI Edit Website" for making broader changes</li>
      <li>Describe your desired changes in natural language</li>
      <li>Review and approve AI-suggested modifications</li>
    </ul>
  </div>

  <div class="help-guide-section">
    <h3>Saving Your Work</h3>
    <ul>
      <li>Click "Switch to Code Explorer" then "Download Updated Code"</li>
      <li>Review your code in the editor before downloading</li>
      <li>Use the "Remove Leading Slashes" tool to fix file paths if needed</li>
      <li>Click "Confirm & Download" to save your changes</li>
      <li>For ZIP projects, all files will be included in the download</li>
    </ul>
  </div>
</div>


<!-- NEW: AUTH & PROJECT BROWSER MODALS -->
<div id="auth-modal" class="modal-overlay">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <h2>Login or Signup</h2>
    <div id="auth-form-container">
      <input type="text" id="auth-username" placeholder="Username">
      <input type="password" id="auth-password" placeholder="Password">
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button id="login-submit">Login</button>
        <button id="signup-submit">Signup</button>
      </div>
      <p id="auth-message" class="error-message"></p>
    </div>
  </div>
</div>

<div id="project-browser-modal" class="modal-overlay">
  <div class="modal-content">
     <span class="modal-close">&times;</span>
     <h2>My Projects</h2>
     <div id="project-list-container">
        <!-- Projects will be listed here -->
        <p>Loading projects...</p>
     </div>
     <button id="create-new-project-button">Start New Local Project</button>
     <p id="project-message"></p>
  </div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.0/ace.js"></script>
<script type="module">
// CORRECTED: Import from the correct file name
import * as api from './api (7).js';

// --- STATE MANAGEMENT ---
let currentUser = null;
let currentProjectId = null;
let currentProjectName = 'Untitled Project';

  if (localStorage.getItem('justSaved') === 'true') {
  localStorage.removeItem('justSaved'); // clean up flag
  // Do not run saveProjectToStorage again
} else {
  // Safe to call saveProjectToStorage or other startup logic here
}

const openDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('WebCodeExplorerDB', 1);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('projects')) {
        db.createObjectStore('projects', { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains('files')) {
        const store = db.createObjectStore('files', { keyPath: 'path' });
        store.createIndex('projectId', 'projectId', { unique: false });
      }
    };
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

  
  // Global registries and history
  const functionHistory = [];
  let currentHistoryIndex = -1;
  const functionRegistry = {};
  let styleRegistry = {};
  let eventRegistry = {};
  let currentEditingFunction = null;
  const dropzone = document.getElementById('dropzone');
  const fileInput = document.getElementById('fileInput');
  const previewFrame = document.getElementById('preview-frame');
  let currentWebsiteCode = '';
  const chatBubble = document.querySelector('.chat-bubble');
  const chatWindow = document.querySelector('.chat-window');
  const chatClose = document.querySelector('.chat-close');
  const chatMessages = document.querySelector('.chat-messages');
  const chatInput = document.querySelector('.chat-input input');
  const chatSend = document.querySelector('.chat-input button');
  document.body.insertAdjacentHTML('beforeend', '<div class="chat-overlay"></div>');
  const chatOverlay = document.querySelector('.chat-overlay');
  
  let conversationHistory = [];
  let moveElementsEnabled = false;
  let selectedElement = null;
  let projectFiles = {};
  let isZipProject = false;
  let currentFilePath = '';
  let draggedComponent = null;
  let dropIndicator = document.querySelector('.drop-indicator');
  let editModeEnabled = false;
  let elementToDelete = null;

  const elementPositions = new WeakMap();

  const ProjectStorage = {
  async saveProject() {
    const projectData = {
      isZipProject: isZipProject,
      currentFilePath: currentFilePath,
      currentWebsiteCode: currentWebsiteCode,
      projectFiles: isZipProject ? this.processFilesForStorage(projectFiles) : null,
      lastUpdated: new Date().toISOString()
    };

    try {
      localStorage.setItem('webCodeExplorerProject', JSON.stringify(projectData));
    } catch (e) {
      console.error('Error saving project:', e);
      if (e.name === 'QuotaExceededError') {
        alert('Warning: Project structure saved, but you may need to re-add large files after refresh.');
      }
    }
  },

  processFilesForStorage(files) {
    const result = {};
    for (const [path, file] of Object.entries(files)) {
      // Only store metadata for binary files, not the content
      if (file.type === 'image' || file.type === 'binary') {
        result[path] = {
          type: file.type,
          mimeType: file.mimeType || getMimeType(path),
          size: file.blob?.size || 0,
          isBinary: true
        };
      } else {
        // Store full content for text files
        result[path] = file;
      }
    }
    return result;
  },

  async loadProject() {
    const savedData = localStorage.getItem('webCodeExplorerProject');
    if (!savedData) return false;

    try {
      const projectData = JSON.parse(savedData);
      
      isZipProject = projectData.isZipProject;
      currentFilePath = projectData.currentFilePath;
      currentWebsiteCode = projectData.currentWebsiteCode;
      
      if (isZipProject && projectData.projectFiles) {
        projectFiles = {};
        
        // Restore file references (actual binary files will need to be re-added)
        for (const [path, fileData] of Object.entries(projectData.projectFiles)) {
          if (fileData.isBinary) {
            projectFiles[path] = {
              type: fileData.type,
              mimeType: fileData.mimeType,
              needsReload: true // Flag that this file needs to be re-added
            };
          } else {
            projectFiles[path] = fileData;
          }
        }
        
        renderFileTree();
        if (currentFilePath) {
          await this.loadCurrentFileWithFallback();
        }
      } else if (currentWebsiteCode) {
        await processHTMLContent(currentWebsiteCode);
      }
      
      return true;
    } catch (e) {
      console.error('Error loading project:', e);
      return false;
    }
  },

  async loadCurrentFileWithFallback() {
    try {
      await loadProjectFile(currentFilePath);
    } catch (e) {
      console.warn('Failed to load main file, trying any HTML file');
      const htmlFiles = Object.keys(projectFiles).filter(path => 
        path.endsWith('.html') || path.endsWith('.htm'));
      if (htmlFiles.length > 0) {
        currentFilePath = htmlFiles[0];
        await loadProjectFile(currentFilePath);
      }
    }
  }
};
  
  // Component Library Toggle
  const componentTabs = document.querySelectorAll('.component-tab');
  const componentCategories = document.querySelectorAll('.component-category');

  // Edit mode controls
  const toggleEditModeButton = document.getElementById('toggleEditMode');
  const deleteElementButton = document.getElementById('deleteElementButton');

  // Initialize component library tabs
  componentTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      // Remove active class from all tabs
      componentTabs.forEach(t => t.classList.remove('active'));
      // Add active class to clicked tab
      tab.classList.add('active');
      
      // Hide all categories
      componentCategories.forEach(cat => cat.style.display = 'none');
      // Show selected category
      const category = tab.dataset.tab;
      document.querySelector(`.component-category[data-category="${category}"]`).style.display = 'block';
    });
  });

  // Initialize drag events for components
  const componentItems = document.querySelectorAll('.component-item');
  componentItems.forEach(item => {
    item.addEventListener('dragstart', handleComponentDragStart);
    item.addEventListener('dragend', handleComponentDragEnd);
    item.addEventListener('click', handleComponentTap);
  });

  function handleComponentDragStart(e) {
    draggedComponent = e.target;
    e.target.classList.add('dragging');
    e.dataTransfer.setData('text/plain', e.target.dataset.type);
    e.dataTransfer.effectAllowed = 'copy';
  }

  function handleComponentDragEnd(e) {
    e.target.classList.remove('dragging');
    draggedComponent = null;
    dropIndicator.style.display = 'none';
  }

  function handleComponentTap(e) {
    // Only proceed if we're on mobile
    if (window.innerWidth <= 768) {
      e.preventDefault();
      
      // Get the component data
      const componentData = e.currentTarget.dataset;
      
      // Get frame and document
      const frame = document.getElementById('preview-frame');
      const frameDoc = frame.contentDocument || frame.contentWindow.document;
      
      // Create the new element
      const newElement = frameDoc.createElement('div');
      newElement.innerHTML = componentData.content;
      const elementToInsert = newElement.firstElementChild;
      
      // Make draggable/resizable
      makeElementDraggable(elementToInsert);
      makeElementResizable(elementToInsert);
      
      // Position the element in the center of the viewport
      const frameRect = frame.getBoundingClientRect();
      const viewportHeight = frameDoc.documentElement.clientHeight;
      const scrollTop = frameDoc.documentElement.scrollTop || frameDoc.body.scrollTop;
      
      elementToInsert.style.position = 'absolute';
      elementToInsert.style.left = '50%';
      elementToInsert.style.top = (viewportHeight / 2 + scrollTop) + 'px';
      elementToInsert.style.transform = 'translate(-50%, -50%)';
      elementToInsert.style.zIndex = '1000';
      
      // Add to iframe
      frameDoc.body.appendChild(elementToInsert);
      
      // Update display
      const allElements = frameDoc.getElementsByTagName('*');
      Array.from(allElements).forEach(el => el.classList.remove('highlight'));
      elementToInsert.classList.add('highlight');
      
      // Update website code
      updateWebsiteCode(frameDoc);
      
      // Show a brief feedback toast
      showToast(`Added ${componentData.type} component`);
    }
  }

  function showToast(message) {
    // Create toast container if it doesn't exist
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.className = 'toast-container';
      document.body.appendChild(toastContainer);
    }
    
    // Create and show toast
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    toastContainer.appendChild(toast);
    
    // Remove toast after animation
    setTimeout(() => {
      toast.classList.add('fade-out');
      setTimeout(() => toast.remove(), 300);
    }, 2000);
  }

  // Set up drop events for the preview frame
  const iframeOverlay = document.querySelector('.iframe-overlay');
  iframeOverlay.addEventListener('dragover', handleFrameDragOver);
  iframeOverlay.addEventListener('dragleave', handleFrameDragLeave);
  iframeOverlay.addEventListener('drop', handleFrameDrop);

  function handleFrameDragOver(e) {
    e.preventDefault();
    if (!draggedComponent) return;
    
    const frameRect = previewFrame.getBoundingClientRect();
    const frameDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
    
    // Calculate position relative to iframe
    const x = e.clientX - frameRect.left;
    const y = e.clientY - frameRect.top;
    
    // Show drop indicator at cursor position
    dropIndicator.style.width = '100px';
    dropIndicator.style.height = '50px';
    dropIndicator.style.left = `${e.clientX - 50}px`;
    dropIndicator.style.top = `${e.clientY - 25}px`;
    
    dropIndicator.style.display = 'block';
    dropIndicator.classList.add('active');
  }

  function handleFrameDragLeave(e) {
    e.preventDefault();
    dropIndicator.style.display = 'none';
    dropIndicator.classList.remove('active');
  }

  function handleFrameDrop(e) {
    e.preventDefault();
    dropIndicator.style.display = 'none';
    dropIndicator.classList.remove('active');
    
    if (!draggedComponent) return;
    
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    
    // Calculate position relative to iframe
    const frameRect = frame.getBoundingClientRect();
    const x = e.clientX - frameRect.left;
    const y = e.clientY - frameRect.top;
    
    // Create the new element
    const newElement = frameDoc.createElement('div');
    newElement.innerHTML = draggedComponent.dataset.content;
    const elementToInsert = newElement.firstElementChild;
    
    // Make draggable/resizable
    makeElementDraggable(elementToInsert);
    makeElementResizable(elementToInsert);
    
    // Position the element
    elementToInsert.style.position = 'absolute';
    elementToInsert.style.left = `${x}px`;
    elementToInsert.style.top = `${y}px`;
    elementToInsert.style.zIndex = '1000';
    
    // Add to iframe
    frameDoc.body.appendChild(elementToInsert);
    
    // Update display
    const allElements = frameDoc.getElementsByTagName('*');
    Array.from(allElements).forEach(el => el.classList.remove('highlight'));
    elementToInsert.classList.add('highlight');
    updateWebsiteCode(frameDoc);
  }

  // Update an existing website
// Enhanced update function for full website updates
async function updateWebsite(prompt) {
  const button = document.getElementById('generateButton');
  button.classList.add('generating');
  button.disabled = true;

  try {
    let currentContent = isZipProject ? 
      Object.entries(projectFiles)
        .map(([path, file]) => `=== ${path} ===\n${file.type === 'text' ? file.content : '[Binary/Image file]'}`)
        .join('\n\n') 
      : currentWebsiteCode;

    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-exp-03-25:generateContent?key=${geminiConfig.apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `Update this website according to: ${prompt}\n\nCurrent content:\n${currentContent}`
          }]
        }]
      })
    });

    if (!response.ok) throw new Error(`API request failed: ${response.status}`);
    const data = await response.json();
    const responseText = data.candidates[0].content.parts[0].text;

    if (isZipProject) {
      const updates = JSON.parse(responseText);
      Object.entries(updates.files).forEach(([path, content]) => {
        if (projectFiles[path]) {
          projectFiles[path].content = content;
        } else {
          projectFiles[path] = { type: 'text', content };
        }
      });
      await saveProjectToStorage();
      if (currentFilePath) await loadProjectFile(currentFilePath);
    } else {
      currentWebsiteCode = responseText.match(/<!DOCTYPE html>[\s\S]*<\/html>/i)?.[0] || responseText;
      await saveProjectToStorage();
      await processHTMLContent(currentWebsiteCode);
    }

    setTimeout(() => location.reload(), 500);
  } catch (error) {
    console.error('Error updating website:', error);
    alert('Error updating website: ' + error.message);
  } finally {
    button.classList.remove('generating');
    button.disabled = false;
  }
}

  function updateWebsiteCode(frameDoc) {
    // Get the current HTML content from the iframe
    const htmlContent = frameDoc.documentElement.outerHTML;

    if (isZipProject && projectFiles[currentFilePath]) {
      // Update the specific file's content in projectFiles
      projectFiles[currentFilePath].content = htmlContent;
      // Mark it as potentially needing path restoration during download
      projectFiles[currentFilePath].needsPathRestoration = true;
    } else if (!isZipProject) {
      // Update the main content for single HTML files
      currentWebsiteCode = htmlContent;
    }
    // Note: No immediate path cleanup here; defer to download.
  }
  // Edit mode toggle
  toggleEditModeButton.addEventListener('click', () => {
    editModeEnabled = !editModeEnabled;
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    const overlay = document.querySelector('.iframe-overlay');
    
    if (editModeEnabled) {
      toggleEditModeButton.classList.add('active');
      frameDoc.body.classList.add('edit-mode-active');
      overlay.style.display = 'block';
      
      // Enable all draggable elements
      const draggables = frameDoc.querySelectorAll('.draggable');
      draggables.forEach(el => {
        el.style.cursor = 'move';
      });
    } else {
      toggleEditModeButton.classList.remove('active');
      frameDoc.body.classList.remove('edit-mode-active');
      overlay.style.display = 'none';
      
      // Disable all draggable elements
      const draggables = frameDoc.querySelectorAll('.draggable');
      draggables.forEach(el => {
        el.style.cursor = '';
      });
    }
  });

  // Delete element button
  deleteElementButton.addEventListener('click', () => {
    if (!elementToDelete) return;
    
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    
    // Remove the element from the DOM
    elementToDelete.remove();
    elementToDelete = null;
    deleteElementButton.disabled = true;
    
    // Update the website code
    updateWebsiteCode(frameDoc);
  });

  // Initialize the move elements toggle
  document.getElementById('toggleMoveElements').addEventListener('change', function(e) {
    moveElementsEnabled = e.target.checked;
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    const elements = frameDoc.querySelectorAll('.draggable');
    
    elements.forEach(element => {
      if (moveElementsEnabled) {
        element.style.cursor = 'move';
        // Restore position if it exists
        if (elementPositions.has(element)) {
          const pos = elementPositions.get(element);
          element.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
        }
      } else {
        element.style.cursor = '';
        // Don't reset transform - just disable dragging
      }
    });
  });

  function addMessage(message, sender) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}`;
    messageDiv.textContent = message;
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Add to conversation history
    conversationHistory.push({
      role: sender === "user" ? "user" : "model", // Corrected role for Gemini
      parts: [{ text: message }]
    });
    
    // Keep only last 10 messages in history
    if (conversationHistory.length > 10) {
      conversationHistory = conversationHistory.slice(-10);
    }
  }

  async function sendMessage() {
    const message = chatInput.value.trim();
    if (!message) return;
    
    chatInput.value = '';
    addMessage(message, 'user');
    
    try {
        let codeContext = isZipProject 
            ? Object.entries(projectFiles).map(([path, file]) => `${path}:\n${file.type === 'text' ? file.content : '[Binary/Image file]'}`).join('\n\n')
            : currentWebsiteCode;

        const systemInstruction = {
            role: "user",
            parts: [{text: `You are a helpful assistant with expertise in web development. You have access to the following website code:\n\n${codeContext}\n\nAnalyze the code to provide accurate and contextual responses. This is a system instruction, respond to the next user message.`}]
        };

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${geminiConfig.apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [systemInstruction, ...conversationHistory]
            })
        });

        if (!response.ok) throw new Error(`API Error: ${response.status}`);
        const data = await response.json();
        const assistantMessage = data.candidates[0].content.parts[0].text;
        addMessage(assistantMessage, 'assistant');
    } catch (error) {
        console.error('Error sending message:', error);
        addMessage('Sorry, there was an error processing your request. Please try again.', 'assistant');
    }
  }

  // Update the event listeners for chat functionality
  chatBubble.addEventListener('click', () => {
    chatWindow.style.display = 'flex';
    chatOverlay.classList.toggle('open');
  });

  chatClose.addEventListener('click', () => {
    chatWindow.style.display = 'none';
    chatOverlay.classList.remove('open');
  });

  chatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      sendMessage();
    }
  });

  chatSend.addEventListener('click', sendMessage);

  chatOverlay.addEventListener('click', () => {
    chatWindow.style.display = 'none';
    chatOverlay.classList.remove('open');
  });

  // New view toggling globals and functions
  let currentView = "playground"; // "playground" or "code"
  function setView(view) {
    currentView = view;
    if(view === "playground") {
      document.getElementById("playgroundContainer").style.display = 'flex';
      document.getElementById("codeDisplayContainer").style.display = 'none';
      document.getElementById("toggleViewButton").textContent = "Switch to Code Explorer";
    } else if(view === "code") {
      document.getElementById("playgroundContainer").style.display = 'none';
      document.getElementById("codeDisplayContainer").style.display = 'block';
      document.getElementById("toggleViewButton").textContent = "Switch to Playground";
    }
  }
  function toggleView() {
    if(currentView === "playground") {
      setView("code");
    } else {
      setView("playground");
    }
  }
  
  // File upload and processing
  dropzone.addEventListener('dragover', e => {
    e.preventDefault();
    dropzone.classList.add('dragover');
  });
  dropzone.addEventListener('dragleave', () => {
    dropzone.classList.remove('dragover');
  });
  dropzone.addEventListener('drop', async e => {
    e.preventDefault();
    dropzone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    await handleFile(file);
  });
  fileInput.addEventListener('change', async e => {
    const file = e.target.files[0];
    await handleFile(file);
  });

// Enhanced save function
async function saveProjectToStorage() {
  const db = await openDB();
  const tx = db.transaction(['projects', 'files'], 'readwrite');
  
  // Save project metadata
  const projectData = {
    id: 'current',
    isZipProject,
    currentFilePath,
    currentWebsiteCode,
    lastUpdated: new Date().toISOString()
  };
  tx.objectStore('projects').put(projectData);

  // Save files (including large ones)
  if (isZipProject) {
    for (const [path, file] of Object.entries(projectFiles)) {
      const fileData = {
        path,
        projectId: 'current',
        ...file
      };
      
      // Store blobs directly in IndexedDB
      if (file.blob) {
        fileData.blob = file.blob;
      }
      
      tx.objectStore('files').put(fileData);
    }
  }

  return new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}  

// Enhanced load function
async function loadProjectFromStorage() {
  const db = await openDB();
  
  // Get project metadata
  const projectData = await new Promise((resolve) => {
    const tx = db.transaction('projects');
    tx.objectStore('projects').get('current').onsuccess = (e) => resolve(e.target.result);
  });

  if (!projectData) return false;

  isZipProject = projectData.isZipProject;
  currentFilePath = projectData.currentFilePath;
  currentWebsiteCode = projectData.currentWebsiteCode;

  // Get all files
  if (isZipProject) {
    projectFiles = {};
    const files = await new Promise((resolve) => {
      const tx = db.transaction('files');
      const request = tx.objectStore('files')
        .index('projectId')
        .getAll('current');
      
      request.onsuccess = (e) => resolve(e.target.result);
    });

    for (const fileData of files) {
      projectFiles[fileData.path] = {
        type: fileData.type,
        content: fileData.content,
        blob: fileData.blob,
        url: fileData.blob ? URL.createObjectURL(fileData.blob) : fileData.url
      };
    }
    
    renderFileTree();
    if (currentFilePath) {
      await loadProjectFile(currentFilePath);
    }
  } else if (currentWebsiteCode) {
    await processHTMLContent(currentWebsiteCode);
  }

  return true;
}

  navigator.storage.estimate().then(estimate => {
  console.log(`Using ${estimate.usage} out of ${estimate.quota} bytes`);
});

  async function cleanupOldProjects() {
  const db = await openDB();
  const tx = db.transaction(['projects', 'files'], 'readwrite');
  tx.objectStore('projects').delete('current');
  
  // Delete all files for this project
  const index = tx.objectStore('files').index('projectId');
  index.openCursor('current').onsuccess = (e) => {
    const cursor = e.target.result;
    if (cursor) {
      cursor.delete();
      cursor.continue();
    }
  };
  
  await new Promise((resolve) => { tx.oncomplete = resolve; });
}

  function cleanupBlobUrls() {
  Object.values(projectFiles).forEach(file => {
    if (file.url && file.url.startsWith('blob:')) {
      URL.revokeObjectURL(file.url);
    }
  });
}


  
  // Clear stored project
function clearStoredProject() {
    localStorage.removeItem('webCodeExplorerProject');
    sessionStorage.removeItem('webCodeExplorerProject');
    delete window.tempProjectStorage;
}
// Clear current project
// Updated clear function
async function clearCurrentProject() {
    if (!currentWebsiteCode && Object.keys(projectFiles).length === 0 && !currentProjectId) return;
    
    if (!confirm('Are you sure you want to clear the current project? This will remove all local unsaved changes.')) return;

    // Clear all variables
    currentWebsiteCode = '';
    projectFiles = {};
    isZipProject = false;
    currentFilePath = '';
    currentProjectId = null;
    currentProjectName = 'Untitled Project';

    
    // Clear the preview iframe
    const frame = document.getElementById('preview-frame');
    if (frame) {
        const frameDoc = frame.contentDocument || frame.contentWindow.document;
        frameDoc.open();
        frameDoc.write('<html><head><title>Cleared</title></head><body></body></html>');
        frameDoc.close();
    }
    
    // Clear file browser
    const fileTree = document.getElementById('fileTree');
    if (fileTree) fileTree.innerHTML = '';
    
    // Clear any upload messages
    const uploadMessage = document.getElementById('zipUploadMessage');
    if (uploadMessage) uploadMessage.textContent = '';
    
    // Clear storage
    clearStoredProject();
    
    // Reset UI
    checkForProject();
    
    // Show create new section
    const createSection = document.querySelector('.create-new-section');
    if (createSection) createSection.classList.add('show');
}  
async function handleFile(file) {
  // Clear current project first
  currentWebsiteCode = '';
  projectFiles = {};
  isZipProject = false;
  currentFilePath = '';
  currentProjectId = null; // New project, not from cloud
  currentProjectName = file.name;
  clearStoredProject();
  
  if (!file) {
    checkForProject();
    return;
  }
  
  if (file.type.includes('html')) {
    // Single HTML file
    document.getElementById('fileBrowser').style.display = 'none';
    document.getElementById('zipUploadMessage').textContent = '';
    const content = await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = e => resolve(e.target.result);
      reader.readAsText(file);
    });
    processHTMLContent(content);
  } else if (file.name.endsWith('.zip')) {
    // ZIP file handling
    isZipProject = true;
    document.getElementById('zipUploadMessage').textContent = 'Extracting ZIP archive...';
    
    try {
      await extractZipFile(file);
      document.getElementById('zipUploadMessage').textContent = 'ZIP extracted successfully!';
      document.getElementById('fileBrowser').style.display = 'block';
      
      // Find the first HTML file to display
      const htmlFiles = Object.keys(projectFiles).filter(path => path.endsWith('.html') || path.endsWith('.htm'));
      if (htmlFiles.length > 0) {
        renderFileTree();
        await loadProjectFile(htmlFiles[0]);
      } else {
        document.getElementById('zipUploadMessage').textContent = 'No HTML files found in the ZIP archive.';
        checkForProject();
      }
    } catch (error) {
      console.error('Error extracting ZIP:', error);
      document.getElementById('zipUploadMessage').textContent = 'Error extracting ZIP: ' + error.message;
      checkForProject();
    }
  } else {
    alert('Please upload an HTML file or ZIP archive');
    checkForProject();
  }
}  
  async function extractZipFile(zipFile) {
    const zipJsLib = 'https://cdn.jsdelivr.net/npm/@zip.js/zip.js/dist/zip.min.js';
    
    // Load zip.js library if not already loaded
    if (!window.zip) {
       await new Promise((resolve, reject) => {
         const script = document.createElement('script');
         script.src = zipJsLib;
         script.onload = resolve;
         script.onerror = reject;
         document.head.appendChild(script);
       });
    }
    
    const reader = new zip.ZipReader(new zip.BlobReader(zipFile));
    const entries = await reader.getEntries();
    
    // Process all entries
    for (const entry of entries) {
      if (!entry.directory) {
        try {
          // First check if it's an image file
          const isImage = /\.(jpg|jpeg|png|gif|svg|webp|ico)$/i.test(entry.filename);
          
          if (isImage) {
            // For images, get as blob and create object URL
            const blob = await entry.getData(
              new zip.BlobWriter(getMimeType(entry.filename))
            );
            projectFiles[entry.filename] = {
              type: 'image',
              url: URL.createObjectURL(blob),
              blob: blob
            };
          } else {
            // Try to get as text first (for HTML, CSS, JS files)
            try {
              const content = await entry.getData(
                new zip.TextWriter()
              );
              projectFiles[entry.filename] = {
                type: 'text',
                content: content
              };
            } catch (e) {
              // If text extraction fails, get as binary
              const binaryContent = await entry.getData(
                new zip.BlobWriter(getMimeType(entry.filename))
              );
              projectFiles[entry.filename] = {
                type: 'binary',
                url: URL.createObjectURL(binaryContent),
                blob: binaryContent
              };
            }
          }
        } catch (binError) {
          console.error(`Failed to extract file ${entry.filename}:`, binError);
        }
      }
    }
    
    await reader.close();
  }
  
  function resolveRelativePath(baseDir, relativePath) {
    // Handle absolute paths within the zip
    if (relativePath.startsWith('/')) {
      // Absolute path within the zip
      return relativePath.substring(1);
    }
    
    const baseParts = baseDir.split('/').filter(Boolean);
    const relativeParts = relativePath.split('/').filter(Boolean);
    
    let resultParts = [...baseParts];
    
    for (let i = 0; i < relativeParts.length; i++) {
      if (relativeParts[i] === '..') {
        resultParts.pop();
      } else if (relativeParts[i] === '.') {
        // Do nothing for current directory
      } else {
        resultParts.push(relativeParts[i]);
      }
    }
    
    return resultParts.join('/');
  }
  
  function rewriteResourcePaths(htmlContent) {
    if (!isZipProject) return htmlContent;
    
    const tempContainer = document.createElement('div');
    tempContainer.innerHTML = htmlContent;
    
    // Get the directory of the current HTML file
    const currentDir = currentFilePath.substring(0, currentFilePath.lastIndexOf('/') + 1);

    // Process script tags
    Array.from(tempContainer.getElementsByTagName('script')).forEach(script => {
      if (script.src && !script.src.startsWith('http') && !script.src.startsWith('data:')) {
        const relativePath = resolveRelativePath(currentDir, script.src);
        if (projectFiles[relativePath]) {
          // Create a blob URL for the script
          const blob = new Blob([projectFiles[relativePath]], {type: 'application/javascript'});
          script.src = URL.createObjectURL(blob);
        }
      }
    });
    
    // Process links (CSS)
    Array.from(tempContainer.getElementsByTagName('link')).forEach(link => {
      if (link.rel === 'stylesheet' && link.href && !link.href.startsWith('http')) {
        const relativePath = resolveRelativePath(currentDir, link.href);
        if (projectFiles[relativePath]) {
          // Create a blob URL for the CSS
          const blob = new Blob([projectFiles[relativePath]], {type: 'text/css'});
          link.href = URL.createObjectURL(blob);
        }
      }
    });
    
    // Process images
    Array.from(tempContainer.querySelectorAll('img')).forEach(img => {
      if (img.src && !img.src.startsWith('http') && !img.src.startsWith('data:')) {
        const relativePath = resolveRelativePath(currentDir, img.src);
        if (projectFiles[relativePath]) {
          // For images, we need to determine the MIME type
          const mimeType = getMimeType(relativePath);
          const blob = new Blob([new TextEncoder().encode(projectFiles[relativePath])], {type: mimeType});
          img.src = URL.createObjectURL(blob);
        }
      }
    });
    
    return tempContainer.innerHTML;
  }
  
  function renderFileTree() {
    const fileTree = document.getElementById('fileTree');
    fileTree.innerHTML = '';
    
    // Create a hierarchical structure for files
    const fileStructure = {};
    
    Object.keys(projectFiles).forEach(path => {
      const parts = path.split('/').filter(Boolean);
      let current = fileStructure;
      
      parts.forEach((part, index) => {
        if (index === parts.length - 1) {
          // It's a file
          current[part] = path;
        } else {
          // It's a directory
          if (!current[part]) {
            current[part] = {};
          }
          current = current[part];
        }
      });
    });
    
    // Render the file tree
    renderFileStructure(fileStructure, fileTree, '');
  }
  
  function renderFileStructure(structure, container, prefix) {
    const ul = document.createElement('ul');
    ul.className = 'file-list';
    
    Object.keys(structure).sort().forEach(key => {
      const value = structure[key];
      
      if (typeof value === 'string') {
        // It's a file
        const fileType = key.split('.').pop().toLowerCase();
        const icon = getFileIcon(fileType);
        
        const li = document.createElement('li');
        li.className = 'file-item';
        li.innerHTML = `
          <span class="file-icon">${icon}</span>
          <span>${key}</span>
        `;
        li.addEventListener('click', () => loadProjectFile(value));
        li.dataset.path = value;
        
        if (value === currentFilePath) {
          li.classList.add('active');
        }
        ul.appendChild(li);
      } else {
        // It's a directory
        const li = document.createElement('li');
        li.innerHTML = `<strong>${key}/</strong>`;
        const folderDiv = document.createElement('div');
        folderDiv.className = 'file-tree-folder';
        li.appendChild(folderDiv);
        renderFileStructure(value, folderDiv, prefix + key + '/');
        ul.appendChild(li);
      }
    });
    
    container.appendChild(ul);
  }
  
  function getFileIcon(fileType) {
    const icons = {
      'html': 'üìÑ',
      'htm': 'üìÑ',
      'css': 'üé®',
      'js': 'üîß',
      'json': 'üìã',
      'png': 'üñºÔ∏è',
      'jpg': 'üñºÔ∏è',
      'jpeg': 'üñºÔ∏è',
      'gif': 'üñºÔ∏è',
      'svg': 'üñºÔ∏è',
      'webp': 'üñºÔ∏è',
      'ico': 'üñºÔ∏è',
      'txt': 'üìù'
    };
    
    return icons[fileType] || 'üìÑ';
  }
  
  async function loadProjectFile(filePath) {
    if (!projectFiles[filePath]) {
      console.error('File not found:', filePath);
      return;
    }

    currentFilePath = filePath;

    // Update file tree UI
    const fileItems = document.querySelectorAll('.file-item');
    fileItems.forEach(item => item.classList.remove('active'));
    const activeItem = document.querySelector(`.file-item[data-path="${filePath}"]`);
    if (activeItem) activeItem.classList.add('active');

    const fileData = projectFiles[filePath];
    const fileType = filePath.split('.').pop().toLowerCase();

    if (fileData.type === 'image') {
      displayImageFile(filePath, fileData.url);
    } else if (fileData.type === 'text') {
      if (fileType === 'html' || fileType === 'htm') {
        // Start with the canonical content stored in projectFiles
        let htmlContent = fileData.content;
        const baseDir = filePath.substring(0, filePath.lastIndexOf('/') + 1);

        // Use DOMParser for safer modification before writing to iframe
        const parser = new DOMParser();
        const tempDoc = parser.parseFromString(htmlContent, 'text/html');
        
        // Create promises for resolving resources
        const resourcePromises = [];

        // Function to resolve a resource path and update the element attribute
        const resolveAndUpdate = (element, attribute, mimeTypeHint = null) => {
            const originalPath = element.getAttribute(attribute);
            if (originalPath && !originalPath.startsWith('http') && !originalPath.startsWith('data:')) {
                const resourcePath = resolveRelativePath(baseDir, originalPath);
                const resource = projectFiles[resourcePath];
                if (resource) {
                    let promise;
                    if (resource.type === 'image' || resource.type === 'binary') {
                        promise = Promise.resolve(resource.url);
                    } else if (resource.type === 'text') {
                        const mimeType = mimeTypeHint || getMimeType(resourcePath);
                        const blob = new Blob([resource.content], { type: mimeType });
                        const blobUrl = URL.createObjectURL(blob);
                        // Store blob URL temporarily for potential later cleanup if needed
                        resource.tempBlobUrl = blobUrl;
                        promise = Promise.resolve(blobUrl);
                    } else {
                         promise = Promise.resolve(originalPath); // Keep original if type unknown/unsupported
                    }

                    resourcePromises.push(
                        promise.then(resolvedUrl => {
                            if (resolvedUrl !== originalPath) {
                                element.setAttribute(attribute, resolvedUrl);
                                // Add a data attribute to track the original path for download restoration
                                element.setAttribute('data-original-path', originalPath);
                            }
                        }).catch(err => {
                           console.warn(`Could not resolve resource ${originalPath} for preview: ${err}`);
                        })
                    );
                } else {
                   console.warn(`Resource not found in project: ${resourcePath} (from ${originalPath})`);
                }
            }
        };

        // Process elements that load external resources
        tempDoc.querySelectorAll('img[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('video[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('audio[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('source[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('track[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('embed[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('iframe[src]').forEach(el => resolveAndUpdate(el, 'src'));
        tempDoc.querySelectorAll('script[src]').forEach(el => resolveAndUpdate(el, 'src', 'application/javascript'));
        tempDoc.querySelectorAll('link[rel="stylesheet"][href]').forEach(el => resolveAndUpdate(el, 'href', 'text/css'));
        tempDoc.querySelectorAll('link[rel*="icon"][href]').forEach(el => resolveAndUpdate(el, 'href')); // Favicons etc.

        // Process inline styles with url()
        tempDoc.querySelectorAll('[style*="url("]').forEach(element => {
            let style = element.getAttribute('style');
            // Match blob URLs within url()
            style = style.replace(/url\(['"]?([^'")\s]+)['"]?\)/g, (match, blobUrl) => {
                let originalRelativePath = null;
                for (const [p, f] of Object.entries(projectFiles)) {
                    if (f.url === blobUrl || f.tempBlobUrl === blobUrl) {
                        originalRelativePath = resolveRelativePath(baseDir, p);
                        break;
                    }
                }
                if (originalRelativePath) {
                    console.log(`Restored style url() for ${blobUrl} to ${originalRelativePath}`);
                    return `url(${originalRelativePath})`;
                } else {
                    console.warn(`Could not find original path for style blob URL: ${blobUrl} in ${baseDir}`);
                    return match; // Keep original if not found
                }
            });
            element.setAttribute('style', style);
        });


        // Wait for all resources to be resolved before processing content
        await Promise.all(resourcePromises);

        // Serialize the modified document back to string for iframe loading
        const processedHtmlForPreview = tempDoc.documentElement.outerHTML;
        processHTMLContent(processedHtmlForPreview); // Load the processed HTML into the iframe

      } else {
        // Handle non-HTML text files (display as plain text or specific editor)
        displayTextFile(filePath, fileData.content);
      }
    } else if (fileData.type === 'binary') {
      displayBinaryFile(filePath, fileData.url);
    }
  }

  // Add helper function to display non-HTML text files
  function displayTextFile(filePath, content) {
      const frame = document.getElementById('preview-frame');
      const frameDoc = frame.contentDocument || frame.contentWindow.document;
      frameDoc.open();
      frameDoc.write(`
          <!DOCTYPE html>
          <html>
          <head>
              <title>${filePath}</title>
              <style>
                  body { background-color: #1e1e1e; color: #d4d4d4; font-family: monospace; white-space: pre; }
              </style>
          </head>
          <body>${escapeHtml(content)}</body>
          </html>
      `);
      frameDoc.close();
      // Clear code explorer details
      document.getElementById('codeOutput').innerHTML = `Displaying non-HTML file: ${filePath}`;
  }

  // Add helper function for binary files (if needed)
   function displayBinaryFile(filePath, url) {
      const frame = document.getElementById('preview-frame');
      const frameDoc = frame.contentDocument || frame.contentWindow.document;
      frameDoc.open();
      frameDoc.write(`
          <!DOCTYPE html>
          <html>
          <head><title>${filePath}</title></head>
          <body style="background:#1e1e1e; color:white; padding:20px;">
              <h2>Binary File</h2>
              <p>Cannot display content for: ${filePath}</p>
              <p><a href="${url}" download="${filePath.split('/').pop()}" style="color:#4fc3f7;">Download File</a></p>
          </body>
          </html>
      `);
      frameDoc.close();
      document.getElementById('codeOutput').innerHTML = `Displaying binary file: ${filePath}`;
   }

  async function handleAIEdit(prompt, content, loaderElement = null) {
    try {
        if (loaderElement) loaderElement.classList.add('active');
        const systemInstruction = {
            role: "user",
            parts: [{text: `You are an expert web developer assistant. Edit the provided HTML/CSS/JS code based on the given instructions. Return ONLY the modified code without any explanations or markdown formatting. Preserve existing functionality while making the requested changes. Original code:\n${content}`}]
        };
        const userInstruction = { role: "user", parts: [{text: prompt}]};

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${geminiConfig.apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [systemInstruction, userInstruction]
            })
        });

        if (!response.ok) throw new Error(`API Error: ${response.status}`);
        const data = await response.json();
        return data.candidates[0].content.parts[0].text;
    } catch (error) {
        console.error('Error getting AI edit:', error);
        return null;
    } finally {
        if (loaderElement) loaderElement.classList.remove('active');
    }
  }
  
  function handleElementClick(e) {
    const element = e.target;
    const allElements = e.target.ownerDocument.getElementsByTagName('*');
    Array.from(allElements).forEach(el => {
      el.classList.remove('highlight');
    });
    element.classList.add('highlight');
    
    // Update resize panel and keep sidebar open when clicking draggable elements
    if (element.classList.contains('draggable')) {
      updateResizePanel(element);
    } 
    
    functionHistory.length = 0;
    currentHistoryIndex = -1;
    functionHistory.push({
      type: 'element',
      element: element,
      content: generateElementContent(element)
    });
    currentHistoryIndex = 0;
    displayElementInfo(element);
    
    // Enable delete button if in edit mode
    if (editModeEnabled) {
      elementToDelete = element;
      deleteElementButton.disabled = false;
    }
  }
  
  function generateElementContent(element) {
    let output = `
      <div class="edit-controls">
        <input type="text" class="edit-prompt" placeholder="Enter instructions to edit this content...">
        <button data-action="edit-content-ai">Edit with AI</button>
        <div class="loader"></div>
      </div>
      <div class="code-block">
        <h3>Element: ${element.tagName ? element.tagName.toLowerCase() : 'unknown'}</h3>
        <pre class="code-content">${escapeHtml(element.outerHTML || '')}</pre>
      </div>
    `;
    const styles = getApplicableStyles(element);
    output += `
      <div class="css-rules">
        <h4>CSS Rules:</h4>
        <pre>${escapeHtml(styles)}</pre>
      </div>
    `;
    const eventHandlers = getEventHandlers(element);
    output += `
      <div class="event-handlers">
        <h4>Event Handlers:</h4>
        <pre>${escapeHtml(JSON.stringify(eventHandlers, null, 2))}</pre>
      </div>
    `;
    const relatedFunctions = getRelatedFunctions(element);
    if (relatedFunctions && relatedFunctions.length > 0) {
      output += `<div class="dependency-tree">
              <h4>Related Functions:</h4>
              ${relatedFunctions.map(func => displayFunctionAndDependencies(func)).join('')}
          </div>`;
    }
    const jsReferences = findJavaScriptReferences(element);
    if (jsReferences && jsReferences.length > 0) {
      output += `<div class="js-references">
              <h4>JavaScript References:</h4>
              ${jsReferences.map(code => `<pre class="code-content">${code}</pre>`).join('')}
          </div>`;
    }
    output += '</div>';
    const codeOutput = document.getElementById('codeOutput');
    if (codeOutput) {
      codeOutput.innerHTML = output;
    }
  }
  
  function displayElementInfo(element) {
    generateElementContent(element);
  }

  function getApplicableStyles(element) {
    let styles = '';
    for (const rule in styleRegistry) {
      if (rule.trim().startsWith('@')) continue;
      try {
        if (element.matches(rule)) {
          styles += styleRegistry[rule] + '\n';
        }
      } catch (e) {
        console.error(`Invalid selector '${rule}':`, e);
      }
    }
    return styles || 'No specific CSS rules found';
  }
  
  function getEventHandlers(element) {
    if (!element || !element.tagName) return 'No event handlers found';
    const tagName = element.tagName.toLowerCase();
    return eventRegistry[tagName] || 'No event handlers found';
  }
  
  function getRelatedFunctions(element) {
    if (!element || !element.attributes) return [];
    const functions = [];
    const attributes = element.attributes;
    Array.from(attributes).forEach(attr => {
      if (attr && attr.name && attr.name.startsWith('on')) {
        const functionName = attr.value.replace('()', '');
        if (functionRegistry[functionName]) {
          functions.push(functionName);
        }
      }
    });
    return functions;
  }
  
  function displayFunctionAndDependencies(functionName, level = 0) {
    if (!functionName || !functionRegistry[functionName]) return '';
    const func = functionRegistry[functionName];
    const indent = '  '.repeat(level);
    let output = `<div class="code-block">
          <span class="function-name">${escapeHtml(functionName)}</span>
          <div class="edit-buttons">
            <button data-action="edit-manual" data-func="${functionName}">Edit Manually</button>
            <button data-action="save-manual" data-func="${functionName}">Save Changes</button>
            <button data-action="edit-ai" data-func="${functionName}">Edit with AI</button>
          </div>
          <pre class="code-content">${addFunctionLinks(escapeHtml(func.code || ''))}</pre>
          <div class="code-editor">
            <textarea>${escapeHtml(func.code || '')}</textarea>
          </div>`;
    if (func.dependencies && func.dependencies.length > 0) {
      output += `<div class="dependency-tree">
              <h4>Dependencies:</h4>
              ${func.dependencies.map(dep => displayFunctionAndDependencies(dep, level + 1)).join('')}
          </div>`;
    }
    output += '</div>';
    return output;
  }
  
  function addFunctionLinks(code) {
    const functionNames = Object.keys(functionRegistry);
    functionNames.sort((a, b) => b.length - a.length);
    let linkedCode = code;
    functionNames.forEach(funcName => {
      const regex = new RegExp(`\\b(${funcName})\\b(?=\\s*\\(|\\s*=\\s*function|\\s*=\\s*\\(|\\s*=>)`, 'g');
      linkedCode = linkedCode.replace(regex, `<span class="function-link" data-action="show-func" data-func="${funcName}">${funcName}</span>`);
    });
    return linkedCode;
  }
  
  function showFunction(functionName) {
    if (currentHistoryIndex < functionHistory.length - 1) {
      functionHistory.splice(currentHistoryIndex + 1);
    }
    functionHistory.push({
      type: 'function',
      name: functionName,
      content: displayFunctionAndDependencies(functionName)
    });
    currentHistoryIndex = functionHistory.length - 1;
    const output = `<div class="navigation-controls">
              <button data-action="nav-back" ${currentHistoryIndex > 0 ? '' : 'disabled'} class="nav-button">
                  ‚Üê Back
              </button>
          </div>
          <div class="code-block">
              ${functionHistory[currentHistoryIndex].content}
          </div>`;
    document.getElementById('codeOutput').innerHTML = output;
  }
  
  function navigateHistory(direction) {
    if (direction === 'back' && currentHistoryIndex > 0) {
      currentHistoryIndex--;
      const previous = functionHistory[currentHistoryIndex];
      const output = `
          <div class="navigation-controls">
              <button data-action="nav-back" ${currentHistoryIndex > 0 ? '' : 'disabled'} class="nav-button">
                  ‚Üê Back
              </button>
          </div>
          <div class="code-block">
              ${previous.content}
          </div>`;
      document.getElementById('codeOutput').innerHTML = output;
      if (previous.type === 'element' && previous.element) {
        const allElements = previous.element.ownerDocument.getElementsByTagName('*');
        Array.from(allElements).forEach(el => {
          el.classList.remove('highlight');
        });
        previous.element.classList.add('highlight');
      }
    }
  }
  
  function findJavaScriptReferences(element) {
    const references = [];
    const id = element.id;
    const classes = Array.from(element.classList);
    const tagName = element.tagName.toLowerCase();
    const scripts = Array.from(element.ownerDocument.getElementsByTagName('script'));
    scripts.forEach(script => {
      if (!script.textContent) return;
      const content = script.textContent;
      const patterns = [
        id ? new RegExp(`(getElementById\\(['"']${id}['"']\\)|#${id}|document\\.${id}|\\[['"]#${id}['"]]|querySelector\\(['"']#${id}['"']\\))`, 'g') : null,
        ...classes.map(cls => new RegExp(`(getElementsByClassName\\(['"']${cls}['"']\\)|\\.${cls}|querySelector\\(['"']\\.${cls}['"']\\))`, 'g')),
        new RegExp(`(getElementsByTagName\\(['"']${tagName}['"']\\)|querySelector\\(['"']${tagName}['"']\\))`, 'g')
      ].filter(Boolean);
      patterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(content)) !== null) {
          let blockStart = content.lastIndexOf('{', match.index);
          let contextStart = blockStart;
          const searchStartIndex = Math.max(0, blockStart - 500);
          const beforeContext = content.substring(searchStartIndex, blockStart);
          const functionDeclaration = beforeContext.match(/(?:async\s+)?function\s+(\w+)\s*\([^)]*\)\s*$/);
          const arrowFunction = beforeContext.match(/(?:const|let|var)?\s*(\w+)\s*=\s*(?:async\s*)?(?:\([^)]*\)|[^=]*)\s*=>/);
          const methodDeclaration = beforeContext.match(/(\w+)\s*:\s*(?:async\s*)?function\s*\([^)]*\)\s*$/);
          const classMethod = beforeContext.match(/(?:async\s+)?(\w+)\s*\([^)]*\)\s*$/);
          const eventListener = beforeContext.match(/addEventListener\([^)]+\)\s*=>\s*$/);
          if (functionDeclaration || arrowFunction || methodDeclaration || classMethod || eventListener) {
            const lastNewline = beforeContext.lastIndexOf('\n');
            if (lastNewline >= 0) {
              contextStart = searchStartIndex + lastNewline + 1;
            } else {
              contextStart = searchStartIndex;
            }
          }
          if (blockStart >= 0) {
            const completeBlock = content.substring(contextStart, blockStart).trim() + extractCompleteCodeBlock(content, blockStart);
            if (completeBlock && !references.includes(completeBlock)) {
              references.push(addFunctionLinks(completeBlock));
            }
          }
        }
      });
    });
    return references;
  }
  
  
  function extractFunctions(code) {
    try {
      // Basic function declaration regex
      const functionDeclRegex = /function\s+(\w+)\s*\([^)]*\)\s*{/g;
      let match;
      
      while ((match = functionDeclRegex.exec(code)) !== null) {
        const functionName = match[1];
        const startIndex = match.index;
        const functionBody = extractCompleteCodeBlock(code, code.indexOf('{', startIndex));
        
        if (functionBody) {
          const dependencies = findFunctionDependencies(functionBody);
          functionRegistry[functionName] = {
            code: functionBody,
            dependencies: dependencies
          };
        }
      }

      // Arrow function and variable assignment regex
      const arrowFuncRegex = /(?:const|let|var)?\s*(\w+)\s*=\s*(?:async\s*)?(?:\([^)]*\)|[^=]*)\s*=>/g;
      while ((match = arrowFuncRegex.exec(code)) !== null) {
        const functionName = match[1];
        const startIndex = match.index;
        let functionBody;
        
        // Find the function body
        const arrowIndex = code.indexOf('=>', startIndex);
        if (arrowIndex >= 0) {
          if (code[arrowIndex + 2] === '{') {
            functionBody = extractCompleteCodeBlock(code, arrowIndex + 2);
          } else {
            // Single line arrow function
            const lineEnd = code.indexOf('\n', arrowIndex);
            functionBody = code.substring(arrowIndex + 2, lineEnd > -1 ? lineEnd : code.length).trim();
          }
          
          if (functionBody) {
            const dependencies = findFunctionDependencies(functionBody);
            functionRegistry[functionName] = {
              code: `${code.substring(startIndex, arrowIndex + 2)} ${functionBody}`,
              dependencies: dependencies
            };
          }
        }
      }
    } catch (error) {
      console.error('Error extracting functions:', error);
    }
  }

  function extractCompleteCodeBlock(code, openBraceIndex) {
    if (openBraceIndex < 0) return null;
    
    let braceCount = 1;
    let currentIndex = openBraceIndex + 1;
    
    while (braceCount > 0 && currentIndex < code.length) {
      if (code[currentIndex] === '{') {
        braceCount++;
      } else if (code[currentIndex] === '}') {
        braceCount--;
      }
      currentIndex++;
    }
    
    if (braceCount === 0) {
      return code.substring(openBraceIndex, currentIndex);
    }
    
    return null;
  }

  function findFunctionDependencies(functionBody) {
    const dependencies = new Set();
    Object.keys(functionRegistry).forEach(funcName => {
      const regex = new RegExp(`\\b${funcName}\\b(?=\\s*\\()`, 'g');
      if (regex.test(functionBody)) {
        dependencies.add(funcName);
      }
    });
    return Array.from(dependencies);
  }

  function extractStyles(styleContent) {
    try {
      const ruleRegex = /([^{]+)\{([^}]+)\}/g;
      let match;
      
      while ((match = ruleRegex.exec(styleContent)) !== null) {
        const selector = match[1].trim();
        const rules = match[2].trim();
        styleRegistry[selector] = rules;
      }
    } catch (error) {
      console.error('Error extracting styles:', error);
    }
  }

  function extractEventHandlers(element) {
    try {
      const handlers = {};
      const attributes = element.attributes;
      
      if (attributes) {
        Array.from(attributes).forEach(attr => {
          if (attr.name.startsWith('on')) {
            const eventType = attr.name.substring(2);
            handlers[eventType] = attr.value;
          }
        });
      }
      
      if (Object.keys(handlers).length > 0) {
        const tagName = element.tagName.toLowerCase();
        eventRegistry[tagName] = handlers;
      }
    } catch (error) {
      console.error('Error extracting event handlers:', error);
    }
  }

  // Helper function to safely parse JSON
function safeJsonParse(str) {
  try {
    return JSON.parse(str);
  } catch (e) {
    console.error('JSON parse error:', e);
    return null;
  }
}

// Helper function to extract HTML from AI response
function extractHtmlFromResponse(response) {
  // First try to find complete HTML document
  const htmlMatch = response.match(/<!DOCTYPE html>[\s\S]*<\/html>/i);
  if (htmlMatch) return htmlMatch[0];
  
  // Then try to find HTML fragment
  const fragmentMatch = response.match(/<html[\s\S]*<\/html>/i);
  if (fragmentMatch) return fragmentMatch[0];
  
  // Finally, try to find body content
  const bodyMatch = response.match(/<body[\s\S]*<\/body>/i);
  if (bodyMatch) return `<html><head><title>Updated Website</title></head>${bodyMatch[0]}</html>`;
  
  return null;
}


  // Helper function to escape HTML special characters
  function escapeHtml(unsafe) {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

async function processGlobalAIEdit() {
  const instructions = document.getElementById('global-ai-instructions').value.trim();
  if (!instructions) {
    alert('Please describe what changes you want to make to the website.');
    return;
  }

  const editButton = document.getElementById('global-ai-edit');
  editButton.classList.add('processing');

  try {
    // Get current content (either from single file or project files)
    let currentContent;
    if (isZipProject) {
      currentContent = {};
      for (const [path, file] of Object.entries(projectFiles)) {
        currentContent[path] = file.type === 'text' ? file.content : '[Binary file]';
      }
    } else {
      currentContent = currentWebsiteCode;
    }

    // Create more explicit prompt
    const prompt = `I need to make specific changes to this website. Please provide ONLY the minimal changes needed in the exact required JSON format.
Current content: ${JSON.stringify(currentContent)}
Instructions: ${instructions}

Respond STRICTLY with a JSON object containing ONLY a "changes" property with the changed files. Example response:
{
  "changes": {
    "path/to/file.html": "<div>Updated content</div>",
    "styles/main.css": ".updated { color: red; }"
  }
}

Important rules:
1. Do NOT include any additional text, explanations, or markdown formatting
2. ONLY include files that need changes
3. Respond with ONLY the JSON object
4. Maintain all existing content that shouldn't change`;

    // Call AI API
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-exp-03-25:generateContent?key=${geminiConfig.apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }]
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`API request failed: ${response.status} - ${errorData.message || 'Unknown error'}`);
    }

    const data = await response.json();
    const responseText = data.candidates[0].content.parts[0].text;

    // Parse and validate the response
    let parsedResponse;
    try {
      // First try direct parse
      parsedResponse = JSON.parse(responseText);
    } catch (e) {
      // If direct parse fails, try to extract JSON from markdown or code blocks
      const jsonMatch = responseText.match(/\{(?:[^{}]|(?:\{[^{}]*\}))*\}/s);
      if (jsonMatch) {
        try {
          parsedResponse = JSON.parse(jsonMatch[0]);
        console.warn('Extracted JSON from formatted response');
        console.warn('Original response:', responseText);
        console.warn('Extracted JSON:', jsonMatch[0]);
        } catch (e2) {
          throw new Error('Could not extract valid JSON from AI response');
        }
      } else {
        throw new Error('AI response did not contain valid JSON');
      }
    }

    // Validate the response structure
    if (!parsedResponse?.changes || typeof parsedResponse.changes !== 'object') {
      throw new Error('AI response did not contain the required "changes" object');
    }

    const changes = parsedResponse.changes;

    // Validate each change
    for (const [path, newContent] of Object.entries(changes)) {
      if (typeof newContent !== 'string') {
        throw new Error(`Invalid content type for file ${path}`);
      }
      
      if (isZipProject && !projectFiles[path]) {
        console.warn(`File ${path} not found in project, will be created`);
        // Allow new files to be created in project mode
      }
    }

    if (Object.keys(changes).length === 0) {
      throw new Error('No valid changes to apply');
    }

    // Apply the changes
    if (isZipProject) {
      for (const [path, newContent] of Object.entries(changes)) {
        if (projectFiles[path]) {
          projectFiles[path].content = newContent;
        } else {
          // Create new file if it doesn't exist
          projectFiles[path] = {
            type: 'text',
            content: newContent
          };
        }
      }
    } else {
      // For single file, update the entire content
      const changedFiles = Object.keys(changes);
      if (changedFiles.length > 1) {
        throw new Error('Single file mode only supports changing one file at a time');
      }
      currentWebsiteCode = changes[changedFiles[0]];
    }

    // Save the updated project
    await saveProjectToStorage();

    // Reload the current view
    if (isZipProject && currentFilePath) {
      await loadProjectFile(currentFilePath);
    } else {
      await processHTMLContent(currentWebsiteCode);
    }

    // Show success and reload after short delay
    alert('Changes applied successfully!');
    setTimeout(() => location.reload(), 500);

  } catch (error) {
    console.error('Error processing AI edit:', error);
    alert('Error processing changes: ' + error.message);
    
    // Optionally log the full response for debugging
    if (error.message.includes('JSON') && responseText) {
      console.error('Full AI response:', responseText);
    }
  } finally {
    editButton.classList.remove('processing');
  }
}
  
  function getMimeType(filename) {
    const extension = filename.split('.').pop().toLowerCase();
    const mimeTypes = {
      'html': 'text/html',
      'css': 'text/css',
      'js': 'application/javascript',
      'json': 'application/json',
      'png': 'image/png',
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'gif': 'image/gif',
      'svg': 'image/svg+xml',
      'webp': 'image/webp',
      'ico': 'image/x-icon',
      'txt': 'text/plain'
    };
    return mimeTypes[extension] || 'application/octet-stream';
  }

  function closeGlobalAIModal() {
    const modal = document.getElementById('global-ai-modal');
    if(modal){
      modal.style.display = 'none';
    }
    document.getElementById('global-ai-instructions').value = '';
    const summaryElement = document.querySelector('.changes-summary');
    if (summaryElement) {
      summaryElement.textContent = '';
      summaryElement.classList.remove('show');
    }
  }

async function downloadCurrentCode() {
    if (!isZipProject && !currentWebsiteCode) {
        alert("No project loaded to download.");
        return;
    }
    if (isZipProject && Object.keys(projectFiles).length === 0) {
        alert("No project files found to download.");
        return;
    }

    // Ensure JSZip is loaded
    if (typeof JSZip === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        document.head.appendChild(script);
        await new Promise(resolve => script.onload = resolve);
    }


    try {
      const zip = new JSZip();
      
      // Add the edited file
      if (isZipProject) {
        // Process multi-file project
        const filePaths = Object.keys(projectFiles);

        for (const path of filePaths) {
          const file = projectFiles[path];
          let finalContent = null;

          if (file.type === 'text') {
            let currentContent = file.content;
            if (path === currentFilePath && (path.endsWith('.html') || path.endsWith('.htm'))) {
                const frame = document.getElementById('preview-frame');
                if (frame && frame.contentDocument) {
                    currentContent = frame.contentDocument.documentElement.outerHTML;
                }
            }

            if (path.endsWith('.html') || path.endsWith('.htm')) {
                const parser = new DOMParser();
                const tempDoc = parser.parseFromString(currentContent, 'text/html');
                const selectors = ['img[src]', 'video[src]', 'audio[src]', 'source[src]', 'track[src]', 'embed[src]', 'iframe[src]', 'script[src]', 'link[rel="stylesheet"][href]', 'link[rel*="icon"][href]', 'a[href]'];

                tempDoc.querySelectorAll(selectors.join(', ')).forEach(element => {
                    const attribute = element.hasAttribute('src') ? 'src' : 'href';
                    const currentPath = element.getAttribute(attribute);

                    if (currentPath && currentPath.startsWith('blob:')) {
                        let originalRelativePath = element.getAttribute('data-original-path');
                        if (!originalRelativePath) {
                           for (const [p, f] of Object.entries(projectFiles)) {
                              if (f.url === currentPath || f.tempBlobUrl === currentPath) {
                                  originalRelativePath = calculateRelativePath(path, p);
                                  break;
                              }
                           }
                        }
                        if (originalRelativePath) {
                            element.setAttribute(attribute, originalRelativePath);
                            element.removeAttribute('data-original-path');
                        }
                    }
                    if (element.hasAttribute('data-original-path')) {
                        element.removeAttribute('data-original-path');
                    }
                });

                tempDoc.querySelectorAll('[style*="url("]').forEach(element => {
                    let style = element.getAttribute('style');
                    style = style.replace(/url\(['"]?([^'")\s]+)['"]?\)/g, (match, blobUrl) => {
                        let originalRelativePath = null;
                        for (const [p, f] of Object.entries(projectFiles)) {
                           if (f.url === blobUrl || f.tempBlobUrl === blobUrl) {
                               originalRelativePath = calculateRelativePath(path, p);
                               break;
                           }
                        }
                        return originalRelativePath ? `url(${originalRelativePath})` : match;
                    });
                    element.setAttribute('style', style);
                });

                finalContent = tempDoc.documentElement.outerHTML;

            } else {
                 finalContent = currentContent;
            }

            zip.file(path, finalContent);
          } else if (file.type === 'image' || file.type === 'binary') {
             try {
                 const response = await fetch(file.url);
                 if (!response.ok) throw new Error(`Failed to fetch blob: ${response.statusText}`);
                 const blobData = await response.blob();
                 zip.file(path, blobData);
             } catch (fetchError) {
                  console.error(`Error fetching blob data for ${path}: ${fetchError}. Skipping file.`);
             }
          }
        }

        const zipBlob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'edited_project.zip';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

      } else {
        const frame = document.getElementById('preview-frame');
        const frameDoc = frame.contentDocument || frame.contentWindow.document;
        let contentToDownload = frameDoc.documentElement.outerHTML; 

        const tempDoc = document.createElement('div');
        tempDoc.innerHTML = contentToDownload;
        tempDoc.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
        tempDoc.querySelectorAll('.draggable').forEach(el => el.classList.remove('draggable','dragging'));
        tempDoc.querySelectorAll('.resize-handle, .element-delete-handle, .iframe-overlay').forEach(el => el.remove());
        contentToDownload = tempDoc.innerHTML;

        const blob = new Blob([contentToDownload], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'edited_page.html';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
    } catch (error) {
      console.error('Error creating or downloading archive:', error);
      alert('Error creating download: ' + error.message);
    }
}
  
  function updateResizePanel(element) {
    selectedElement = element;
    const panel = document.querySelector('.resize-control-panel');
    const widthInput = document.getElementById('elementWidth');
    const heightInput = document.getElementById('elementHeight');
    const widthUnit = document.getElementById('widthUnit');
    const heightUnit = document.getElementById('heightUnit');
    const bgColorInput = document.getElementById('elementBgColor');
    const textColorInput = document.getElementById('elementTextColor');
    const fontSizeInput = document.getElementById('elementFontSize');
    const fontSizeUnit = document.getElementById('fontSizeUnit');
    const fontFamilySelect = document.getElementById('elementFontFamily');
    const textContentInput = document.getElementById('elementTextContent');
    const elementTypeIndicator = document.getElementById('elementTypeIndicator');
    const imageControls = document.getElementById('imageControls');
    const linkControls = document.getElementById('linkControls');
    const buttonControls = document.getElementById('buttonControls');
    const inputControls = document.getElementById('inputControls');
    const imageUpload = document.getElementById('imageUpload');
    const imageAlt = document.getElementById('imageAlt');
    const imagePreview = document.querySelector('.image-preview');
    const linkUrl = document.getElementById('linkUrl');
    const linkNewTab = document.getElementById('linkNewTab');
    const buttonType = document.getElementById('buttonType');
    const inputType = document.getElementById('inputType');
    const inputPlaceholder = document.getElementById('inputPlaceholder');
    
    // Show element type
    elementTypeIndicator.textContent = element.tagName.toLowerCase();
    
    // Hide all type-specific controls first
    document.querySelectorAll('.element-type-controls').forEach(control => {
      control.style.display = 'none';
    });
    
    // Show specific controls based on element type
    switch(element.tagName.toLowerCase()) {
      case 'img':
        imageControls.style.display = 'block';
        imageAlt.value = element.alt || '';
        imagePreview.innerHTML = `<img src="${element.src}" alt="${element.alt || ''}">`;
        break;
        
      case 'a':
        linkControls.style.display = 'block';
        linkUrl.value = element.href || '';
        linkNewTab.checked = element.target === '_blank';
        break;
        
      case 'button':
        buttonControls.style.display = 'block';
        buttonType.value = element.type || 'button';
        break;
        
      case 'input':
        inputControls.style.display = 'block';
        inputType.value = element.type || 'text';
        inputPlaceholder.value = element.placeholder || '';
        break;
    }
    
    const style = window.getComputedStyle(element);
    const width = parseFloat(style.width);
    const height = parseFloat(style.height);
    const currentWidthUnit = style.width.includes('%') ? '%' : 'px';
    const currentHeightUnit = style.height.includes('%') ? '%' : 'px';
    
    widthInput.value = Math.round(width);
    heightInput.value = Math.round(height);
    widthUnit.value = currentWidthUnit;
    heightUnit.value = currentHeightUnit;
    
    const computedStyle = window.getComputedStyle(element);
    const bgColor = computedStyle.backgroundColor;
    
    const transparentCheckbox = document.getElementById('transparentBg');
    const opacitySlider = document.getElementById('bgOpacity');
    const opacityValue = document.getElementById('opacityValue');
    
    if (bgColor === 'transparent' || bgColor === 'rgba(0, 0, 0, 0)') {
      transparentCheckbox.checked = true;
      opacitySlider.disabled = true;
      opacitySlider.value = 0;
      opacityValue.textContent = '0%';
    } else {
      transparentCheckbox.checked = false;
      opacitySlider.disabled = false;
      
      const match = bgColor.match(/rgba?\([\d\s,\.]+(?:,([\d.]+))?\)/);
      const opacity = match ? Math.round((match[1] || 1) * 100) : 100;
      
      opacitySlider.value = opacity;
      opacityValue.textContent = opacity + '%';
    }
    bgColorInput.value = rgbToHex(bgColor);
    textColorInput.value = rgbToHex(computedStyle.color);
    
    const fontSize = parseFloat(computedStyle.fontSize);
    fontSizeInput.value = Math.round(fontSize);
    fontSizeUnit.value = computedStyle.fontSize.includes('em') ? 'em' : 
                        computedStyle.fontSize.includes('rem') ? 'rem' : 'px';
    
    fontFamilySelect.value = computedStyle.fontFamily || 'inherit';
    
    const isTextEditable = element.nodeType === 3 || 
                          (element.childNodes.length === 1 && element.childNodes[0].nodeType === 3) || 
                          ['P', 'SPAN', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'BUTTON', 'A', 'LABEL', 'DIV'].includes(element.tagName);
    
    if (isTextEditable) {
        let textContent = element.textContent || element.innerText;
        textContentInput.value = textContent.trim();
        textContentInput.disabled = false;
    } else {
        textContentInput.value = '';
        textContentInput.disabled = true;
    }
    
    panel.classList.add('active');
    const resizerSection = panel.closest('.sidebar-section');
    resizerSection.classList.add('expanded');
  }

  function applyStyles() {
    if (!selectedElement) return;
    
    const bgColor = document.getElementById('elementBgColor').value;
    const isTransparent = document.getElementById('transparentBg').checked;
    const opacity = document.getElementById('bgOpacity').value;
    const textColor = document.getElementById('elementTextColor').value;
    const fontSize = document.getElementById('elementFontSize').value;
    const fontSizeUnit = document.getElementById('fontSizeUnit').value;
    const fontFamily = document.getElementById('elementFontFamily').value;
    const textContent = document.getElementById('elementTextContent').value;
    
    if (isTransparent) {
      selectedElement.style.backgroundColor = 'transparent';
    } else {
      const r = parseInt(bgColor.slice(1,3), 16);
      const g = parseInt(bgColor.slice(3,5), 16);
      const b = parseInt(bgColor.slice(5,7), 16);
      const a = opacity / 100;
      selectedElement.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    
    selectedElement.style.color = textColor;
    selectedElement.style.fontSize = `${fontSize}${fontSizeUnit}`;
    selectedElement.style.fontFamily = fontFamily;
    
    switch(selectedElement.tagName.toLowerCase()) {
      case 'img':
        selectedElement.alt = document.getElementById('imageAlt').value;
        break;
        
      case 'a':
        selectedElement.href = document.getElementById('linkUrl').value;
        selectedElement.target = document.getElementById('linkNewTab').checked ? '_blank' : '';
        break;
        
      case 'button':
        selectedElement.type = document.getElementById('buttonType').value;
        break;
        
      case 'input':
        selectedElement.type = document.getElementById('inputType').value;
        selectedElement.placeholder = document.getElementById('inputPlaceholder').value;
        break;
    }
    
    if (!document.getElementById('elementTextContent').disabled && 
        textContent !== '' && 
        textContent !== selectedElement.textContent) { 
      selectedElement.textContent = textContent;
    }
    
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    updateWebsiteCode(frameDoc);
  }

  function rgbToHex(rgb) {
    if (!rgb.startsWith('rgb')) return rgb;
    const values = rgb.match(/\d+/g);
    if (!values) return '#000000';
    const r = parseInt(values[0]);
    const g = parseInt(values[1]);
    const b = parseInt(values[2]);
    return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
  }

  function initializeDragAndResize() {
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    
    const iframeOverlay = document.querySelector('.iframe-overlay');
    iframeOverlay.addEventListener('dragover', handleFrameDragOver);
    iframeOverlay.addEventListener('dragleave', handleFrameDragLeave);
    iframeOverlay.addEventListener('drop', handleFrameDrop);
    
    const elements = frameDoc.getElementsByTagName('*');
    Array.from(elements).forEach(element => {
      if (!['BODY', 'HTML', 'HEAD', 'SCRIPT'].includes(element.tagName)) {
        makeElementDraggable(element);
        makeElementResizable(element);
      }
    });
    saveProjectToStorage();
  }

  function makeElementDraggable(element) {
    element.classList.add('draggable');
    
    if (!elementPositions.has(element)) {
      elementPositions.set(element, { x: 0, y: 0 });
    }
    
    let isDragging = false, currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

    const pos = elementPositions.get(element);
    element.style.transform = `translate(${pos.x}px, ${pos.y}px)`;

    element.addEventListener('mousedown', dragStart);
    element.addEventListener('mousemove', drag);
    element.addEventListener('mouseup', dragEnd);
    element.addEventListener('mouseleave', dragEnd);
    element.addEventListener('touchstart', dragStart, { passive: true });
    element.addEventListener('touchmove', drag, { passive: false });
    element.addEventListener('touchend', dragEnd);

    function dragStart(e) {
      if ((!moveElementsEnabled && !editModeEnabled) || e.target.classList.contains('resize-handle') || e.target.classList.contains('element-delete-handle')) return;
      initialX = (e.type === 'mousedown' ? e.clientX : e.touches[0].clientX) - xOffset;
      initialY = (e.type === 'mousedown' ? e.clientY : e.touches[0].clientY) - yOffset;
      if (e.target === element || element.contains(e.target)) {
        isDragging = true;
        element.classList.add('dragging');
      }
    }

    function drag(e) {
      if (isDragging && (moveElementsEnabled || editModeEnabled)) {
        e.preventDefault();
        currentX = (e.type === 'mousemove' ? e.clientX : e.touches[0].clientX) - initialX;
        currentY = (e.type === 'mousemove' ? e.clientY : e.touches[0].clientY) - initialY;
        xOffset = currentX;
        yOffset = currentY;
        element.style.transform = `translate(${currentX}px, ${currentY}px)`;
      }
    }

    function dragEnd() {
      if (!moveElementsEnabled && !editModeEnabled) return;
      elementPositions.set(element, { x: xOffset, y: yOffset });
      initialX = currentX;
      initialY = currentY;
      isDragging = false;
      element.classList.remove('dragging');
    }
  }

  function makeElementResizable(element) {
    const handles = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    handles.forEach(handleClass => {
        const div = document.createElement('div');
        div.className = `resize-handle ${handleClass}`;
        element.appendChild(div);
    });

    if (editModeEnabled) {
        const deleteHandle = document.createElement('div');
        deleteHandle.className = 'element-delete-handle';
        deleteHandle.innerHTML = '√ó';
        deleteHandle.addEventListener('click', (e) => {
            e.stopPropagation();
            elementToDelete = element;
            deleteElementButton.disabled = false;
            const allElements = element.ownerDocument.getElementsByTagName('*');
            Array.from(allElements).forEach(el => el.classList.remove('highlight'));
            element.classList.add('highlight');
        });
        element.appendChild(deleteHandle);
    }

    let isResizing = false, currentHandle = null, originalWidth = 0, originalHeight = 0, originalX = 0, originalY = 0, originalMouseX = 0, originalMouseY = 0;

    const resizeHandles = element.querySelectorAll('.resize-handle');
    resizeHandles.forEach(handle => {
        handle.addEventListener('mousedown', initResize);
        handle.addEventListener('touchstart', initResize, { passive: true });
    });

    document.addEventListener('mousemove', resize);
    document.addEventListener('touchmove', resize, { passive: false });
    document.addEventListener('mouseup', stopResize);
    document.addEventListener('touchend', stopResize);

    function initResize(e) {
        if (!editModeEnabled) return;
        isResizing = true;
        currentHandle = e.target;
        const rect = element.getBoundingClientRect();
        originalWidth = rect.width;
        originalHeight = rect.height;
        originalX = rect.left;
        originalY = rect.top;
        originalMouseX = e.type === 'mousedown' ? e.pageX : e.touches[0].pageX;
        originalMouseY = e.type === 'mousedown' ? e.pageY : e.touches[0].pageY;
        e.stopPropagation();
    }

    function resize(e) {
        if (!isResizing) return;
        e.preventDefault();
        let currentX = e.type === 'mousemove' ? e.pageX : e.touches[0].pageX;
        let currentY = e.type === 'mousemove' ? e.pageY : e.touches[0].pageY;
        let deltaX = currentX - originalMouseX;
        let deltaY = currentY - originalMouseY;
        let newWidth = originalWidth, newHeight = originalHeight;

        if (currentHandle.classList.contains('bottom-right')) { newWidth += deltaX; newHeight += deltaY; }
        else if (currentHandle.classList.contains('bottom-left')) { newWidth -= deltaX; newHeight += deltaY; element.style.left = originalX + deltaX + 'px'; }
        else if (currentHandle.classList.contains('top-right')) { newWidth += deltaX; newHeight -= deltaY; element.style.top = originalY + deltaY + 'px'; }
        else if (currentHandle.classList.contains('top-left')) { newWidth -= deltaX; newHeight -= deltaY; element.style.top = originalY + deltaY + 'px'; element.style.left = originalX + deltaX + 'px'; }
        
        element.style.width = Math.max(20, newWidth) + 'px';
        element.style.height = Math.max(20, newHeight) + 'px';
    }
    function stopResize() { isResizing = false; currentHandle = null; }
  }

  document.addEventListener('click', function(e) {
    const sidebar = document.querySelector('.sidebar');
    const sidebarToggle = document.querySelector('.sidebar-toggle');
    if (!sidebar.contains(e.target) && !sidebarToggle.contains(e.target) && !e.target.closest('.draggable') && !e.target.closest('.resize-handle') && !e.target.closest('.element-delete-handle') && !e.target.closest('.component-item')) {
      sidebar.classList.remove('open');
    }
  });

  function editCurrentContent(button) {
    let controls = button.parentElement;
    let input = controls.querySelector('.edit-prompt');
    let instructions = input.value.trim();
    if (!instructions) return alert("Please provide editing instructions.");
    let loader = controls.querySelector('.loader');
    let codeBlock = controls.nextElementSibling;
    if (!codeBlock) return alert("Associated code block not found.");
    let codePre = codeBlock.querySelector('.code-content');
    let originalContent = codePre ? codePre.textContent : '';
    if (!originalContent) return alert("No content to edit found.");
    
    handleAIEdit(instructions, originalContent, loader).then(editedCode => {
      if (editedCode) {
        codePre.textContent = editedCode;
        const previewFrame = document.getElementById('preview-frame');
        if (previewFrame) {
          const frameDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
          const highlighted = frameDoc.querySelector('.highlight');
          if (highlighted) {
            highlighted.outerHTML = editedCode;
          }
        }
      } else {
        alert("AI edit failed. Please try again.");
      }
    }).catch(err => {
      console.error("Error in editCurrentContent:", err);
      alert("Error during AI edit.");
    });
  }

  // Sidebar toggle functionality
  document.querySelector('.sidebar-toggle').addEventListener('click', () => {
    document.querySelector('.sidebar').classList.toggle('open');
  });

  // Section collapse functionality
  document.querySelectorAll('.sidebar-section-title').forEach(title => {
    title.addEventListener('click', () => {
      title.parentElement.classList.toggle('expanded');
    });
  });

  document.getElementById('imageUpload').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file && selectedElement && selectedElement.tagName.toLowerCase() === 'img') {
      const reader = new FileReader();
      reader.onload = function(event) {
        selectedElement.src = event.target.result;
        const imagePreview = document.querySelector('.image-preview');
        imagePreview.innerHTML = `<img src="${event.target.result}" alt="${selectedElement.alt || ''}">`;
      };
      reader.readAsDataURL(file);
    }
  });

  document.getElementById('imageAlt').addEventListener('change', e => { if (selectedElement && selectedElement.tagName.toLowerCase() === 'img') selectedElement.alt = e.target.value; });
  document.getElementById('linkUrl').addEventListener('change', e => { if (selectedElement && selectedElement.tagName.toLowerCase() === 'a') selectedElement.href = e.target.value; });
  document.getElementById('linkNewTab').addEventListener('change', e => { if (selectedElement && selectedElement.tagName.toLowerCase() === 'a') selectedElement.target = e.target.checked ? '_blank' : ''; });
  document.getElementById('buttonType').addEventListener('change', e => { if (selectedElement && selectedElement.tagName.toLowerCase() === 'button') selectedElement.type = e.target.value; });
  document.getElementById('inputType').addEventListener('change', e => { if (selectedElement && selectedElement.tagName.toLowerCase() === 'input') selectedElement.type = e.target.value; });
  document.getElementById('inputPlaceholder').addEventListener('change', e => { if (selectedElement && selectedElement.tagName.toLowerCase() === 'input') selectedElement.placeholder = e.target.value; });
  
  // Initialize Ace Editor
  let editor;
  function initCodeEditor() {
    if (!editor) {
      editor = ace.edit("code-editor");
      editor.setTheme("ace/theme/monokai");
      editor.getSession().setMode("ace/mode/html");
      editor.setOptions({
        fontSize: "14px",
        showPrintMargin: false,
        enableLiveAutocompletion: true,
        enableSnippets: true,
        enableBasicAutocompletion: true
      });
    }
  }

  
  function showCodeReview(code) {
    const modal = document.getElementById('code-review-modal');
    modal.style.display = 'block';
    
    let optimizedCode = code;
    
    if (isZipProject) {
        const parser = new DOMParser();
        const tempDoc = parser.parseFromString(optimizedCode, 'text/html');
        
        const elements = tempDoc.querySelectorAll('img[src], script[src], link[href], video[src], audio[src], source[src], iframe[src], embed[src]');
        elements.forEach(element => {
            const attr = element.hasAttribute('src') ? 'src' : 'href';
            const currentPath = element.getAttribute(attr);
            
            if (currentPath && currentPath.startsWith('blob:')) {
                let originalPath = element.getAttribute('data-original-path');
                if (!originalPath) {
                    for (const [path, file] of Object.entries(projectFiles)) {
                        if (file.url === currentPath || file.tempBlobUrl === currentPath) {
                            originalPath = calculateRelativePath(currentFilePath, path);
                            break;
                        }
                    }
                }
                if (originalPath) {
                    element.setAttribute(attr, originalPath);
                    element.removeAttribute('data-original-path');
                }
            }
        });

        const elementsWithBackgroundUrl = tempDoc.querySelectorAll('[style*="url("]');
        elementsWithBackgroundUrl.forEach(element => {
            let style = element.getAttribute('style');
            style = style.replace(/url\(['"]?([^'")\s]+)['"]?\)/g, (match, blobUrl) => {
                for (const [path, file] of Object.entries(projectFiles)) {
                    if (file.url === blobUrl || file.tempBlobUrl === blobUrl) {
                        return `url('${calculateRelativePath(currentFilePath, path)}')`;
                    }
                }
                return match;
            });
            element.setAttribute('style', style);
        });

        optimizedCode = tempDoc.documentElement.outerHTML;
    }
    
    const tempContainer = document.createElement('div');
    tempContainer.innerHTML = optimizedCode;
    tempContainer.querySelectorAll('.highlight, .draggable, .dragging').forEach(el => el.classList.remove('highlight', 'draggable', 'dragging'));
    tempContainer.querySelectorAll('.resize-handle, .element-delete-handle, .iframe-overlay').forEach(el => el.remove());
    optimizedCode = tempContainer.innerHTML;

    initCodeEditor();
    editor.setValue(optimizedCode, -1);
    editor.clearSelection();
  }

  function closeCodeReview() {
    document.getElementById('code-review-modal').style.display = 'none';
  }

  async function confirmAndDownload() {
    const finalCode = editor.getValue();
      
    try {
      if (isZipProject) {
        const zip = new JSZip();
        zip.file(currentFilePath, finalCode);
          
        for (const [path, file] of Object.entries(projectFiles)) {
            if (path === currentFilePath) continue;
            if (file.type === 'text') {
                zip.file(path, file.content);
            } else if ((file.type === 'image' || file.type === 'binary') && file.url) {
                try {
                    const response = await fetch(file.url);
                    const blob = await response.blob();
                    zip.file(path, blob);
                } catch (fetchError) {
                    console.error(`Error fetching binary data for ${path}: ${fetchError}. Skipping file.`);
                }
            }
        }

        const zipBlob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'edited_project.zip';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } else {
        const blob = new Blob([finalCode], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'edited_page.html';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      closeCodeReview();
    } catch (error) {
      console.error('Error creating download:', error);
      alert('Error creating download: ' + error.message);
    }
  }
  
  function removeLeadingSlashes() {
    const code = editor.getValue();
    const affectedLines = [];
    const patterns = [
      /(src|href|url)\s*=\s*["']\/(.*?)["']/g,
      /url\(\s*['"]?\/(.*?)['"]?\)/g,
      /(src|href|url)\s*=\s*{\s*["']\/(.*?)['"]\s*}/g
    ];
    let modifiedCode = code;
    
    code.split('\n').forEach((line, index) => {
      let lineModified = false;
      patterns.forEach(pattern => {
        if (line.match(pattern)) {
          lineModified = true;
          modifiedCode = modifiedCode.replace(line, line.replace(pattern, (match, attr, path) => attr === 'url' ? `url('${path}')` : `${attr}="${path}"`));
        }
      });
      if (lineModified) affectedLines.push(index + 1);
    });
    
    editor.setValue(modifiedCode, -1);
    const reportDiv = document.getElementById('slashRemovalReport');
    reportDiv.innerHTML = affectedLines.length > 0 ? `Modified ${affectedLines.length} line(s): ${affectedLines.join(', ')}` : 'No leading slashes found.';
    reportDiv.style.display = 'block';
    if (affectedLines.length > 0) editor.gotoLine(affectedLines[0], 0, true);
  }

  function calculateRelativePath(fromPath, toPath) {
    fromPath = fromPath.replace(/^\/+/, '');
    toPath = toPath.replace(/^\/+/, '');
    
    const fromParts = fromPath.split('/').filter(Boolean);
    const toParts = toPath.split('/').filter(Boolean);
    fromParts.pop();
    
    let commonLength = 0;
    while (commonLength < fromParts.length && commonLength < toParts.length && fromParts[commonLength] === toParts[commonLength]) {
      commonLength++;
    }
    
    const relativePath = [];
    for (let i = commonLength; i < fromParts.length; i++) relativePath.push('..');
    for (let i = commonLength; i < toParts.length; i++) relativePath.push(toParts[i]);
    return relativePath.join('/') || '.';
  }
  
  function toggleHelpGuide() {
    document.querySelector('.help-guide').classList.toggle('open');
    document.querySelector('.help-overlay').classList.toggle('open');
  }

function checkForProject() {
  const hasProject = isZipProject || currentWebsiteCode;
  const createNewSection = document.querySelector('.create-new-section');
  
  if (hasProject) {
    document.getElementById('websiteActionTitle').textContent = 'Update Website';
    document.getElementById('websiteActionDescription').textContent = 'Describe the changes you want to make...';
    document.getElementById('actionButtonText').textContent = 'Update Website';
    createNewSection.classList.add('show');
  } else {
    document.getElementById('websiteActionTitle').textContent = 'Create New Website';
    document.getElementById('websiteActionDescription').textContent = 'Describe the website you want to create.';
    document.getElementById('actionButtonText').textContent = 'Generate Website';
    createNewSection.classList.add('show');
  }
}

async function handleWebsiteAction() {
  const prompt = document.getElementById('websitePrompt').value.trim();
  if (!prompt) return alert('Please describe what you want to do.');
  const hasProject = isZipProject || currentWebsiteCode;
  if (hasProject) await updateWebsite(prompt);
  else await generateWebsite(prompt);
}

  let geminiConfig = { apiKey: '' };
  
  function saveApiConfig() {
    const apiKey = document.getElementById('apiKey').value.trim();
    const statusDiv = document.querySelector('.api-status');
  
    if (!apiKey) {
      statusDiv.textContent = 'Please enter your API key.';
      statusDiv.className = 'api-status error';
      return;
    }
  
    fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ contents: [{ parts: [{ text: "Hello" }] }] })
    })
    .then(response => {
      if (!response.ok) throw new Error('Invalid API key');
      geminiConfig = { apiKey: apiKey };
      localStorage.setItem('geminiConfig', JSON.stringify(geminiConfig));
      statusDiv.textContent = 'API key verified and saved!';
      statusDiv.className = 'api-status success';
      setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);
    })
    .catch(error => {
      statusDiv.textContent = 'Error: ' + error.message;
      statusDiv.className = 'api-status error';
    });
  }

  async function generateWebsite(prompt) {
    if (!geminiConfig.apiKey) return alert('Please configure your Gemini API key first.');

    const button = document.getElementById('generateButton');
    button.classList.add('generating');
    button.disabled = true;

    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${geminiConfig.apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: `Generate a complete, single-file, responsive HTML website based on this description: ${prompt}. Include embedded CSS and JavaScript. Return only the HTML code.`
            }]
          }]
        })
      });

      if (!response.ok) throw new Error(`API Error: ${response.status}`);
      const data = await response.json();
      let generatedCode = data.candidates[0].content.parts[0].text;
      const htmlMatch = generatedCode.match(/```html\s*([\s\S]*?)```|<!DOCTYPE html>[\s\S]*<\/html>/i);
      generatedCode = htmlMatch ? (htmlMatch[1] || htmlMatch[0]) : generatedCode;

      currentWebsiteCode = generatedCode;
      isZipProject = false;
      currentProjectId = null;
      currentProjectName = 'AI Generated Project';
      processHTMLContent(currentWebsiteCode);
      checkForProject();
      showToast('Website generated successfully!');
    } catch (error) {
      console.error('Error generating website:', error);
      alert('Error generating website: ' + error.message);
    } finally {
      button.classList.remove('generating');
      button.disabled = false;
    }
  }

async function processHTMLContent(content) {
  try {
    currentWebsiteCode = '';
    
    Object.keys(functionRegistry).forEach(key => delete functionRegistry[key]);
    styleRegistry = {};
    eventRegistry = {};
    
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    frameDoc.open();
    
    if (isZipProject) {
        const tempDoc = document.createElement('div');
        tempDoc.innerHTML = content;
        const currentDir = currentFilePath.substring(0, currentFilePath.lastIndexOf('/') + 1);

        ['img', 'video', 'audio', 'source', 'track', 'embed', 'iframe'].forEach(tagName => {
            Array.from(tempDoc.getElementsByTagName(tagName)).forEach(element => {
                const src = element.getAttribute('src');
                if (src && !src.startsWith('http') && !src.startsWith('data:')) {
                    const resourcePath = resolveRelativePath(currentDir, src);
                    const resource = projectFiles[resourcePath];
                    if (resource && (resource.type === 'image' || resource.type === 'binary')) {
                        element.src = resource.url;
                        element.setAttribute('data-original-path', src);
                    }
                }
            });
        });
        
        Array.from(tempDoc.getElementsByTagName('link')).forEach(link => {
            if (link.rel === 'stylesheet' || link.rel.includes('icon')) {
                const href = link.getAttribute('href');
                if (href && !href.startsWith('http')) {
                    const resourcePath = resolveRelativePath(currentDir, href);
                    const resource = projectFiles[resourcePath];
                    if (resource) {
                        if (resource.type === 'text') {
                            const style = document.createElement('style');
                            style.textContent = resource.content;
                            link.parentNode.replaceChild(style, link);
                        } else if (resource.type === 'image' || resource.type === 'binary') {
                            link.href = resource.url;
                            link.setAttribute('data-original-path', href);
                        }
                    }
                }
            }
        });
        
        Array.from(tempDoc.querySelectorAll('[style*="background"]')).forEach(element => {
            let style = element.getAttribute('style');
            if (style) {
                const urlMatch = style.match(/url\(['"]?([^'")\s]+)['"]?\)/);
                if (urlMatch && !urlMatch[1].startsWith('http') && !urlMatch[1].startsWith('data:')) {
                    const resourcePath = resolveRelativePath(currentDir, urlMatch[1]);
                    const resource = projectFiles[resourcePath];
                    if (resource && (resource.type === 'image' || resource.type === 'binary')) {
                        element.style.cssText = style.replace(urlMatch[1], resource.url);
                        element.setAttribute('data-original-style-url', urlMatch[1]);
                    }
                }
            }
        });
        
        Array.from(tempDoc.getElementsByTagName('script')).forEach(script => {
            if (script.src && !script.src.startsWith('http')) {
                const resourcePath = resolveRelativePath(currentDir, script.src);
                const resource = projectFiles[resourcePath];
                if (resource && resource.type === 'text') {
                    script.removeAttribute('src');
                    script.textContent = resource.content;
                }
            }
        });
        frameDoc.write(tempDoc.innerHTML);
    } else {
      frameDoc.write(content);
      currentWebsiteCode = content;
    }
    
    frameDoc.close();
    
    if (frameDoc.body) {
      const scriptEl = frameDoc.createElement('script');
      scriptEl.textContent = `
        window.parent.receiveConsoleLog = (type, args) => {
            const logEvent = new CustomEvent('consoleLog', { detail: { type, args } });
            window.parent.document.dispatchEvent(logEvent);
        };
        (function() {
          const originalLog = console.log, originalError = console.error, originalWarn = console.warn, originalInfo = console.info;
          console.log = function() { originalLog.apply(console, arguments); window.parent.receiveConsoleLog('log', Array.from(arguments)); };
          console.error = function() { originalError.apply(console, arguments); window.parent.receiveConsoleLog('error', Array.from(arguments)); };
          console.warn = function() { originalWarn.apply(console, arguments); window.parent.receiveConsoleLog('warn', Array.from(arguments)); };
          console.info = function() { originalInfo.apply(console, arguments); window.parent.receiveConsoleLog('info', Array.from(arguments)); };
          window.onerror = (m,s,l,c,e) => window.parent.receiveConsoleLog('error', [m,s,l,c,e?e.stack:'']);
          window.onunhandledrejection = e => window.parent.receiveConsoleLog('error', ['Unhandled rejection:', e.reason]);
        })();
      `;
      frameDoc.head.appendChild(scriptEl);
    }
    
    const scripts = frameDoc.getElementsByTagName('script');
    Array.from(scripts).forEach(script => { if (script.textContent) extractFunctions(script.textContent); });
    
    const styles = frameDoc.getElementsByTagName('style');
    Array.from(styles).forEach(style => { if (style.textContent) extractStyles(style.textContent); });
    
    if (frameDoc.body) {
      extractEventHandlers(frameDoc.body);
      frameDoc.body.addEventListener('click', handleElementClick);
    }
    
    setTimeout(() => {
      initializeDragAndResize();
      checkForProject();
      if (isZipProject) renderFileTree();
      saveProjectToStorage();
    }, 500);
  } catch (error) {
    console.error('Error processing HTML content:', error);
    alert('Error loading website content: ' + error.message);
    checkForProject();
  }
}
  
  // Replace receiveConsoleLog with an event listener
  document.addEventListener('consoleLog', (e) => {
    const { type, args } = e.detail;
    const logContainer = document.getElementById('previewConsole');
    if (!logContainer) return;
    const logEntry = document.createElement('div');
    logEntry.className = `console-entry ${type}`;
    // Simple serialization for objects/arrays
    const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' ');
    logEntry.textContent = `[${type.toUpperCase()}] ${message}`;
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
  });

document.getElementById('editCodeButton').addEventListener('click', () => {
  let codeToEdit = '';
  if (isZipProject) {
    if (currentFilePath && projectFiles[currentFilePath] && projectFiles[currentFilePath].type === 'text') {
      codeToEdit = projectFiles[currentFilePath].content;
    } else {
      return alert('Please select a text file to edit.');
    }
  } else {
    const frame = document.getElementById('preview-frame');
    const frameDoc = frame.contentDocument || frame.contentWindow.document;
    codeToEdit = frameDoc.documentElement.outerHTML;
  }
  showCodeReview(codeToEdit);
});


function showCodeEditor(code) {
  const modal = document.getElementById('code-review-modal');
  modal.style.display = 'block';
  
  initCodeEditor();
  editor.setValue(code, -1);
  editor.clearSelection();
}

async function saveCodeChanges() {
  const editedCode = editor.getValue();
  
  try {
    if (isZipProject) {
      if (currentFilePath && projectFiles[currentFilePath]) {
        projectFiles[currentFilePath].content = editedCode;
        await saveProjectToStorage();
        await loadProjectFile(currentFilePath);
        closeCodeReview();
        setTimeout(() => location.reload(), 500);
      }
    } else {
      currentWebsiteCode = editedCode;
      await saveProjectToStorage();
      await processHTMLContent(currentWebsiteCode);
      closeCodeReview();
      setTimeout(() => location.reload(), 500);
    }
  } catch (error) {
    console.error('Error saving changes:', error);
    alert('Error saving changes: ' + error.message);
  }
}
  const StorageUtils = {
    async compress(data) {
        try {
            const stream = new Blob([JSON.stringify(data)]).stream();
            const compressedStream = stream.pipeThrough(new CompressionStream('gzip'));
            const compressedBlob = await new Response(compressedStream).blob();
            return await new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.readAsDataURL(compressedBlob);
            });
        } catch (e) {
            console.warn('Compression failed, storing uncompressed', e);
            return JSON.stringify(data);
        }
    },

    async decompress(data) {
        try {
            if (data.startsWith('H4sI')) {
                const blob = await fetch(`data:application/gzip;base64,${data}`).then(r => r.blob());
                const stream = blob.stream().pipeThrough(new DecompressionStream('gzip'));
                const decompressed = await new Response(stream).text();
                return JSON.parse(decompressed);
            }
            return JSON.parse(data);
        } catch (e) {
            console.warn('Decompression failed, parsing as-is', e);
            return JSON.parse(data);
        }
    }
};

async function processFilesForStorage(files) {
  const result = {};
  
  for (const [path, file] of Object.entries(files)) {
    if (file.type === 'image' || file.type === 'binary') {
      result[path] = { type: file.type, mimeType: file.mimeType || getMimeType(path), size: file.blob?.size || 0, url: file.url, isBinary: true };
      if (file.blob && file.blob.size < 500000) {
        try {
          result[path].content = await blobToBase64(file.blob);
          result[path].oversized = false;
        } catch (e) {
          result[path].oversized = true;
        }
      } else if (file.blob) {
        result[path].oversized = true;
      }
    } else {
      result[path] = { type: 'text', content: file.content };
    }
  }
  
  return result;
}

  
// --- AUTH & PROJECT MANAGEMENT ---

function initApp() {
    const savedUser = localStorage.getItem('currentUser');
    if (savedUser) {
        currentUser = JSON.parse(savedUser);
    }
    updateUserUI();
    setupEventListeners();
    const savedConfig = localStorage.getItem('geminiConfig');
    if (savedConfig) {
        geminiConfig = JSON.parse(savedConfig);
        document.getElementById('apiKey').value = geminiConfig.apiKey;
    }
    ProjectStorage.loadProject().then(loaded => {
        if (!loaded) checkForProject();
    });
}

function updateUserUI() {
    const userInfo = document.getElementById('user-info');
    const authButton = document.getElementById('auth-button');
    const logoutButton = document.getElementById('logout-button');
    const projectsButton = document.getElementById('projects-button');
    const saveButton = document.getElementById('save-project-button');

    if (currentUser) {
        userInfo.textContent = `Welcome, ${currentUser.username}`;
        userInfo.style.display = 'inline';
        authButton.style.display = 'none';
        logoutButton.style.display = 'inline-block';
        projectsButton.style.display = 'inline-block';
        saveButton.style.display = 'inline-block';
    } else {
        userInfo.style.display = 'none';
        authButton.style.display = 'inline-block';
        logoutButton.style.display = 'none';
        projectsButton.style.display = 'none';
        saveButton.style.display = 'none';
    }
}

function setupEventListeners() {
    // --- Major UI Buttons ---
    document.getElementById('auth-button').addEventListener('click', () => showAuthModal(true));
    document.getElementById('logout-button').addEventListener('click', handleLogout);
    document.getElementById('projects-button').addEventListener('click', handleOpenProjectBrowser);
    document.getElementById('save-project-button').addEventListener('click', handleSaveProject);
    document.getElementById('toggleViewButton').addEventListener('click', toggleView);
    document.getElementById('generateButton').addEventListener('click', handleWebsiteAction);
    document.getElementById('help-button').addEventListener('click', toggleHelpGuide);
    document.getElementById('help-guide-close-button').addEventListener('click', toggleHelpGuide);

    // --- Sidebar Controls ---
    document.getElementById('save-config-button').addEventListener('click', saveApiConfig);
    document.getElementById('browse-files-button').addEventListener('click', () => fileInput.click());
    document.getElementById('apply-dimensions-button').addEventListener('click', applyDimensions); // Assuming you have this func
    document.getElementById('apply-styles-button').addEventListener('click', applyStyles);

    // --- Global AI Modal ---
    document.getElementById('global-ai-edit').addEventListener('click', () => document.getElementById('global-ai-modal').style.display = 'block');
    document.getElementById('global-ai-modal-close').addEventListener('click', closeGlobalAIModal);
    document.getElementById('global-ai-cancel-button').addEventListener('click', closeGlobalAIModal);
    document.getElementById('global-ai-apply-button').addEventListener('click', processGlobalAIEdit);
    
    // --- Code Review Modal ---
    document.getElementById('save-code-changes-button').addEventListener('click', saveCodeChanges);
    document.getElementById('remove-slashes-button').addEventListener('click', removeLeadingSlashes);
    document.getElementById('code-review-cancel-button').addEventListener('click', closeCodeReview);
    document.getElementById('confirm-download-button').addEventListener('click', confirmAndDownload);

    // --- Auth Modal ---
    document.getElementById('login-submit').addEventListener('click', handleLogin);
    document.getElementById('signup-submit').addEventListener('click', handleSignup);

    // --- Project Browser Modal ---
    document.getElementById('create-new-project-button').addEventListener('click', () => {
        clearCurrentProject();
        showProjectBrowser(false);
    });
    
    // --- Modal Closing ---
    document.querySelectorAll('.modal-close').forEach(btn => {
        btn.closest('.modal-overlay').addEventListener('click', (e) => {
            if (e.target === e.currentTarget || e.target.classList.contains('modal-close')) {
                e.currentTarget.style.display = 'none';
            }
        });
    });

    // --- Code Explorer Event Delegation ---
    document.getElementById('codeOutput').addEventListener('click', handleCodeOutputClick);
}
function applyDimensions(){ /* TODO: Implement if needed */ }


function handleCodeOutputClick(e) {
    const target = e.target;
    const action = target.dataset.action;
    if (!action) return;

    const funcName = target.dataset.func;
    const button = target;
    const controls = button.closest('.edit-controls, .edit-buttons');
    const codeBlock = button.closest('.code-block');

    switch (action) {
        case 'edit-content-ai':
            editCurrentContent(button);
            break;
        case 'edit-manual':
            // toggleCodeEdit(codeBlock, funcName); // Assuming toggleCodeEdit exists
            break;
        case 'save-manual':
            // saveCodeEdit(codeBlock, funcName); // Assuming saveCodeEdit exists
            break;
        case 'edit-ai':
            // editFunctionWithAI(funcName); // Assuming editFunctionWithAI exists
            break;
        case 'show-func':
            showFunction(funcName);
            break;
        case 'nav-back':
            navigateHistory('back');
            break;
    }
}


function showAuthModal(show) {
    document.getElementById('auth-modal').style.display = show ? 'block' : 'none';
    document.getElementById('auth-message').textContent = '';
}

function showProjectBrowser(show) {
    document.getElementById('project-browser-modal').style.display = show ? 'block' : 'none';
    document.getElementById('project-message').textContent = '';
}

async function handleLogin() {
    const username = document.getElementById('auth-username').value;
    const password = document.getElementById('auth-password').value;
    const messageEl = document.getElementById('auth-message');

    if (!username || !password) {
        messageEl.textContent = 'Please enter both username and password.';
        return;
    }
    messageEl.textContent = 'Logging in...';

    try {
        const user = await api.login(username, password);
        currentUser = user;
        localStorage.setItem('currentUser', JSON.stringify(user));
        updateUserUI();
        showAuthModal(false);
        handleOpenProjectBrowser();
    } catch (error) {
        messageEl.textContent = `Login failed: ${error.message}`;
    }
}

async function handleSignup() {
    const username = document.getElementById('auth-username').value;
    const password = document.getElementById('auth-password').value;
    const messageEl = document.getElementById('auth-message');

    if (!username || !password) {
        messageEl.textContent = 'Please enter both username and password.';
        return;
    }
    messageEl.textContent = 'Signing up...';

    try {
        const response = await api.signup(username, password);
        messageEl.textContent = 'Signup successful! Please log in.';
    } catch (error) {
        messageEl.textContent = `Signup failed: ${error.message}`;
    }
}

function handleLogout() {
    currentUser = null;
    localStorage.removeItem('currentUser');
    updateUserUI();
    clearCurrentProject();
}

async function handleOpenProjectBrowser() {
    if (!currentUser) {
        showAuthModal(true);
        return;
    }
    showProjectBrowser(true);
    const container = document.getElementById('project-list-container');
    container.innerHTML = '<p>Loading projects...</p>';

    try {
        const projects = await api.listProjects(currentUser.id);
        if (projects.length === 0) {
            container.innerHTML = '<p>No projects found. Start a new one!</p>';
        } else {
            container.innerHTML = '';
            projects.forEach(proj => {
                const item = document.createElement('div');
                item.className = 'project-item';
                item.innerHTML = `
                    <span class="project-item-name">${escapeHtml(proj.name)}</span>
                    <div class="project-item-actions">
                        <button class="load-btn">Load</button>
                        <button class="delete-btn delete">Delete</button>
                    </div>
                `;
                item.querySelector('.load-btn').onclick = () => handleLoadProject(proj.id);
                item.querySelector('.delete-btn').onclick = () => handleDeleteProject(proj.id, proj.name);
                container.appendChild(item);
            });
        }
    } catch (error) {
        container.innerHTML = `<p class="error-message">Error loading projects: ${error.message}</p>`;
    }
}

async function handleLoadProject(projectId) {
    showProjectBrowser(false);
    showToast(`Loading project...`);
    try {
        const project = await api.loadProject(currentUser.id, projectId);
        const projectData = JSON.parse(project.projectData);
        await applyLoadedProjectData(projectData);
        currentProjectId = projectId; 
        currentProjectName = projectData.name || 'Untitled Project';
        showToast('Project loaded successfully!');
    } catch (error) {
        alert(`Failed to load project: ${error.message}`);
    }
}

async function handleDeleteProject(projectId, projectName) {
    if (!confirm(`Are you sure you want to delete "${projectName}"? This cannot be undone.`)) {
        return;
    }
    try {
        await api.deleteProject(currentUser.id, projectId);
        showToast('Project deleted.');
        handleOpenProjectBrowser();
    } catch (error) {
        alert(`Failed to delete project: ${error.message}`);
    }
}

async function handleSaveProject() {
    if (!currentUser) {
        alert('Please log in to save projects to the cloud.');
        return;
    }

    if (!currentProjectId) {
        const name = prompt('Please enter a name for this new project:', currentProjectName);
        if (!name) return; 
        currentProjectName = name;
        currentProjectId = `proj_${Date.now()}`;
    }
    
    showToast('Saving project to cloud...');
    try {
        const projectData = await gatherProjectDataForSaving();
        api.saveProject(currentUser.id, currentProjectId, projectData);
        showToast(`Project "${currentProjectName}" is being saved.`);
    } catch (error) {
        alert(`Failed to save project: ${error.message}`);
    }
}

async function gatherProjectDataForSaving() {
    const data = {
        name: currentProjectName,
        isZipProject,
        currentFilePath,
        currentWebsiteCode,
        projectFiles: {}
    };

    if (isZipProject) {
        for (const [path, file] of Object.entries(projectFiles)) {
             if (file.type === 'text') {
                data.projectFiles[path] = { type: 'text', content: file.content };
            } else if ((file.type === 'image' || file.type === 'binary') && file.blob) {
                data.projectFiles[path] = {
                    type: file.type,
                    content: await blobToBase64(file.blob),
                    mimeType: getMimeType(path)
                };
            }
        }
    }
    return data;
}

async function applyLoadedProjectData(data) {
    await clearCurrentProject(); 
    isZipProject = data.isZipProject;
    currentFilePath = data.currentFilePath;
    currentWebsiteCode = data.currentWebsiteCode;
    projectFiles = {};

    if (isZipProject && data.projectFiles) {
        for (const [path, fileData] of Object.entries(data.projectFiles)) {
            if (fileData.type === 'text') {
                projectFiles[path] = { type: 'text', content: fileData.content };
            } else if (fileData.type === 'image' || fileData.type === 'binary') {
                const blob = await base64ToBlob(fileData.content, fileData.mimeType);
                projectFiles[path] = {
                    type: fileData.type,
                    blob: blob,
                    url: URL.createObjectURL(blob)
                };
            }
        }
        renderFileTree();
        if (currentFilePath) {
            await loadProjectFile(currentFilePath);
        }
    } else if (currentWebsiteCode) {
        await processHTMLContent(currentWebsiteCode);
    }
}


function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result.split(',')[1]);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

async function base64ToBlob(base64, mimeType = '') {
    const res = await fetch(`data:${mimeType};base64,${base64}`);
    return await res.blob();
}

function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => resolve(e.target.result);
    reader.onerror = e => reject(new Error('File read failed'));
    reader.readAsText(file);
  });
}

// --- APP INITIALIZATION ---
document.addEventListener('DOMContentLoaded', initApp);
  
</script>
</body>
  </html>
